Ниже — вариант того самого `architecture.txt`: максимально абстрактное описание архитектуры и принципов разработки, рассчитанное на то, что с ним будут работать и люди, и ИИ.

---

# Архитектура проекта (Tower Tetris 3D)

## 0. Назначение документа

Этот документ описывает **архитектуру и принципы организации кода** для браузерной 3D‑игры.

Документ **намеренно абстрактный**:

* не фиксирует конкретные имена файлов, директорий и классов;
* не привязан к конкретному фреймворку (three.js упоминается только как пример 3D‑библиотеки);
* описывает уровни, роли и правила взаимодействия модулей.

Когда в документе используется слово **«модуль»**, это может означать:

* отдельный файл;
* набор файлов;
* логический компонент внутри каталога.

Конкретное физическое разбиение по файлам задаётся в ТЗ и/или в отдельном плане разработки.

---

## 1. Базовые принципы

Все решения в проекте должны соответствовать следующим принципам:

1. **Чёткое разделение ответственности**

   * У каждого модуля одна понятная роль.
   * Игровая логика не знает о рендеринге и DOM.
   * Код, работающий с конкретной библиотекой (3D, аудио и т.д.), изолирован в своём слое.

2. **Слоистая архитектура и направленные зависимости**

   * Высокоуровневые модули опираются на абстракции низкоуровневых, а не наоборот.
   * Зависимости идут **в одну сторону**, циклических импортов быть не должно.

3. **Тестируемость**

   * Основная игровая логика реализована как чистые функции / классы без побочных эффектов.
   * Их можно тестировать без браузера, WebGL и реального рендера.

4. **Минимизация глобального состояния**

   * Нет «магических» синглтонов с доступом отовсюду.
   * Состояние передаётся явно через параметры конструкторов / функций.

5. **Простота поверх излишней абстракции**

   * Не вводить сложные паттерны «на будущее».
   * Если задача решается простой структурой данных и функцией — так и делать.

6. **Читаемость важнее краткости**

   * Код пишется для людей, а не для компилятора.
   * Предпочитать явные имена, разбиение логики на маленькие функции и комментирование важных решений.

7. **Ограниченный размер модулей**

   * Модуль не должен разрастаться до состояния «God‑object».
   * Приблизительное правило:

     * один модуль ≤ ~400–500 строк;
     * одна функция ≤ ~30–40 логических строк;
     * если больше — выделять под‑модули/под‑функции.

---

## 2. Общая слоистая модель

Проект делится на несколько **логических слоёв**. Они должны быть понятны любому новому разработчику/ИИ без знания реализации.

1. **Слой домена (Core / Domain)**

   * Чистая игровая логика.
   * Модели данных (состояние игры, игровое поле, фигуры, правила).
   * Алгоритмы: проверка столкновений, падение фигур, очистка полос/колец, расчёт очков и т.д.
   * Этот слой **не импортирует**:

     * библиотеки для рендера,
     * библиотеки для работы с браузером,
     * фреймворки UI.

2. **Слой рендеринга (Rendering)**

   * Отвечает за отображение состояния игры в 3D.
   * Получает на вход **только данные** из доменного слоя.
   * Не изменяет игровой стейт и не содержит логики правил.
   * Инкапсулирует использование конкретной 3D‑библиотеки (например, three.js).

3. **Слой ввода (Input)**

   * Обрабатывает события клавиатуры/мыши/контроллеров.
   * Преобразует «сырые» события в **абстрактные игровые команды** (например, «сдвинуть фигуру влево», «поворот по часовой»).
   * Не знает деталей реализации логики и рендера, только интерфейс взаимодействия (набор команд/колбеков).

4. **Слой пользовательского интерфейса (UI / HUD / меню)**

   * 2D‑элементы (очки, уровень, подсказки, кнопки меню и т.п.).
   * Может использовать DOM, Canvas 2D или оверлей поверх WebGL.
   * Получает данные из доменного слоя и/или фасада приложения, но не изменяет правила игры напрямую.

5. **Слой оболочки приложения (Application / Shell)**

   * «Склейка» всех вышеописанных слоёв.
   * Запуск игры, главный цикл, инициализация модулей.
   * Управление жизненным циклом: старт/пауза/рестарт, переключение экранов.

**Правило зависимостей:**

* Домейн не зависит ни от чего.
* Рендер, Input, UI зависят от домейна, но не друг от друга напрямую (при необходимости используют событийную шину/фасад).
* Оболочка знает обо всех и связывает их.

---

## 3. Модель данных и доменный слой

### 3.1. Состояние игры

Доменный слой должен иметь **единый объект состояния** (или набор тесно связанных структур), содержащий:

* параметры поля (ширина, высота, радиальная / цилиндрическая геометрия);
* текущее положение и ориентацию активной фигуры;
* уже установленные блоки на поле;
* очереди/стек следующих фигур;
* параметры игрока (очки, уровень, количество очищенных «этажей» и т.п.);
* фазу игры (игра идёт, пауза, анимация уничтожения, game over и т.п.).

**Требования:**

* состояние образует целостную структуру, а не «размазана» по нескольким глобальным объектам;
* изменения состояния происходят через **ограниченный набор функций/методов**, а не произвольной записью в поля.

### 3.2. Операции доменного слоя

Должен существовать набор чистых функций/методов, работающих со стейтом:

* инициализация состояния;
* генерация новой фигуры;
* обработка одного шага симуляции (падение по таймеру, soft drop, hard drop);
* проверка/фиксация фигуры;
* поиск полностью заполненных уровней;
* применение «гравитации» после очистки;
* расчёт очков/уровня.

**Особое правило для ИИ:**
Если нужно реализовать новую игровую механику (доп. тип фигуры, бонусы и т.п.), изменения в первую очередь вносятся в **доменный слой**, а не в рендер/ввод.

---

## 4. Рендеринг и визуальный слой

### 4.1. Роль модуля рендеринга

Модуль рендеринга:

* принимает объект состояния домена (или «снимок» этого состояния);
* отображает его при помощи 3D‑библиотеки;
* занимается только:

  * созданием/обновлением геометрии,
  * материалами,
  * анимацией (например, разлёт обломков),
  * управлением камерой и светом.

Он **не должен**:

* решать, какие уровни очищать;
* пересчитывать очки;
* принимать решения по игровым событиям.

### 4.2. Анимации и временные эффекты

Для анимаций (разрушение этажей, движение камеры, частицы и т.д.) используется отдельная подсистема:

* имеет свой внутренний стейт визуальных эффектов;
* на каждом кадре обновляется в зависимости от `deltaTime`;
* может ссылаться на доменное состояние только для чтения.

Если анимация затрагивает домен (например, переход в другую фазу после окончания анимации уничтожения), **инициатором изменения стейта** должен быть не рендер, а оболочка приложения, которая:

* подписана на события рендерера (например, «анимация завершена»);
* вызывает соответствующий метод доменного слоя.

---

## 5. Ввод (Input)

### 5.1. Абстрактные команды

Слой ввода должен оперировать **командами высокого уровня**, а не непосредственно изменять стейт:

Примеры абстрактных команд (названия условные):

* `MoveLeft`, `MoveRight`;
* `RotateClockwise`, `RotateCounterClockwise`;
* `SoftDrop`, `HardDrop`;
* `PauseToggle` и т.п.

Сами команды можно представлять:

* перечислением (enum);
* объектами с типом и параметрами.

### 5.2. Обработка событий

Модуль ввода:

* слушает события от браузера (клавиатура/мышь/геймпад);
* картирует их в команды;
* складывает команды в очередь/список текущего кадра.

Далее, в основном игровом цикле:

* оболочка передаёт текущий набор команд в доменный слой;
* доменный слой интерпретирует команды и изменяет состояние.

**Правило:** В модуле ввода нельзя напрямую вызывать методы доменного слоя, меняющие стейт. Ввод только сообщает о намерениях пользователя.

---

## 6. Пользовательский интерфейс (UI/HUD/меню)

### 6.1. Роль

UI‑слой:

* выводит статистику (очки, уровень, рекорды);
* отображает подсказки управления;
* реализует меню (старт, пауза, настройки).

UI получает данные:

* либо напрямую из доменного состояния (через «читательский» интерфейс);
* либо из фасада приложения (если удобнее).

### 6.2. Отсутствие бизнес‑логики

В UI **не должно быть**:

* логики тетриса (проверка заполнения этажей, генерация фигур);
* прямых изменений состояния игры.

UI отправляет назад либо:

* абстрактные команды (например, «рестарт игры»),
* либо вызывает методы фасада оболочки, которые затем уже взаимодействуют с доменом.

---

## 7. Оболочка приложения и игровой цикл

### 7.1. Фасад приложения

Должен существовать центральный компонент/фасад, который:

* создаёт экземпляры:

  * состояния домена,
  * доменной логики,
  * рендерера,
  * модуля ввода,
  * UI;
* организует главный цикл;
* управляет фазами игры (старт, пауза, анимация, конец).

### 7.2. Главный цикл

Главный цикл (где-то внутри оболочки приложения) на каждый кадр делает:

1. Получает `deltaTime` с предыдущего кадра.
2. Читает команды из модуля ввода.
3. Передаёт команды и `deltaTime` доменному слою для обновления стейта.
4. Передаёт новый стейт в рендеринг и UI для отображения.
5. Очищает очередь команд ввода.

**Правило:**
Оболочка приложения — единственное место, где одновременно «видны» и домен, и рендер, и ввод. Нельзя допускать, чтобы рендер напрямую тянул команды ввода, или ввод напрямую менял домен.

---

## 8. Организация модулей и ограничения по размерам

### 8.1. Разбиение по ответственности

Каждый модуль должен описываться одной фразой:

> «Этот модуль отвечает за …»

Если описание получается длиннее одного предложения — модуль, скорее всего, делает слишком много и его нужно разделить.

Примеры типов модулей (названия условные):

* модуль состояния игры;
* модуль логики обновления (game rules);
* модуль геометрии поля (цилиндрическая координатная система);
* модуль работы с фигурами (форма, вращение);
* модуль визуального представления башни;
* модуль частиц/эффектов разрушения;
* модуль ввода с клавиатуры;
* модуль отображения HUD.

### 8.2. Ограничения по размеру

Для читаемости и управляемости:

* один модуль (файл) **желательно** держать ≤ ~400 строк кода;
* функции — ≤ 30–40 строк (лучше меньше);
* класс с десятками методов — сигнал, что нужно выделить под‑классы / вспомогательные модули.

**Правило для ИИ:**
Если новый функционал потенциально увеличит размер модуля сверх этих границ, нужно:

1. либо переносить часть логики в существующий более подходящий модуль;
2. либо создавать новый специализированный модуль;
3. либо выделять вспомогательные функции/классы.

---

## 9. Работа с внешними библиотеками (3D, утилиты)

### 9.1. Изоляция зависимостей

Любая внешняя библиотека (3D, математика, аудио, менеджер ресурсов и т.п.) должна быть:

* инкапсулирована в своём модуле/подслое;
* доступна остальному коду через **ограниченный интерфейс** (фасад/адаптер).

Пример принципа (без имён файлов):

* есть модуль «рендеринга», внутри него используются конкретные классы 3D‑библиотеки;
* доменный слой не импортирует 3D‑библиотеку; если ему нужны понятия из 3D (например, векторы), используются либо простые собственные типы, либо интерфейсы, не зависящие от конкретной реализации.

### 9.2. Асинхронная загрузка ресурсов

Логика загрузки текстур/шрифтов/моделей:

* отделена от игровой логики и рендера;
* инкапсулирована в модуле загрузчика ресурсов;
* оболочка приложения:

  * на старте инициирует загрузку;
  * ждёт её завершения (или отображает экран загрузки);
  * только после этого запускает игру.

---

## 10. Тестирование

### 10.1. Что тестировать

В первую очередь тестируется доменный слой:

* корректность падения фигур;
* корректность проверки заполнения уровней;
* корректность очистки и «гравитации»;
* подсчёт очков и уровней;
* корректное поведение при граничных ситуациях (верх поля заполнен и т.п.).

Рендер, ввод и UI могут иметь минимальное количество тестов (например, smoke‑тесты), упор идёт на ручное тестирование.

### 10.2. Требования к коду для тестируемости

* функции доменного слоя не должны иметь скрытых зависимостей от глобальных переменных;
* при необходимости использования случайности — инжектировать генератор случайных чисел;
* время (`deltaTime`) всегда передаётся параметром.

---

## 11. Рекомендации по взаимодействию с ИИ/кодогенератором

Когда ИИ генерирует или изменяет код, нужно придерживаться следующих правил:

1. **Сохранять архитектурные границы**

   * Не добавлять рендер‑код в доменный слой.
   * Не вставлять логику правил в модуль рендеринга.
   * Не делать прямые импорты внешних библиотек в слои, где этого быть не должно.

2. **Минимизировать дублирование**

   * Если в проекте уже есть модуль, который частично решает задачу, расширять его либо явно использовать, а не создавать похожий с нуля.
   * Избегать копипасты существующих функций с мелкими изменениями — выносить общую часть в утилиту.

3. **Соблюдать размеры модулей и функций**

   * Если сгенерированный код превращает модуль в «многотысячник», разнести по под‑модулям.
   * При необходимости ИИ должен предлагать, как именно разбить модуль на части.

4. **Ненарушаемые инварианты**

   * Единый источник истины — объект состояния игры.
   * Все изменения состояния происходят через официальные функции доменного слоя.
   * Никаких скрытых «подправлений» стейта из рендера/ввода.

---

## 12. Какие ещё инструкции/файлы нужны

Для комфортной работы (и людей, и ИИ) достаточно следующего набора документов:

1. **`TZ.txt`**

   * Сухое, но полное описание функциональности игры (что именно должна уметь).
   * Без архитектурных деталей.

2. **`plan.txt`**

   * Пошаговый план разработки: этапы, подзадачи, приоритеты.
   * Здесь можно уже ссылаться на уровни архитектуры (например, «сначала реализовать доменный слой без рендера»).

3. **`architecture.txt`** (этот документ)

   * Высокоуровневая архитектура, слои, зависимости, принципы.

4. **`convention.txt`**

   * Конкретные правила оформления кода:

     * стиль (TypeScript/JS, форматирование, комментарии);
     * соглашения по именованию;
     * лимиты на размеры файлов/функций;
     * структура модулей;
     * правила работы с ветками/коммитами (если нужно);
     * дополнительные best‑practice вроде обработки ошибок, логирования и т.п.

Отдельный файл **бест‑практис** делать не обязательно — их логично зашить в `convention.txt`.
Если проект со временем сильно вырастет, имеет смысл позже добавить ещё один документ:

* `decisions.md` (или `ADR` — архитектурные решения) — краткие записи о важных принятых решениях и почему именно так.

Но на старт **достаточно** связки: `TZ.txt` + `plan.txt` + `architecture.txt` + `convention.txt`.

Если хочешь, в следующем запросе могу как раз сформировать содержимое `convention.txt` с очень конкретными правилами стиля, именования, размера файлов и т.п., заточенное под работу с ИИ.


## 13. Наблюдаемость, диагностика 3D и 3d_helper_system

Архитектура проекта должна изначально поддерживать **наблюдаемость** (observability)
и диагностируемость 3D‑логики. Это критично для работы с нейросетью и для
отладки сложных визуальных багов.

1. **Экспорт состояния в виде данных**

   Любой модуль, связанный с 3D‑сценой (рендеринг, камера, движение, анимации,
   коллизии, разрушения и т.п.), должен быть спроектирован так, чтобы:

   - можно было извлекать его состояние в виде простых структур данных
     (позиции, ориентации, логические координаты, векторы `forward/up/right`,
     bounding volume, контакты/коллизии и т.д.);
   - эти данные можно было сериализовать в стабильный и простой формат
     (JSON/текст), пригодный для анализа нейросетью и людьми.

2. **Поддержка тестовых стендов и лабораторий**

   При проектировании новых 3D‑подсистем (движение, коллизии, камера,
   разрушаемые этажи, спецэффекты) необходимо:

   - предусматривать возможность запуска их в изолированных «лабораториях»
     (минимальных сценах), где:
     - мало объектов,
     - есть контролируемый сценарий,
     - можно включать расширенное логирование;
   - не связывать жизненно важные механики с конкретным игровым сценарием,
     а держать их в виде переиспользуемых модулей, которые легко тестировать
     отдельно.

3. **Инварианты и проверки**

   Для ключевых 3D‑подсистем должны быть явно сформулированы **инварианты**,
   например:

   - «две логически разные клетки не могут иметь пересекающихся коллайдеров»;
   - «камера не может оказаться ниже определённого уровня»;
   - «после очистки слоя логически пустые ячейки не имеют визуальных блоков».

   Архитектура должна позволять интегрировать эти инварианты:

   - в виде assert‑ов;
   - в виде периодических проверок;
   - в виде отдельных диагностических отчётов.

4. **Связь с 3d_helper_system**

   Файл `3d_helper_system.txt` описывает методологии построения тестовых стендов,
   лабораторий, логов и инвариантов для 3D‑сцен. При проектировании и
   развитии 3D‑подсистем (особенно связанных с координатами, движением,
   коллизиями и разрушаемыми структурами) архитектура должна:

   - облегчать внедрение этих методологий;
   - не препятствовать добавлению логгеров, экспортёров состояния и отдельных
     стендов;
   - поощрять разделение «игровой логики» и «диагностической обвязки», чтобы
     последнюю можно было включать/отключать без ломки архитектуры.

   При обсуждении или изменении архитектуры 3D‑частей ИИ должен учитывать
   `3d_helper_system.txt` как официальный источник требований к наблюдаемости
   и 3D‑диагностике.
