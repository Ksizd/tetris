Ниже — содержимое `plan.txt`. Это **рабочий план для нейросети и людей**, по которому можно поэтапно собирать весь проект, соблюдая `architecture.txt` и `convention.txt`.

---

# План разработки 3D Tower Tetris (plan.txt)

## Контекст проекта и использование 3d_helper_system

Этот план относится к браузерной 3D‑игре «Tower Tetris 3D» — вариации тетриса,
где игровое поле представляет собой цилиндрическую башню из кубиков в стиле
Mahjong. Игрок управляет падающими фигурами в 3D‑пространстве, вращая их вокруг
башни и заполняя уровни. При заполнении полного кольца этаж башни разрушается
с визуальными эффектами.

План описывает последовательность реализации функциональности, но **умышленно
не расписывает подробно 3D‑диагностику и тестовые стенды**. Для любых этапов,
которые затрагивают:

- 3D‑геометрию и преобразование координат;
- движение и ориентацию объектов;
- коллизии, физику и размещение в пространстве;
- камеру и визуальные эффекты разрушения;

при необходимости должны использоваться методологии из файла
`3d_helper_system.txt` (лаборатории, инварианты, логи, диагностические отчёты).

Этот файл является **кросс‑проектным дополнением**: он задаёт общие подходы к
тестированию и диагностике 3D‑сцен, поэтому его можно применять и в других
3D‑проектах с другим планом, но с общей архитектурой и конвенциями.


## 0. Как пользоваться этим планом

* Работать **по этапам и подэтапам**, не перепрыгивая вперёд.
* В каждом запросе к нейросети явно указывать, **какой пункт / подпункт** сейчас реализуется (например: `Этап 3.2`).
* В одном запросе — **ограниченный, чёткий подэтап**, чтобы код получался сфокусированным.
* При реализации подэтапа нейросеть:

  * следует архитектуре (`architecture.txt`);
  * следует конвенциям (`convention.txt`);
  * не меняет другие части проекта без необходимости;
  * при необходимости затронуть существующий код — описывает, **какие именно изменения** и почему.

Структура плана:

* **Этапы** (1, 2, 3, …) — крупные блоки работ.
* **Подэтапы** (1.1, 1.2, …) — то, что разумно делать за 1–3 запроса к нейросети.
* **Подподэтапы** (1.2.1…) — если нужно ещё сильнее раздробить задачу.

---

## Этап 1. Инициализация проекта и инфраструктуры

### 1.1. Базовая структура проекта

**Цель:** создать минимальный, но аккуратный каркас проекта без реализации игры.

[ ] 1.1.1. Создать базовый проект (без сборщика или с простым Vite/webpack/esbuild по выбору).
[ ] 1.1.2. Организовать корневую структуру каталогов, например (пример, а не жёсткое требование):

* `src/`

  * `core/` — доменный слой (логика игры, без браузера).
  * `app/` — слой приложения (игровая сессия, команды, главный цикл).
  * `render/` — рендеринг 3D.
  * `input/` — ввод.
  * `ui/` — HUD, меню.
  * `util/` — общие утилиты.
* `public/` — статические ресурсы (иконки, текстуры и т.д.).

[ ] 1.1.3. Создать пустой `index.html` с `<canvas>` или контейнером для WebGL и базовым `<div>` для HUD.
[ ] 1.1.4. Создать **главную точку входа** (например `src/main.ts`), которая пока просто:

* находит в DOM контейнер для рендера;
* пишет в консоль, что приложение запущено.

### 1.2. Настройка языка и качества кода

[ ] 1.2.1. Включить TypeScript:

* настроить `tsconfig` с strict‑режимом;
* указать целевой стандарт ES2020+.

[ ] 1.2.2. Настроить форматирование и линтинг (по желанию):

* Prettier / ESLint или аналог, согласно `convention.txt`.

[ ] 1.2.3. Добавить базовую структуру тестов (если используется тестовый фреймворк):

* решить, какой фреймворк (Jest/Vitest и т.д.);
* подготовить 1 простой тест «Hello test», чтобы убедиться, что всё работает.

**Критерий завершения Этапа 1:**
Проект собирается и запускается, в консоли браузера видно простое сообщение, тесты (если есть) проходят.

---

## Этап 2. Доменный слой: геометрия поля и базовые типы

Цель этапа — создать ядро, описывающее цилиндрическое поле и ячейки, **без фигур и правил**.

### 2.1. Базовые типы и константы домена

[ ] 2.1.1. Определить конфигурационный тип для размеров поля:

* ширина (кол-во секторов по окружности),
* высота (кол-во уровней по вертикали).

[ ] 2.1.2. Определить перечисления/типы для:

* типа содержимого ячейки (`empty`, `block` и т.п.);
* статуса игры (будет использоваться позже, но можно описать тип уже сейчас).

[ ] 2.1.3. Создать набор доменных констант:

* стандартные размеры поля (по умолчанию, но не жестко захардкоженные);
* параметры по умолчанию для уровней (будут расширены на Этапе 4).

### 2.2. Координаты цилиндрического поля

[ ] 2.2.1. Реализовать утилиту для манипулирования координатами:

* структура `CellCoord { x: number; y: number; }` (или аналогичный тип).

[ ] 2.2.2. Реализовать функции:

* нормализация `x` по ширине (`wrapX`, модуль по ширине поля);
* проверка валидности координат (`isInsideBoard`);
* получение соседних ячеек (влево/вправо/вверх/вниз) в терминах цилиндра.

[ ] 2.2.3. Написать **юнит‑тесты** на:

* корректность обёртки по `x`;
* корректность проверки границ по `y`;
* сценарии `x = -1`, `x = width`, большие/отрицательные значения.

### 2.3. Модель поля (Board)

[ ] 2.3.1. Спроектировать тип/класс `Board` (без логики фигур):

* хранит сетку `height x width` с флагами занятости (занято / пусто / тип блока);
* предоставляет методы:

  * чтения клетки (`getCell`),
  * записи (`setCell`),
  * очистки строки по `y`,
  * проверки, полностью ли заполнен слой (строка `y`).

[ ] 2.3.2. Реализовать конструктор/фабрику для создания пустой доски с заданными размерами.

[ ] 2.3.3. Реализовать методы:

* `isLayerFull(y)` — заполнен ли этот уровень;
* `clearLayer(y)` — очистить один уровень (без «гравитации»);
* `clone()` или безопасный способ получить копию (для тестов/симуляций).

[ ] 2.3.4. Написать тесты:

* создание пустой доски;
* установка и считывание ячейки;
* работа `isLayerFull` при разных конфигурациях;
* очистка строки и сохранение остальных.

**Критерий завершения Этапа 2:**
Есть устойчивый доменный модуль `Board` + утилиты координат, полностью покрытые базовыми тестами, без привязки к рендеру и UI.

---

## Этап 3. Доменный слой: фигуры (тетримино) и коллизии

Цель — описать фигуры, их вращение и базовую коллизию с полем.

### 3.1. Описание фигур

[ ] 3.1.1. Создать тип `PieceType` (enum: I, O, T, S, Z, J, L).

[ ] 3.1.2. Сформировать структуру данных для базовых форм фигур (например, в локальных координатах 4x4):

* каждая фигура описывается списком относительных координат блоков;
* для квадрата `O` вращения тривиальны (можно не хранить отдельные ориентации).

[ ] 3.1.3. Определить тип/структуру `PieceOrientation` (0..3).

[ ] 3.1.4. Создать модуль/серивис, который:

* предоставляет данные о блоках фигуры для заданного `PieceType` и ориентации;
* не знает о поле, только о фигуре.

### 3.2. Вращение фигур

[ ] 3.2.1. Реализовать функцию/метод:

* `rotatePiece(piece, direction)` — возвращает новую ориентацию, учитывая 4 состояния.

[ ] 3.2.2. Определить, используем ли **простое вращение** или систему wall‑kick (на старте можно простое, без сложных стенок).

[ ] 3.2.3. Написать тесты:

* корректность ориентаций и последовательности вращений;
* наличие всех блоков после вращения (их количество не меняется);
* для фигур, где форма “не меняется” (O), убедиться, что результат стабилен.

### 3.3. Позиционирование фигуры на поле

[ ] 3.3.1. Определить тип `ActivePiece`:

* `type` (PieceType);
* `orientation`;
* `position` (CellCoord) — базовая точка, относительно которой считаются блоки фигуры (например, левый нижний блок или условный центр).

[ ] 3.3.2. Реализовать функцию:

* `getWorldBlocks(piece)` — возвращает список координат всех блоков фигуры в мировых координатах поля с учётом обёртки по `x`.

[ ] 3.3.3. Написать тесты:

* простое позиционирование;
* обёртка по `x` при `position.x` у границы;
* корректность `y` (наружу поля не делаем обёртку, только проверку).

### 3.4. Проверка коллизий фигуры с полем

[ ] 3.4.1. Реализовать функцию:

* `canPlacePiece(board, piece)` — проверяет, что все блоки:

  * находятся в пределах по `y` (не ниже 0, но могут быть выше `height - 1` при спауне);
  * не пересекаются с занятыми ячейками доски (если `y` в пределах доски).

[ ] 3.4.2. Реализовать функции:

* `canMove(piece, dx, dy)` — проверяет возможность смещения;
* `canRotate(piece, direction)` — проверяет возможность вращения.

[ ] 3.4.3. Написать тесты:

* коллизия с нижней границей;
* коллизия со стенками в терминах цилиндра (левая/правая сравниваются через обёртку);
* коллизия с уже занятыми блоками.

**Критерий завершения Этапа 3:**
Фигуры и коллизии полностью работают и покрыты тестами, без каких‑либо 3D или UI.

---

## Этап 4. Доменный слой: правила игры и состояние

### 4.1. Структура `GameState`

[ ] 4.1.1. Создать тип/класс `GameState`, который содержит:

* `board` — игровое поле;
* `currentPiece` — активная фигура или `null`;
* `nextPieces` — очередь следующих фигур;
* `score`, `level`, `linesCleared` (этажей очищено);
* флаг/enum `gameStatus` (`running`, `paused`, `clearing`, `gameOver`, и т.п.);
* любые дополнительные счётчики для таймингов (progress падения и т.д. — можно в отдельной структуре).

[ ] 4.1.2. Реализовать функцию/конструктор `createInitialGameState(config)`.

### 4.2. Генерация фигур

[ ] 4.2.1. Создать модуль генерации фигур:

* тип генератора (например, класс/функция), которому можно передать seed (для тестов);
* простой алгоритм (рандом с равномерным распределением или классический “мешок” из 7 фигур).

[ ] 4.2.2. Реализовать методы:

* `getNextPiece()` — достаёт фигуру из генератора/очереди;
* `peekNextPiece()` — смотрит следующую для HUD.

[ ] 4.2.3. Обновить `GameState`, чтобы при создании сразу заполнялась очередь следующих фигур.

### 4.3. Логика падения и шаг симуляции

[ ] 4.3.1. Определить в домене параметры для скорости падения:

* базовый интервал падения в секундах/тик;
* зависимость от уровня (будет масштабировать время).

[ ] 4.3.2. Реализовать функцию `tickGame(state, deltaTime)`, которая:

* обновляет внутренний таймер падения;
* когда накоплено достаточно времени:

  * пытается опустить фигуру вниз (`dy = -1`);
  * если не может — запускает **процесс фиксации фигуры**.

[ ] 4.3.3. Обработать сценарий, когда текущей фигуры нет (например, после фиксации до генерации новой):

* создать новую фигуру сверху;
* проверить, не завершена ли игра (коллизия при спауне);
* при невозможности спауна — `gameStatus = gameOver`.

### 4.4. Фиксация фигуры и очистка слоёв

[ ] 4.4.1. Реализовать функцию `lockCurrentPiece(state)`, которая:

* записывает блоки фигуры в `board`;
* сбрасывает `currentPiece` в `null`.

[ ] 4.4.2. Реализовать функцию `findFullLayers(board)`:

* возвращает массив уровней `y`, где строка полностью заполнена.

[ ] 4.4.3. Спроектировать 2‑стадийную очистку:

1. После фиксации:

   * найти все заполненные уровни;
   * если их нет — перейти к спауна новой фигуры;
   * если есть:

     * сохранить список очищаемых уровней в состояние;
     * поменять статус игры на `clearing` (для визуальных эффектов).
2. Отдельная функция/стадия:

   * по завершении анимации (об этом сообщит Application/Rendering) вызвать доменную функцию:

     * окончательно удалить эти уровни;
     * “ронять” верхние строки вниз;
     * обновить счёт и уровень;
     * вернуть статус в `running` и сгенерировать новую фигуру.

### 4.5. Система очков и уровней

[ ] 4.5.1. Определить и реализовать:

* шкалу очков за количество очищенных уровней за один ход (1,2,3,4 и т.д.);
* бонусы за «комбо» (опционально).

[ ] 4.5.2. Реализовать логику повышения уровня:

* при достижении определённого количества очищенных слоёв или очков;
* уменьшать интервал падения.

### 4.6. Обработка команд игрока на уровне домена

[ ] 4.6.1. Определить абстрактный тип команд (например `GameCommand`):

* `MoveLeft`, `MoveRight`,
* `RotateCW`, `RotateCCW`,
* `SoftDrop`, `HardDrop`,
* `TogglePause` и т.п.

[ ] 4.6.2. Создать функцию `applyCommand(state, command)`, которая:

* в зависимости от команды:

  * пытается сместить/повернуть фигуру (через `canMove` / `canRotate`);
  * выполняет soft/hard drop;
  * переключает паузу (статус игры).

[ ] 4.6.3. Написать тесты:

* серия команд приводит к ожидаемой конфигурации;
* hard drop действительно доводит фигуру до упора и запускает фиксацию;
* soft drop ускоряет падение без “телепорта”.

**Критерий завершения Этапа 4:**
Доменный слой умеет:

* поддерживать полное состояние игры;
* двигать и вращать фигуры по командам;
* фиксировать фигуры, чистить слои и считать очки/уровни;
  — всё это без единой строчки WebGL/DOM кода.

---

## Этап 5. Application Layer: игровой контроллер и главный цикл

Цель — создать “мозг” приложения, который связывает домен с временем и командами, но ещё не знает о 3D‑рендере.

### 5.1. Командный интерфейс приложения

[ ] 5.1.1. Создать класс/модуль Application‑слоя (условно `GameController`), который:

* держит экземпляр `GameState`;
* предоставляет методы:

  * `update(deltaTime)` — один шаг симуляции;
  * `enqueueCommand(command)` — передать команду от ввода;
  * `getSnapshot()` — вернуть **read‑only** снимок состояния для рендера и UI.

[ ] 5.1.2. Внутри `update`:

* забрать очередь команд;
* последовательно применить их к состоянию через `applyCommand`;
* вызвать `tickGame` с `deltaTime`;
* возвращать/сохранять информацию о произошедших **событиях** (см. 5.2).

### 5.2. Система событий

[ ] 5.2.1. Определить тип/enum событий (**Domain Events**), например:

* `LinesCleared` (с информацией, какие уровни и сколько);
* `PieceLocked`;
* `NewPieceSpawned`;
* `GameOver`.

[ ] 5.2.2. В `update` накапливать события за шаг симуляции:

* чтобы рендер и UI могли реагировать (например, запускать анимации разрушения).

[ ] 5.2.3. Реализовать метод `getEvents()` или возвращать события из `update`.

### 5.3. Интеграционные тесты (без рендера)

[ ] 5.3.1. Написать несколько сценариев:

* фигура падает и блокируется;
* последовательность, приводящая к очистке уровня;
* переход в состояние `gameOver`.

[ ] 5.3.2. Убедиться, что через `GameController` корректно прокладывается весь поток:

* команда → изменения состояния → события.

**Критерий завершения Этапа 5:**
Есть “чистый” игровой контроллер, который можно запускать в любой среде (даже в Node.js), чтобы симулировать игру.

---

## Этап 6. Rendering: базовая 3D‑сцена

Цель — поднять минимальную 3D‑сцену с башней из кубиков и без полноценной игры.

### 6.1. Инициализация рендера

[ ] 6.1.1. Создать модуль рендера, который:

* инициализирует Three.js (или выбранную 3D‑библиотеку);
* создаёт `Scene`, `Camera`, `Renderer`.

[ ] 6.1.2. Камера:

* перспективная;
* расположена так, чтобы башня целиком помещалась в кадр;
* смотрит на центр сцены.

[ ] 6.1.3. Освещение:

* хотя бы один `AmbientLight` и один `DirectionalLight`.

[ ] 6.1.4. Отрисовать тестовый примитив (один куб), чтобы проверить, что всё работает.

### 6.2. Связь рендера с DOM и resize

[ ] 6.2.1. Подключить canvas рендера к DOM (через контейнер).
[ ] 6.2.2. Реализовать обработку изменения размера окна:

* изменять размер рендера;
* обновлять aspect ratio камеры.

### 6.3. Главный рендер‑цикл

[ ] 6.3.1. Реализовать анимационную петлю:

* `requestAnimationFrame`;
* вычисление `deltaTime` (в секундах).

[ ] 6.3.2. На каждом кадре:

* вызывать `GameController.update(deltaTime)` (позже, после подключения контроллера);
* вызывать ф-цию `renderScene(snapshot)`.

На этом этапе snapshot можно временно подделывать (статичный тестовый стейт), чтобы просто видеть башню.

**Критерий завершения Этапа 6:**
В браузере видна 3D‑сцена, рендер обновляется по кадрам, камера и свет настроены базово.

---

## Этап 7. Rendering: отображение башни и поля

Цель — научиться визуализировать `Board` как цилиндрическую башню из кубиков.

### 7.1. Преобразование координат поля в 3D‑пространство

[ ] 7.1.1. Создать модуль/утилиту `BoardToWorldMapper`:

* функции:

  * `cellToWorldPosition(x, y)` → `Vector3`;
  * учитывает:

    * радиус цилиндра;
    * высоту блока;
    * обёртку `x` на окружность.

[ ] 7.1.2. Задать константы для:

* `blockSize`;
* `towerRadius`;
* `verticalSpacing` (обычно = `blockSize`).

[ ] 7.1.3. Написать небольшие тесты (необязательно авто‑, можно ручные):

* убедиться, что соседние `x` формируют равномерную окружность;
* `y` растёт вверх.

### 7.2. Меши для блоков башни

[ ] 7.2.1. Реализовать базовую геометрию куба (одна форма для всех блоков):

* материал просто цветной (белый / жёлтый), текстуры пока не нужны.

[ ] 7.2.2. Использовать instanced mesh или собственный пул мешей:

* чтобы не создавать тысяч отдельных объектов в сцене.

[ ] 7.2.3. Реализовать функцию `renderBoard(boardSnapshot)`:

* очищает/обновляет инстансы в зависимости от состояния поля;
* отрисовывает только занятые ячейки.

### 7.3. Визуализация пустоты / внутренней стенки

[ ] 7.3.1. Добавить внутренний цилиндр:

* радиус чуть меньше `towerRadius`;
* материал жёлтый, создающий вид «заполненной» башни внутри.

[ ] 7.3.2. Убедиться, что через “дыры” в башне видно внутреннюю стенку.

**Критерий завершения Этапа 7:**
Игровая доска домена отображается как цилиндрическая башня; изменения в `Board` отражаются в 3D.

---

## Этап 8. Rendering: активная фигура и базовая анимация

### 8.1. Отрисовка активной фигуры

[ ] 8.1.1. Создать отдельный набор мешей/инстансов для текущей фигуры.

[ ] 8.1.2. Реализовать функцию `renderActivePiece(pieceSnapshot)`:

* использует те же правила координат, что и `BoardToWorldMapper`;
* визуально отличает активную фигуру (например, другим оттенком или эмиссией).

### 8.2. Плавная анимация падения и движения

[ ] 8.2.1. В Application‑слой добавить представление “прогресса падения” между клетками (для интерполяции).
[ ] 8.2.2. В рендере:

* позиционировать кубики фигуры с учётом этого прогресса (между `y` и `y-1`);
* при горизонтальном смещении — при желании тоже интерполировать углы.

[ ] 8.2.3. Убедиться визуально, что фигура:

* плавно падает вниз;
* мгновенно/быстро реагирует на команды игрока.

**Критерий завершения Этапа 8:**
Фигура падает, двигается и вращается в 3D в соответствии с доменной логикой.

---

## Этап 9. Input Layer: управление с клавиатуры

### 9.1. Маппинг клавиш на команды

[ ] 9.1.1. Создать модуль ввода (например, `KeyboardInput`), который:

* подписывается на события `keydown` и, возможно, `keyup`;
* отображает клавиши на `GameCommand`:

  * `←` / `→` — MoveLeft / MoveRight;
  * `↑` — RotateCW;
  * `Z` — RotateCCW (опционально);
  * `↓` — SoftDrop;
  * `Space` — HardDrop;
  * `P` — TogglePause.

[ ] 9.1.2. Иметь очередь команд:

* при событии клавиши складывать соответствующую команду в очередь;
* Application‑слой периодически забирает и очищает эту очередь.

### 9.2. Поведение повторения и анти‑дребезг

[ ] 9.2.1. Решить, поддерживаем ли повтор (`auto repeat`) для MoveLeft/MoveRight/SoftDrop:

* можно реализовать простой таймер задержки для начала повторения.

[ ] 9.2.2. Избежать многократного срабатывания hard drop и паузы:

* по `keydown` реагировать только на первый `keydown` до `keyup`.

**Критерий завершения Этапа 9:**
Игрок может управлять фигурой с клавиатуры, команды доходят до домена через Application‑слой.

---

## Этап 10. UI / HUD и игровые статусы

### 10.1. HUD (очки, уровень, следующая фигура)

[ ] 10.1.1. Создать простой 2D‑HUD (DOM или Canvas 2D) поверх WebGL:

* панель с текущим счётом;
* уровень;
* количество очищенных этажей.

[ ] 10.1.2. Добавить окно превью следующей фигуры:

* 2D‑рисунок маленькими квадратиками.

[ ] 10.1.3. Обновлять HUD при каждом рендер‑кадре на основе snapshot из Application‑слоя.

### 10.2. Стартовый экран, пауза, Game Over

[ ] 10.2.1. Определить состояния приложения:

* `mainMenu`, `playing`, `paused`, `gameOver`.

[ ] 10.2.2. Добавить простое меню:

* кнопка “Start Game”;
* опционально “Restart” при Game Over.

[ ] 10.2.3. Реализовать:

* затемнение/оверлей при паузе;
* экран “Game Over” с очками и предложением начать заново.

**Критерий завершения Этапа 10:**
Игра выглядит как цельное приложение: есть HUD, старт/пауза/конец, всё управляется через Application‑слой.

---

## Этап 11. Визуальный стиль: Mahjong‑текстуры, освещение, пол

Цель — приблизиться к рекламному ролику по визуалу.

### 11.1. Материалы и текстуры блоков

[ ] 11.1.1. Подготовить/подключить текстуры Mahjong‑плитки:

* белая “плитка” с красным символом;
* корректная UV‑развёртка для кубика.

[ ] 11.1.2. Обновить материалы блоков:

* внешний слой — текстурированный материал;
* внутренние грани и/или внутренний цилиндр — жёлтый материал.

### 11.2. Свет и тени

[ ] 11.2.1. Настроить освещение:

* направленный свет с мягкой тенью;
* ambient‑свет для заполнения.

[ ] 11.2.2. По возможности включить тени:

* блоки/башня отбрасывают тень на пол.

### 11.3. Пол с отражением

[ ] 11.3.1. Добавить чёрный глянцевый пол:

* плоскость под башней;
* использовать отражения (либо с помощью зеркального материала, либо фейковый отражающий шейдер, либо дублирование сцены вниз с масштабом по Y = -1).

**Критерий завершения Этапа 11:**
Башня выглядит узнаваемо: Mahjong‑блоки, жёлтая внутренняя часть, отражение на полу и приятное освещение.

---

Этап 11x. Визуальный сверх‑полиш башни
Цели этапа

Сделать башню визуально неотличимой от “рекламного” референса или лучше:

правильный ракурс камеры (виден и верх, и низ, башня выглядит монументально, а не “палкой вдали”);

высокая “круглость” цилиндра (52–55 кубиков в окружности или эквивалент);

реалистичные кубики:

белая лицевая грань с красным иероглифом строго по центру;

остальные грани — красивое золото;

сглаженные рёбра (bevel);

заметные, аккуратные зазоры между кубами;

сочный PBR‑материал (блики, отражения, мягкие тени, приятные цвета).

Сделать всё так, чтобы:

это ложилось поверх уже существующей архитектуры рендера;

не ломало доменную логику;

легко расширялось для будущей анимации разрушения.

11x.1. Анализ текущего состояния и выделение параметров

Задача: ввести “набор ручек”, которые можно крутить (камера, размеры, материалы, свет).

[ ] 11x.1.1. Вынести в конфиг (render‑layer) параметры:

towerRadius

blockSize

boardWidth (количество кубиков по окружности)

положение камеры (cameraPosition, cameraTarget)

FOV камеры (cameraFov)

параметры света (интенсивность, цвет, направление)

включение/выключение пост‑эффектов (bloom и т.п.)

[ ] 11x.1.2. Сделать небольшой “режим девелопмента визуала”:

переключатель visualDebugMode или отдельная сцена;

в этом режиме:

нет геймплея (можно поставить статичную конфигурацию башни);

рядом/в консоль выводятся текущие значения основных параметров.

[ ] 11x.1.3. (Опционально) Подготовить простенький UI для твика (например, через dat.GUI / lil-gui):

слайдеры для:

FOV

дистанции камеры

высоты камеры

radius башни

интенсивности света и отражений.

Это сильно ускорит ручную подгонку.

11x.2. Камера и композиция кадра

Цель: башня должна выглядеть как в референсе — целиком в кадре, чуть сверху, с запаса по верх/низ.

[ ] 11x.2.1. Настроить позицию камеры:

камера чуть выше середины башни, смотрит немного вниз:

Y камеры ≈ 0.55–0.65 от высоты башни;

расстояние до центра башни такое, чтобы:

башня полностью влезала по вертикали;

по горизонтали оставался небольшой отступ (чёрный фон или рамка).

[ ] 11x.2.2. Настроить FOV:

подобрать FOV так, чтобы:

башня не выглядела “размазанной палкой” (слишком узкий FOV);

и не была с огромной перспективной деформацией (слишком широкий FOV).

ориентир: FOV ~ 30–45° — но подбирать экспериментально с учётом радиуса.

[ ] 11x.2.3. Реализовать адаптацию под размер окна:

при изменении размера окна:

пересчитывать aspect ratio;

при необходимости чуть подстраивать Z‑позицию камеры, чтобы башня по вертикали всегда целиком помещалась в кадр с небольшим запасом.

[ ] 11x.2.4. Добавить микро‑анимацию камеры (потом, когда всё настроено):

лёгкий “дыхательный” motion:

едва заметное покачивание/орбита вокруг башни с очень маленькой амплитудой,

но это можно оставить ближе к финалу, главное — чтобы базовый статичный ракурс был идеален.

11x.3. Геометрия башни: количество кубиков и “круглость”

Цель: сделать цилиндр визуально гладким, как в референсе (52–55 кубиков вокруг).

[ ] 11x.3.1. Определиться с boardWidth (логической шириной):

вариант A (прямой): установить boardWidth ≈ 52–56, чтобы логика и визуал один к одному → одна логическая колонка = один куб.

вариант B (двухуровневый): оставить логическую ширину меньше (например, 24), но:

визуально рисовать “подсетку” фоновых золотых кубиков с шагом в 52–56 сегментов;

а активные белые кубы занимать несколько визуальных ячеек по окружности.

Для чистоты и простоты (особенно пока проект не в продакшне), лучше:

прямо увеличить boardWidth до требуемого количества, чтобы потом не страдать с проекцией.

[ ] 11x.3.2. Пересчитать радиус башни исходя из:

размер кубика blockSize;

количество кубиков по окружности boardWidth.

Цель: чтобы кубы:

стояли плотно, без зазоров/нахлёстов по окружности;

между ними были видны вертикальные швы (маленький зазор);

но не было видимых “ступенек”.

Формула:
окружность ≈ boardWidth * (blockSize + gap) →
radius ≈ окружность / (2π).

[ ] 11x.3.3. Проверить, что:

при отрисовке уровня:

каждый кубик повёрнут наружу (нормаль лицевой грани смотрит от центра);

отсутствуют визуальные пересечения соседних кубов;

зазоры между кубами не “слишком жирные” и не “слишком нулевые”.

[ ] 11x.3.4. Если логическая ширина была изменена:

убедиться, что все доменные операции (фигуры, вращение, очистка слоёв) корректно работают с новым boardWidth;

возможно, обновить стартовые уровни и настройки (скорость, формы фигур).

11x.4. Кубик как объект: форма, сглаженные рёбра, фаски

Цель: уйти от “плоского простого куба” к “реалистичной плитке”.

[ ] 11x.4.1. Определить пропорции кубика:

чуть сплющенный “брусок” вместо идеального 1×1×1:

например, толщина < ширины/высоты (по желанию);

но важно, чтобы:

лицевая грань была чуть больше выделена;

куб не выглядел “кирпичом для стен”.

[ ] 11x.4.2. Реализовать bevel / chamfer (сглаженные рёбра):

вариант A: геометрия с фасками:

создать кастомную геометрию куба с небольшими скошенными гранями;

или использовать параметризированный “rounded box” (можно написать свой генератор).

вариант B: normal map, если не хочется увеличивать полигоны:

сгенерить/нарисовать нормал‑карту, которая имитирует сглаженные рёбра;

применить её к материалу плитки.

На старте:

лучше сделать реальный геометрический bevel (как минимум по 1 сегменту на ребро),
а потом, если сильно бьёт по производительности, оптимизировать.

[ ] 11x.4.3. Убедиться, что:

фаски не слишком большие (чтобы не было ощущения “резинового кубика”);

на фасках хорошо считываются блики;

не возникает геометрических артефактов (перекрученные нормали, дырки).

11x.5. Текстурирование и UV‑развёртка куба

Цель: лицевая грань — белая плитка с красным иероглифом; остальные — золото. Всё без растягивания/смещений.

[ ] 11x.5.1. Спроектировать UV‑развёртку для куба:

карта 1×1, где:

лицевая грань (та, что смотрит наружу) занимает, например, верхнюю часть текстуры (top area),

остальные 5 граней — нижнюю часть (bottom area) или отдельные сегменты.

[ ] 11x.5.2. Подготовить или описать текстуру:

единая текстура, где:

участок A — белая плитка с красным иероглифом, выровненным по центру;

участок B — золото (можно с лёгким шумом/градиентом для реализма);

важно:

достаточное разрешение (например, 512×512 или 1024×1024, без пикселизации);

иероглиф — не “мыльный”.

[ ] 11x.5.3. Прописать в материале:

лицевой грани UV‑координаты → участок A;

боковым и задним граням → участок B;

следить, чтобы:

иероглиф не обрезался;

не растягивался по диагонали;

не зеркалился.

[ ] 11x.5.4. Проверить куб:

один куб в тестовой сцене;

камеру поднести близко;

убедиться, что:

лицевая плитка читается идеально;

золото выглядит целостно по всем небелым граням.

11x.6. PBR‑материалы: золото и белая керамика

Цель: реализовать реалистичный материал, а не “плоскую заливку”.

[ ] 11x.6.1. Материал белой лицевой грани:

базовый цвет: чуть тёплый белый (слегка кремовый, а не чистый #FFFFFF);

лёгкий shininess:

roughness маленький, но не нулевой;

metalness ближе к 0 (керамика/фарфор, не металл);

опционально:

тонкая карта отражений или AO;

микрошум на roughness для более живого блика.

[ ] 11x.6.2. Материал золота:

базовый цвет — насыщенный жёлто‑золотой;

metalness высокий (~0.8–1.0);

roughness средний или чуть ниже:

не зеркало (это будет “пластилин”), но и не матовая краска;

хорошо реагирует на environment map (отражения окружающего мира);

можно использовать отдельную золото‑текстуру:

с лёгкими вариациями яркости/оттенка;

чтобы не было ощущения “однотонной пластмассы”.

[ ] 11x.6.3. Убедиться, что:

материалы раздельные (не один и тот же для всех граней);

при изменении света золотые грани дают красивые спекулярные блики;

белые плитки не “горят” (не пересвечиваются до клиппинга).

11x.7. Внутренняя поверхность башни и зазоры

Цель: создать ощущение “полой башни”, как в референсе.

[ ] 11x.7.1. Внутренняя стенка:

отдельный цилиндр радиусом чуть меньше, чем радиус кубиков;

материал:

золотой, но чуть менее зеркальный, чем боковые грани кубиков;

без текстуры или с лёгкой шумихой.

[ ] 11x.7.2. Зазоры между кубами:

по окружности → небольшой gap (gapAngle или gapWidth);

по вертикали → небольшой verticalGap:

чтобы между рядами была тонкая тень/щель и кубы не слипались в “монолит”.

[ ] 11x.7.3. Проверить, что:

через зазоры видна внутренняя золотая стенка;

нет пересечений:

кубы не врезаются внутрь цилиндра;

не пересекаются между собой.

11x.8. Свет: постановка “студийного” освещения

Цель: чтобы башня выглядела как предмет в студии product‑фото.

[ ] 11x.8.1. Сцена освещения:

Ambient/Environment light:

мягкий общий свет, чтобы не было полностью чёрных теней;

Key light (главный источник):

направленный свет, имитирующий студийный прожектор;

слегка сбоку и сверху;

тёплый оттенок.

Rim light (контурный):

слабый источник позади башни или сбоку;

подчёркивает границы силуэта.

[ ] 11x.8.2. HDRI‑окружение:

использовать environment map:

для отражений на золотых гранях;

не обязательно видимую фоном (фон может быть просто чёрным);

подобрать карту, которая даёт интересные блики без грязного цвета.

[ ] 11x.8.3. Тени:

включить тени для ключевого света:

башня отбрасывает тень на пол;

кубики отбрасывают тени на внутреннюю стенку и друг на друга;

настроить:

разрешение shadow map;

bias (чтобы не было “лесенок” и дыр).

[ ] 11x.8.4. Пройтись по сцене глазами:

при вращении башни/камеры (даже если это временная отладочная орбита) отражения должны:

“играть” на гранях;

но не превращаться в сплошной наркоманский калейдоскоп.

11x.9. Пол и отражение

Цель: глянцевый чёрный пол с красивым отражением башни, как в референсе.

[ ] 11x.9.1. Геометрия пола:

плоский диск или квадрат под башней;

чуть больше радиуса башни.

[ ] 11x.9.2. Материал пола:

почти чёрный, но не идеально:

чтобы можно было увидеть слабое отражение;

средний metalness, низкий roughness;

пол ловит отражения environment map.

[ ] 11x.9.3. Отражение башни:

вариант A: “фейковое” отражение:

дублировать башню вниз, инвертируя по оси Y, с постепенным Fade по альфе;

вариант B: planar reflection (если захочешь заморочиться);

важно:

не переборщить с яркостью (зеркало пола не должно отвлекать от башни).

11x.10. Пост‑обработка и финальный “кинематограф”

Цель: аккуратно добавить “дорогой” вид: bloom, лёгкая виньетка и т.п.

[ ] 11x.10.1. Bloom:

очень аккуратный:

чтобы золотые и белые блики чуть мягче светились;

но не превращались в засвеченный ад.

[ ] 11x.10.2. Цветокор:

лёгкий контраст;

можно чуть подсогреть общую картинку (тёплый gold + легкая холодная тень → приятно смотрится).

[ ] 11x.10.3. Виньетка:

слабая затемняющая рамка по краям, фокусируя взгляд на башне.

[ ] 11x.10.4. Anti‑aliasing:

убедиться, что:

используется MSAA/WebGL2‑подход или post‑AA (FXAA/SMAA);

на гранях кубиков нет зубцов.

11x.11. Тестовые ракурсы и контроль качества

Цель: гарантировать, что башня выглядит круто во всех разумных ситуациях.

[ ] 11x.11.1. Сделать несколько контрольных ракурсов:

классический референсный вид (как в рекламном видео);

чуть ближе (полукадр верхней части);

общая сцена с низом и отражением.

[ ] 11x.11.2. Для этих ракурсов сделать скриншоты:

сохранить как ref_view_01.png, ref_view_02.png и т.п.

Использовать как “визуальные тесты”:

при дальнейших правках рендера сравнивать, чтобы не ухудшать картинку.

[ ] 11x.11.3. Визуальные инварианты:

кубы никогда не пересекаются визуально;

зазоры читаются, но не режут глаз;

иероглиф всегда в центре белой плитки, без смещения;

золото выглядит как металл, а не как жёлтый пластик;

при любом масштабировании окна башня красиво кадрируется.

11x.12. Связь с 3d_helper_system и дальнейшими этапами

[ ] 11x.12.1. Для визуальных аспектов создать “лабоработорию визуала”:

отдельная сцена/режим, где:

башня загружается в фиксированную конфигурацию;

можно:

переключать разные наборы параметров (presets света/материалов);

делать автоматический рендер скриншотов.

[ ] 11x.12.2. Зафиксировать в документации:

какую комбинацию параметров считать “эталонной” (камера, FOV, свет, материалы);

какие менять нельзя (или только очень осознанно).

[ ] 11x.12.3. Подготовить всё так, чтобы:

Этап 12 (анимация разрушения) уже работал на этой красивой картинке;

любые частицы/обломки наследовали материалы кубиков, чтобы не выпадали из стиля.

---

Этап 11y. Визуальный Overkill: золото, свет, камера
11y.0. Цели этапа

Довести материалы (золото + белая плитка) до состояния “дорогой рекламный рендер”:

золото светлое, металлическое, блестящее, с богатой игрой отражений;

белая лицевая грань — чистая, чуть глянцевая керамика с чётким иероглифом.

Поставить освещение уровня студийной предметной съёмки:

несколько источников света с понятной ролями (key, fill, rim);

HDRI‑окружение с красивыми отражениями;

мягкие тени без шумов и лесенок.

Перестроить камеру и управление:

комфортный игровой ракурс по умолчанию (как в референсе, виден верх и низ башни);

удобная свободная орбитальная камера для осмотра (мышь/колесо, ограничения, сглаживание);

быстрые пресеты (переключение подготовленных ракурсов).

Закрепить всё в виде качественного рендер‑пайплайна:

правильная гамма, тон‑мэппинг, post‑effects;

возможность включать/выключать “ультра‑режим” качества;

набор контрольных скриншотов, по которым можно проверять, что мы не деградировали.

11y.1. Проверка и настройка цвет/гамма пайплайна

Цель: убедиться, что всё, что мы делаем с материалами и светом, не убивается неправильной гаммой.

[ ] 11y.1.1. Проверить, что:

рендерер использует sRGB для цветового пространства:

включена корректная кодировка вывода;

color‑текстуры помечены как sRGB.

линейные значения освещения и PBR рассчитываются в линейном пространстве.

[ ] 11y.1.2. Настроить тон‑мэппинг и экспозицию:

выбрать адекватный оператор (Reinhard / ACES / другой);

подобрать экспозицию так, чтобы:

блики на золоте яркие, но не клипуются в “белое пятно”;

тени остаются читаемыми (не проваливаются в чёрное).

[ ] 11y.1.3. Сделать маленький тест‑сценарий:

один золотой куб и один белый куб над чёрным полом;

один свет;

несколько значений экспозиции;

визуально выбрать “золотую середину” и зафиксировать её как дефолт.

11y.2. Точная настройка материалов плитки
11y.2.1. Белая лицевая грань (керамика/фарфор)

[ ] 11y.2.1.1. Базовый цвет:

использовать слегка тёплый белый, не чистый #FFFFFF;

лёгкий оттенок в сторону кремового, чтобы не было “монитора”.

[ ] 11y.2.1.2. PBR‑параметры:

metalness ≈ 0.0–0.1 (керамика не металл);

roughness ≈ 0.15–0.35:

чтобы был аккуратный блеск, но не зеркало.

[ ] 11y.2.1.3. Текстура:

скорректировать карту белой плитки:

добавить микро‑шум / лёгкую неоднородность;

но не превращать в грязь — плитка должна оставаться “чистой”.

[ ] 11y.2.1.4. Проверка:

крупный план одной плитки:

иероглиф читается чётко;

блики плавно движутся по поверхности при вращении света/камеры.

11y.2.2. Золотые грани

[ ] 11y.2.2.1. Подбор базового цвета:

начать с яркого жёлто‑золотого:

H ≈ жёлтый, S высокий, V высокий;

поэкспериментировать с несколькими вариациями и зафиксировать одну “эталонную” в конфиге.

[ ] 11y.2.2.2. PBR‑параметры:

metalness ≈ 1.0 (почти чистый металл);

roughness ≈ 0.2–0.35:

ниже → слишком зеркально, выше → слишком матово.

[ ] 11y.2.2.3. Текстуры:

при желании — ввести лёгкую gold‑texture:

вариации яркости/цвета на уровне 2–5% от базового;

микрошум, полосочки и т.п. для “жизни”, но очень аккуратно.

[ ] 11y.2.2.4. Спекуляр и отражения:

убедиться, что envMap реально сказывается на золоте:

вращаем башню — видим, как отражения скользят по граням;

есть чёткие блики на фасках и мягкие отражения на плоскостях.

11y.3. HDRI‑окружение и студийный свет
11y.3.1. HDRI / environment map

[ ] 11y.3.1.1. Выбрать HDRI окружение:

светлое, с несколькими яркими источниками (окна, студийные панели);

без слишком яркого мусора/цветных пятен (чтобы отражения были “дорогими”, а не кислотными).

[ ] 11y.3.1.2. Настроить envMapIntensity:

для золота — чуть выше (чтобы отражения были богаче);

для белой плитки — умеренно, чтобы не перебивать сам цвет.

[ ] 11y.3.1.3. Сделать тест:

один золотой куб в центре;

вращать камеру вокруг;

оценить, как играют отражения;

при необходимости скорректировать интенсивность и гамму HDRI.

11y.3.2. “Студийный” свет: key / fill / rim

[ ] 11y.3.2.1. Key‑light (главный):

направленный свет (spot/directional) или area;

позиция: слегка сверху и спереди/сбоку;

цвет: чуть тёплый (например, 5000–6000K условно);

интенсивность:

достаточно высокая, чтобы сформировать яркие блики и читаемые тени.

[ ] 11y.3.2.2. Fill‑light (заполняющий):

более слабый мягкий источник;

позиция со стороны теней;

цвет ближе к нейтральному/слегка холодному;

задача — убить “чёрную дыру” в тенях, оставить детали.

[ ] 11y.3.2.3. Rim‑light (контровой):

источник позади башни или сверху сзади;

слабый, но дающий обводку по краю башни;

помогает отделить башню от фона.

[ ] 11y.3.2.4. Интеграция с HDRI:

сбалансировать, чтобы:

HDRI давал общую “атмосферу” и отражения;

key/fill/rim отвечали за акценты и скульптурность формы.

11y.4. Тени: качество и мягкость

[ ] 11y.4.1. Включить тени для главного света:

башня и кубики отбрасывают тени на пол и внутреннюю поверхность.

[ ] 11y.4.2. Настроить параметры:

достаточное разрешение shadow map (чтобы не было пиксельной лесенки);

shadowBias и аналогичные параметры:

чтобы убрать self‑shadowing артефакты и перескакивание;

при возможности — использовать soft‑shadows / PCF.

[ ] 11y.4.3. Проверить:

на средних и близких дистанциях:

тени от кубиков на других кубиках читаются;

нет грязи в местах контакта.

11y.5. Камера: UX, ракурсы, управление
11y.5.1. Игровой ракурс по умолчанию

[ ] 11y.5.1.1. Определить “эталонный” игровой кадр:

башня целиком в кадре:

виден верхний край;

виден нижний край и отражение на полу;

камера чуть выше середины, смотрит немного вниз;

башня занимает ~60–70% высоты кадра (без огромных пустых полей).

[ ] 11y.5.1.2. Зафиксировать этот ракурс в конфиге:

позиция камеры;

точка, на которую она смотрит;

FOV.

11y.5.2. Орбитальная камера для осмотра

[ ] 11y.5.2.1. Реализовать Orbit‑камеру (или эквивалент) для режима инспекции:

ЛКМ (drag) — вращение вокруг башни;

СКМ (drag) или Shift+ЛКМ — панорамирование (медленное смещение);

колесо — zoom (изменение расстояния).

[ ] 11y.5.2.2. Добавить ограничения:

минимальная и максимальная дистанция до центра башни;

ограничение вертикального угла:

чтобы камера не уходила строго снизу/сверху без нужды;

запрет на прохождение камеры “внутрь” башни или под пол.

[ ] 11y.5.2.3. Сглаживание:

добавить damping:

плавное затухание движения;

отсутствие рывков при резких остановках мыши;

чувствительность должна быть настроена так, чтобы:

небольшие движения мыши → аккуратный поворот;

быстрые махи → быстрый разворот, но без нервоза.

11y.5.3. Переключение режимов камеры

[ ] 11y.5.3.1. Минимум два режима:

Game View — фиксированный/почти фиксированный игровой ракурс;

Inspect View — свободная орбита.

[ ] 11y.5.3.2. Сделать переключатель:

клавиша (например, C) или кнопка UI;

плавный переход между текущей позицией и целевым ракурсом (lerp за 0.3–0.6 сек), чтобы не “телепортировать” камеру.

[ ] 11y.5.3.3. В Game View:

блокировать лишний input (например, отключить панорамирование);

allowed:

небольшое вращение вокруг оси башни для “живости”;

но с жёсткими ограничениями.

11y.6. Допиливание геометрии: фаски и нормали (если ещё не доведено)

[ ] 11y.6.1. Убедиться, что кубики имеют:

геометрический bevel (скошенные рёбра) или корректную normal map;

нормали:

сглаженные на фасках;

ровные на плоскостях.

[ ] 11y.6.2. Проверка крупным планом:

на стыке двух кубов видна тонкая тень;

на фаске кубика плавно меняется яркость блика по мере движения камеры.

11y.7. Настройки качества: Ultra / Medium / Low

Цель: чтобы можно было включить “ультра‑качество” для красоты и урезать для слабых машин.

[ ] 11y.7.1. Ввести уровни качества:

Ultra:

максимальное разрешение shadow map;

HDRI высокого разрешения;

активный bloom/AA;

много сегментов фаски и ровная геометрия.

Medium:

более низкое качество теней;

простой AA;

тот же материал, но меньше сегментов.

Low:

тени отключены или сильно упрощены;

без bloom;

упрощённый материал (без нормал карт).

[ ] 11y.7.2. Добавить переключатель качества:

через config или UI;

так, чтобы легко было переключить и сравнить (для разработки можно держать Ultra).

11y.8. Визуальные отладочные режимы (debug‑view)

[ ] 11y.8.1. Режим проверки материалов:

возможность переключить башню:

в matcap‑режим (проверка нормалей);

в режим, где различным материалам назначены простые цвета;

чтобы убедиться, что лицевая грань всегда правильно отрисована.

[ ] 11y.8.2. Режим проверки освещения:

отключение envMap → только лампы;

отключение ламп → только envMap;

видны ли артефакты в тенях, есть ли паразитные засветки.

[ ] 11y.8.3. Быстрая перезагрузка материала/света:

хоткей или кнопка “Reset lighting/materials to defaults”.

11y.9. Финальный визуальный QA

[ ] 11y.9.1. Сделать набор контрольных скриншотов:

view_game_01.png — игровой ракурс (как в рекламе);

view_inspect_closeup_01.png — крупный план верхней части башни;

view_inspect_bottom_01.png — низ + отражение.

[ ] 11y.9.2. Критерии “готово”:

золото светлое, с чёткими, но не слепящими бликами;

белая плитка читабельна, иероглиф чёткий;

зазоры между кубами заметны, но не дикие;

тени мягкие, без лесенок и дерганья;

при вращении камеры в Inspect‑режиме:

отражения на гранях прекрасно играют;

никаких странных провалов в чёрный.

[ ] 11y.9.3. Если что‑то не устраивает:

фиксировать в TODO/BUGS конкретно:

“золото всё ещё выглядит слишком тёмным при таком‑то ракурсе”;

“камера на Ultra‑качестве даёт тряску при zoom‑in”;

повторять локальные подпункты (например, 11y.2 или 11y.3) до получения эффекта “в восторге”.

11y.10. Подготовка к Этапу 12 (анимации)

[ ] 11y.10.1. Зафиксировать параметры:

материалы и свет → отдельный конфиг, не трогать без веской причины;

камера:

игровой ракурс, который будет использоваться как база для анимаций.

[ ] 11y.10.2. Убедиться, что:

все эффекты (золото, отражения, свет) выглядят стабильно при движении камеры;

ничего не “ломает” FPS настолько, чтобы анимации разрушения стали невозможными.

---

Окей, давай сделаем отдельный “Этап 11z” — приведение геймплея в нормальное состояние: камера, убирание кринжа, глобальный фикс коллизий и спавн.

Ниже — план, который ты можешь прям вклеить между 11 и 12 (или после 11y).
Как обычно, структурно, с подпунктами, чтобы пинать Codex по частям.

Этап 11z. Игровая камера, чистый рендер без дебага и глобальный фикс коллизий
11z.0. Цели этапа

Сделать игровую камеру играбельной:

видно весь низ башни, верх башни и зону спавна;

в обычном игровом режиме — один хороший, понятный ракурс без кринжа.

Убрать дебажный мусор из нормального режима:

голубое кольцо и направляющие выключены в прод‑режиме;

вместо них — аккуратный “отпечаток” башни на полу (сегментированная разметка).

Сделать глобальный, единый и надёжный фикс коллизий и движения:

фигуры НИКОГДА не пролезают на 1 блок внутрь пола или других блоков;

при любых сценариях: гравитация, soft drop стрелкой вниз, горизонтальные движения, “подсование” в щель;

не ломая возможность проталкивать фигуры в узкие зазоры (быстрые боковые движения при маленькой высоте окна).

Исправить спавн по вертикали:

новая фигура сразу целиком видна, без “додорисовки” через пару тиков;

ничего не обрезается верхом кадра или near‑plane.

Всё это — без ломки доменной логики и архитектуры:

все правки движения/коллизий идут через доменный слой;

рендер только аккуратно отображает.

11z.1. Режимы и флаги: разделяем прод и дебаг

Цель: жёстко отделить “обычную игру” от debug/visual‑режимов.

[ ] 11z.1.1. Ввести структуру “режимов отображения”:

Например, в конфиге:

renderMode = {
  kind: "game" | "visualDebug" | "textureProbe",
  showGuides: boolean,
  showDebugRing: boolean,
  showColliders: boolean
}


Для игрового режима (kind: "game"):

showGuides = false

showDebugRing = false

showColliders = false

[ ] 11z.1.2. Все дебажные элементы (кольцо, оси XYZ, вспомогательные линии):

повесить на единый флаг/слой;

в игровом режиме не создавать их или скрывать целиком.

[ ] 11z.1.3. Обеспечить, чтобы обычный запуск игры (без специальных флагов) всегда включал именно renderMode.kind = "game".

11z.2. Игровая камера: целиком видимый низ и верх башни

Цель: в обычном режиме мы видим ВСЮ башню:
и основание, и верхние ряды, и zону спавна, и отражение.

11z.2.1. Описание “объекта интереса” для камеры

[ ] 11z.2.1.1. Явно описать границы башни в мировых координатах:

высота:

минимум Y: уровень пола (основание башни);

максимум Y: верхний логический уровень башни + запас (1–2 блока выше зоны спавна, если спавн над видимым полем);

радиус:

внешний радиус цилиндра с кубами;

плюс небольшой запас (ещё один куб).

[ ] 11z.2.1.2. Сделать функцию в рендер‑слое:

getTowerBounds(): BoundingCylinder | { center: Vector3, radius: number, minY: number, maxY: number }


– она должна считать bounds из логики (boardWidth, boardHeight, размеры куба, высота пола и т.д.).

11z.2.2. Расчёт позиции и параметров камеры

[ ] 11z.2.2.1. Сделать функцию:

computeGameCameraPose(bounds, viewportAspect): { position, target, fov }


которая:

ставит камеру так, чтобы:

башня полностью помещалась по вертикали;

по горизонтали был небольшой отступ;

выбирает FOV (например, 30–40°, подбирая экспериментально);

ориентирует камеру:

центр обзора ≈ центр башни по высоте (или чуть ниже, чтобы низ был лучше виден);

камера выше башни и смотрит чуть вниз, но так, чтобы низ не был “под носом”.

[ ] 11z.2.2.2. Камера должна:

однозначно видеть:

весь минимальный уровень (основание башни);

зону спавна + 1–2 блока сверху;

не зависеть от текущей высоты заполненности башни — это статичный “игровой” ракурс.

11z.2.3. Clipping‑плоскости и cropping по верху

[ ] 11z.2.3.1. Проверить параметры near/far:

near достаточно маленький, чтобы камера не отрезала нижние блоки;

far достаточно большой, чтобы башня целиком помещалась, но без бессмысленного километрового диапазона.

[ ] 11z.2.3.2. Для теста:

взять getTowerBounds(), построить bounding sphere;

проверить, что он полностью попадает в frustum камеры:

можно сделать тестовую функцию, которая вычисляет это в коде (в debug‑режиме),

или хотя бы визуально проверить через вспомогательный отрисовщик рамки.

11z.3. Убираем дебажное кольцо и направляющие, добавляем “отпечаток” на полу

Цель: в игровом режиме нет голубого кольца и стрелок, но игрок всё ещё понимает, куда ставятся блоки.

11z.3.1. Управление debug элементами

[ ] 11z.3.1.1. Все debug‑элементы (кольцо, оси, линии) выделить в отдельный модуль:

например, DebugOverlaysRenderer;

этот модуль должен читать renderMode и не рисовать ничего, если kind = "game".

[ ] 11z.3.1.2. Убедиться, что при переключении на visualDebug:

все эти элементы вновь появляются;

но в game они гарантированно не активны.

11z.3.2. Сегментированный “фундамент” башни

[ ] 11z.3.2.1. Добавить новый объект на полу: разметка кольца:

плоская геометрия (диск/кольцо) на уровне пола;

материал: не светится, но чуть светлее пола;

разделена на сектора по количеству колонок (boardWidth):

можно сделать геометрию с radial‑линиями,

или просто текстурой с сегментами.

[ ] 11z.3.2.2. Привязка к логике:

каждый сектор разметки соответствует одной логической колонке башни;

по нему игрок интуитивно видит:

как повернута башня;

в какую “ячейку” приземлится блок.

[ ] 11z.3.2.3. Визуальный стиль:

разметка не должна отвлекать:

тонкие линии;

слегка более светлый/матовый цвет, чем пол;

в ULTRA‑режимах можно слегка подбросить контраст, но не превращать в цирк.

11z.4. Глобальный фикс коллизий и движения (без “прощупывания” сквозь блоки)

Цель: все движения фигуры (гравитация, soft drop, стрелка вниз, влево/вправо, вращение) используют одну и ту же логику проверки и НИКОГДА не показывают фигуру “внутри” пола или других блоков — даже на один кадр. При этом пампится классический тетрис‑флоу: можно проталкивать фигуру в узкие щели до самого конца.

11z.4.1. Доменные инварианты

[ ] 11z.4.1.1. Явно задекларировать в доменном слое инварианты:

Логические клетки фигуры никогда не занимают уже занятые клетки поля.

Логическая позиция фигуры никогда не выходит за границы поля (по всем осям).

Любой шаг симуляции (гравитация, soft drop, ввод игрока) либо:

приводит к новой валидной позиции (все клетки допустимы),

либо вообще не меняет позицию фигуры.

Визуальный рендер фигуры всегда соответствует какой‑то валидной логической позиции фигуры (на пути от старой валидной к новой валидной, но не переходящей в заведомо невалидную).

[ ] 11z.4.1.2. Всё перемещение фигуры в доменном слое должно идти через одну точку входа, а не разрозненные “подправить x, потом y” в разных местах.

11z.4.2. Единый API для движения фигуры

[ ] 11z.4.2.1. В доменном слое создать/переиспользовать единый метод:

tryMovePiece(gameState, move: { dx: number, dy: number, rotation: RotationDelta }): MoveResult


dx — смещение по окружности (влево/вправо);

dy — смещение по вертикали (вниз; вверх, если нужно);

rotation — изменение ориентации (0, ±90°, и т.д.).

[ ] 11z.4.2.2. Внутри tryMovePiece:

Рассчитать кандидатную позицию фигуры.

На основе логических координат фигуры получить набор клеток, которые она займёт.

Проверить пересечение с:

границами поля;

уже занятыми клетками;

полом (нулевой уровень).

Если всё валидно:

обновить gameState (новые координаты фигуры);

вернуть MoveResult.success.

Если НЕ валидно:

НЕ менять gameState;

вернуть MoveResult.blocked + информацию (что именно заблокировало).

[ ] 11z.4.2.3. Запретить любые прямые манипуляции piece.x, piece.y, piece.rotation “напрямую” в другом коде:

все тик‑функции (гравитация), обработчики ввода (стрелки left/right/down, rotate), soft/hard drop должны использовать только tryMovePiece.

11z.4.3. Гравитация и soft drop по таймеру

[ ] 11z.4.3.1. Для обычной гравитации:

на каждом шаге, когда пора падать:

звать tryMovePiece(..., {dx: 0, dy: -1, rotation: 0});

если success:

фигура опустилась на 1 логическую клетку;

если blocked:

считаем, что фигура “приземлилась”:

запускаем/увеличиваем lock delay (см. ниже),

либо сразу фиксируем (если delay = 0).

[ ] 11z.4.3.2. Для soft drop клавишей вниз:

принцип тот же, только:

soft drop либо:

уменьшает интервал гравитации (чаще вызываем tryMovePiece с dy=-1),

либо отдельной веткой при удержании стрелки вниз делает дополнительные попытки dy = -1 между основными тиками.

ВАЖНО: никаких схем типа:

“сдвинул вниз → о, провалился → подвинем назад”;

только “сначала спросили у логики, можно ли, и если можно — делаем шаг”.

11z.4.4. Горизонтальные движения и “подсовывание” в щели

[ ] 11z.4.4.1. Все MoveLeft / MoveRight:

реализовывать как:

tryMovePiece(..., {dx: -1, dy: 0, rotation: 0})
или

tryMovePiece(..., {dx: +1, dy: 0, rotation: 0}).

[ ] 11z.4.4.2. Выполнение горизонтальных движений, пока фигура падает:

ввод от игрока (лево/право) при падении:

не должен напрямую менять dy;

он просто даёт горизонтальное движение на текущей высоте:

последовательность может быть: left, gravity, right, gravity и т.д.;

при достижении нижней точки (когда попытка dy=-1 блокируется):

мы всё ещё можем несколько тиков разрешать горизонтальные движения и вращения до окончательной фиксации → классический lock delay.

[ ] 11z.4.4.3. Lock delay:

ввести структуру в gameState, напр.:

fallState: {
  landed: boolean,
  lockTime: number,        // сколько времени прошло с момента первого касания
  lockMovesCount: number   // сколько раз двигали/вращали после касания
}


при первом blocked по dy=-1:

landed = true, lockTime = 0, lockMovesCount = 0;

пока landed == true и:

lockTime < LOCK_DELAY_MAX и lockMovesCount < LOCK_MOVES_MAX:

разрешаем tryMovePiece с dx/rotation;

если движение/вращение успешно → обновляем фигуру и увеличиваем lockMovesCount;

после превышения лимитов:

фиксируем фигуру и превращаем в статические блоки.

Это гарантирует, что:

ты можешь БЫСТРО запихнуть фигуру в щель высотой 1 кубик в последний момент;

но при этом нет никакого прохождения сквозь пол/кубы — всё через валидные дискретные шаги.

11z.4.5. Визуальное отображение: никаких промежуточных “плохих” позиций

[ ] 11z.4.5.1. Связка логика → рендер:

логика хранит piece.logicalX, logicalY, rotation;

рендер хранит piece.visualX, visualY (можно для плавности);

но visualY (и X) не имеют права выходить за пределы позиции, рассчитанной по валидному logicalY.

Пример:

пусть logicalY = 3 (на 3 блока от пола);

при падении:

мы анимируем visualY от высоты уровня 4 к высоте уровня 3;

если проверка следующего шага dy=-1 вернула blocked:

logicalY не меняется (остается 3),

visualY не может уходить ниже 3‑го уровня;

никаких анимаций “ниже пола” быть не должно.

[ ] 11z.4.5.2. Удалить/заменить старые “костыли”:

старый фикс вида:

“если залез под пол → подвинуть вверх на 1 блок”

заменить логикой:

“никогда вообще не опускать логическую позицию туда, куда нельзя”;

а рендер привязать к логике, а не к попытке опустить “наверняка”, а потом откатывать.

[ ] 11z.4.5.3. Проверка всех путей:

gravity tick;

soft drop (таймером);

arrow down;

движение влево/вправо на разных высотах;

вращение рядом со стеной и другими блоками.

Во всех этих ветках фигура должна двигаться только через один API tryMovePiece и ни одного кадра не показываться “внутри” пола или блоков.

11z.5. Спавн фигуры и её видимость сверху

Цель: как только фигура заспавнилась — она сразу целиком видна, целиком отрисована, нигде не обрезана.

[ ] 11z.5.1. Проанализировать спавн:

откуда берётся спавн‑позиция по логике:

какие логические координаты по высоте (spawnY);

как мапятся логические координаты в мировые (grid→world);

как устроена камера по вертикали (top‑margin).

[ ] 11z.5.2. Обеспечить условие:

Для каждой возможной фигуры при спавне
(учитывая её высоту в блоках)
все её блоки лежат в пределах видимой зоны камеры.

Это можно сделать двумя способами (можно оба):

Подвинуть камеру вверх, чтобы зона видимости включала:

maxY башни + запас [1–2 блока];

Отрегулировать spawnY, чтобы:

фигура спавнилась на такое logicalY, что её верхний блок ≤ “видимого” максимума.

[ ] 11z.5.3. Проверить near‑clip:

при спавне фигура не частично обрезается near‑плоскостью камеры;

если near слишком большой и фигура близко к камере:

либо уменьшаем near, либо чуть отодвигаем камеру.

[ ] 11z.5.4. Сделать mini‑тест:

перебрать все виды фигур;

для каждой:

подставить spawn‑координаты;

просчитать world‑позиции их блоков;

убедиться, что они попадают в getTowerBounds и в frustum камеры.

11z.6. Тесты и стенды для гарантий (3d_helper_system)

[ ] 11z.6.1. При помощи 3d_helper_system.txt сделать небольшой стенд “CollisionSanity”:

фиксированная башня с несколькими “дырками”;

сценарии:

падение фигуры строго вниз;

падение с активным soft drop;

агрессивные движения влево/вправо возле стенок;

запихивание фигуры в дырку высотой 1 блок между двумя слоями.

[ ] 11z.6.2. Логировать:

логические координаты фигуры каждый тик;

факты блокировки движений (когда tryMovePiece возвращает blocked);

глубину theoretical penetration (если вычисляется);

мирные bounding box фигуры относительно пола и статических блоков.

[ ] 11z.6.3. Инварианты стенда:

ни один кадр не содержит:

пересечение bounding box фигуры с полом или статическими блоками;

logicalY < 0.

фигура всегда либо:

падает через валидные ступени;

либо стоит на месте (в процессе lock delay);

либо зафиксирована.

[ ] 11z.6.4. Отдельный сценарий “GapTest”:

две стенки с дыркой высотой 1 блок;

фигура падает сверху, игрок активно жмёт влево/вправо;

проверка:

фигура в большинстве случаев успешно может быть запихнута в щель, если действий достаточно;

при этом ни разу не проваливается внутрь блоков/пола.

Всё это можно оформить в plan.txt как новый:

11z. Этап: Игровая камера, убирание дебаг-рендера и глобальный фикс коллизий
...


А дальше — по привычной схеме:

В одном запросе к Codex:
сделать 11z.2 + 11z.3 (камера, отпечаток на полу, отключение дебага).

В другом запросе:
аккуратно реализовать 11z.4 + 11z.5 (глобальный фикс движения/коллизий + спавн).

Потом — отладочные стенды по 11z.6, если останутся сомнения.

Так получишь не “костыльчик ещё один”, а единый нормальный фундамент, на котором уже можно спокойно делать анимации разрушения (этап 12), не возвращаясь к этому цирку.

---

12. Этап: Физическая симуляция разрушения кубов (перезапуск)
12.0. Как это должно выглядеть для игрока

С точки зрения глаза:

Ряд собран, логика сказала “надо уничтожить этот этаж”.

Ряд пока целый. Кубы стоят, ничего не мерцает и не исчезает.

Потом по кругу идёт ударная волна:

куб №1: стоит–стоит → БАХ → именно он ломается и разлетается на кучу осколков;

куб №2: через небольшой промежуток времени — то же самое;

… по кругу, пока не взорвутся все кубы на уровне.

Осколки летят далеко, перемешиваются с осколками соседних кубов, дробятся, падают на пол, там чуть подскакивают/ползут и постепенно исчезают.

Когда последний куб уровня отработал свою симуляцию, верхняя часть башни резво и красиво “проседает” на один уровень вниз, без ломки домена.

12.1. Жёсткие инварианты (что категорически запрещено)

Сначала прям как контракт, чтобы Codex не съехал:

[ ] 12.1.1. Запрещено:

Сначала удалять кубы ряда (делать их невидимыми), а потом играть эффект в воздухе.

Делать “эффект разрушения”, который вообще не зависит от геометрии куба (одинаковый шарик/облако).

Ограничивать движение осколков маленьким объёмом вокруг центра куба.

“Завершать” взрыв за 0.2 секунды, пока осколки даже не успели долететь до пола.

[ ] 12.1.2. Обязательно:

Куб видим и цел до конкретного момента “взрыва” для него.

В момент взрыва:

куб исчезает именно потому, что его замещают осколки;

осколки стартуют внутри объёма этого куба (а не просто в его центре).

Осколки живут достаточно долго, чтобы:

вылететь из объёма куба;

пролететь через объём соседних кубов;

дойти до пола и там “доиграть”.

Верхняя часть башни падает вниз только после того, как симуляция разрушения всех кубов этого уровня завершена.

12.2. Разделение домен ↔ симуляция

[x ] 12.2.1. В домене:

по событию “ряд полон”:

{ type: "StartLineDestruction", clearedLevels: number[] }


домен переходит в GamePhase.Clearing и НЕ меняет board:

никакого “вырезать уровень из массива”;

board всё ещё содержит все блоки.

[x ] 12.2.2. В application/visual‑слое:

заводится объект “сценарий разрушения линий”:

interface LineDestructionScenario {
  levels: number[]; // какие уровни чистим

  // по одному сценарию разрушения на каждый уровень
  perLevel: Map<number, RowDestructionSim>;

  startedAtMs: number;
  finished: boolean;
}


домен – хозяин логики,

симуляция – хозяин анимации и таймингов разрушения.

12.3. Модель для одного уровня (этажа)

[x ] 12.3.1. Описание куба уровня:

interface CubeId {
  x: number; // индекс по окружности
  y: number; // индекс по высоте = level
}

interface CubeVisual {
  id: CubeId;
  worldPos: Vector3;
}


[x ] 12.3.2. Симуляция разрушения ряда:

interface RowDestructionSim {
  level: number;
  cubes: CubeVisual[];             // все кубы уровня, упорядоченные по кругу
  explosions: CubeExplosionSlot[]; // расписание взрывов

  allCubesExploded: boolean;
}


[x ] 12.3.3. Расписание взрывов (чистая волна):

interface CubeExplosionSlot {
  cubeIndex: number;     // индекс в массиве cubes
  startTimeMs: number;   // когда ЭТОТ куб должен начать взрыв
  started: boolean;      // уже запустили симуляцию разрушения этого куба?
}


[x ] 12.3.4. Построение волны:

Получаем все CubeVisual уровня в порядке по окружности (как они стоят).

Простой вариант “бум‑бум‑бум”:

const delayBetweenCubesMs = 30..60; // подбирается
for (let i = 0; i < cubes.length; i++) {
  explosionSlots[i] = {
    cubeIndex: i,
    startTimeMs: globalStartMs + i * delayBetweenCubesMs,
    started: false
  };
}


Всё: волна = просто итерация по массиву кубов с равным шагом по времени.

12.4. Симуляция разрушения ОДНОГО куба

Это сердце всего. Тут нужно прямо по шагам.

[x ] 12.4.1. Структура:

interface CubeDestructionSim {
  cube: CubeVisual;        // какой куб разрушаем
  fragments: Fragment[];   // осколки этого куба

  startedAtMs: number;
  finished: boolean;
}


[x ] 12.4.2. В глобальном состоянии симуляции:

interface DestructionSimulationState {
  rows: LineDestructionScenario;    // текущие ряды, которые разрушаем
  activeCubes: CubeDestructionSim[]; // все кубы, которые уже "взорвались" и сейчас симулируются
}


[x ] 12.4.3. Жизненный цикл куба:

До взрыва:

Куб рисуется как обычный инстанс башни;

В DestructionSimulationState ещё нет CubeDestructionSim для него.

Момент взрыва (t = startTimeMs по расписанию):

создаём CubeDestructionSim для этого куба;

генерируем фрагменты внутри объёма куба;

помечаем для рендера: “куб X,Y больше не рисовать как целый”.

После взрыва:

целый куб никогда больше не рисуется;

за него отвечает только набор Fragment[].

12.5. Геометрия и начальное состояние фрагментов

[x ] 12.5.1. Фрагмент:

interface Fragment {
  position: Vector3;
  velocity: Vector3;

  rotation: Quaternion;
  angularVelocity: Vector3;

  ageMs: number;
  lifetimeMs: number;
  fade: number;

  instanceId: number;          // индекс в instanced mesh
  materialId: "gold" | "face" | "inner"; // какие материалы
}


[x ] 12.5.2. Позиции: строго внутри объёма куба

Пусть куб имеет размеры cubeSize = (sx, sy, sz) и центр в cube.worldPos.

Для каждого фрагмента:

const local = new Vector3(
  random(-0.5, 0.5) * sx,
  random(-0.5, 0.5) * sy,
  random(-0.5, 0.5) * sz,
);
fragment.position = cube.worldPos + local;


Это гарантирует: “осколок родился как часть этого куба”.

[x ] 12.5.3. Количество фрагментов:

Настраиваемое (например, N = 12..32 для ultra):

часть фрагментов “мелкие кубики”;

часть “пластинки”/осколки (сплющенная геометрия);

часть “внутренние куски” (только золото без лицевой стороны).

[x ] 12.5.4. Начальные скорости:

outward – направление от центра башни наружу

outward = normalize(cube.worldPos - towerCenterInWorld);


tangent – направление вдоль окружности:

tangent = normalize(cross(up, outward)); // или cross(outward, up), по системе координат


Задаём скорость:

radialSpeed     = random(radialMin, radialMax);       // мощный выстрел наружу
tangentialSpeed = random(tanMin, tanMax);             // скос вдоль кольца
verticalSpeed   = random(vMin, vMax);                 // вверх/вниз

fragment.velocity =
    outward * radialSpeed +
    tangent * tangentialSpeed +
    up      * verticalSpeed;


Важно: radialMax должен быть таким, чтобы осколки улетали дальше одной клетки, пересекались с соседними кубами/осколками.

[x ] 12.5.5. Угловая скорость:

Берём случайный вектор:

fragment.angularVelocity = randomVectorWithinSphere(ωMin, ωMax);


Разные типы фрагментов могут иметь разные диапазоны (плоские – быстрее вращаются).

[x ] 12.5.6. lifetime:

lifetimeMs в районе 1000–2000 мс (с рандомом):

чтобы осколок успел:

вылететь;

упасть;

немного “пожить” на полу;

постепенно исчезнуть.

12.6. Пер‑фрейм обновление симуляции (НАСТОЯЩАЯ симуляция)

[x ] 12.6.1. Модель:

Каждый кадр мы симулируем физику фрагментов, а не просто проигрываем таймлайн.

Для каждого CubeDestructionSim:

для каждого Fragment:

ageMs += dtMs;
if (ageMs >= lifetimeMs) {
  fade = 0;
  пометить фрагмент к удалению;
  continue;
}

// Гравитация
velocity += gravity * dt;

// Воздушное сопротивление
velocity *= (1 - drag * dt);

// Позиция
position += velocity * dt;

// Вращение
angularVelocity *= (1 - angularDrag * dt);
rotation = applyAngularVelocity(rotation, angularVelocity, dt);

// Fade только в конце жизни
const t = ageMs / lifetimeMs;
fade = 1 - smoothstep(0.7, 1.0, t); // 70% жизни без заметного фейда, потом плавное исчезновение


[x ] 12.6.2. Столкновение с полом:

Пусть floorY – координата пола.

if (position.y <= floorY) {
    position.y = floorY + smallOffset;

    if (Math.abs(velocity.y) > minBounceSpeed) {
        velocity.y *= -bounceFactor; // bounceFactor ~ 0.3–0.6
    } else {
        velocity.y = 0;
    }

    // трение по XZ
    velocity.xz *= (1 - floorFriction * dt);
}


Это создаёт ощущение, что осколок физически упал и чуть подпрыгнул/поскользил.

[x ] 12.6.3. Ограничение радиуса:

Чтобы не улетать в бесконечность:

если расстояние от центра башни в XZ превышает maxRadius:

можно:

либо мягко притормаживать скорость радиально,

либо считать, что фрагмент “вылетел из сцены” и досрочно гасить.

[x ] 12.6.4. Обновление инстансов:

Для каждого фрагмента:

updateInstanceTransform(instanceId, position, rotation, fade);


Никакой анимации “на месте”. Всё движение — результат интеграции velocity.

12.7. Оркестратор волны: запуск симуляций кубов по очереди

[x ] 12.7.1. Каждый кадр, пока GamePhase = Clearing:

берём текущий timeNowMs;

для каждого RowDestructionSim:

for each slot in explosions:
    if (!slot.started && timeNowMs >= slot.startTimeMs) {
        // запускаем симуляцию этого куба
        const cube = cubes[slot.cubeIndex];

        create CubeDestructionSim(cube);
        activeCubes.push(sim);

        slot.started = true;
    }


[x ] 12.7.2. Визуальная связка:

Пока slot.started == false:

куб X,Y — рисуем целый;

Как только slot.started == true:

куб X,Y — больше никогда не рисуем целым;

за него отвечают только его фрагменты.

12.8. Завершение разрушения, падение башни

[x ] 12.8.1. Уровень считается разрушенным, когда:

для этого уровня все CubeExplosionSlot.started == true,

и все CubeDestructionSim для кубов этого уровня завершили свои фрагменты (все осколки либо умерли по lifetime, либо удалены).

[x ] 12.8.2. Когда все уровни из clearedLevels “отстрелялись”:

application‑слой вызывает домен:

game = finishLineDestruction(game);


[x ] 12.8.3. Домен:

удаляет уровни из board;

делает гравитацию для верхних уровней (логически роняет башню вниз);

возвращает GamePhase = Running.

[ x] 12.8.4. Визуальный “просад башни”:

для блоков, которые логически “упали” вниз:

делаем короткую анимацию от старого worldY к новому вместо телепорта:

// в render‑слое
visualY = lerp(oldY, newY, easeOutCubic(t));


t растёт от 0 до 1 за dropAnimationDurationMs (например, 200–300 ms).

12.9. Пресеты качества (чтобы ultra был аховый)

[x ] 12.9.1. Настройки для destructionPreset = "ultra":

fragmentCount = 16–32;

lifetimeMs ~ 1200–2000;

radialSpeedMax достаточно большой, чтобы осколки уходили дальше 1–2 кубиков;

full physics update по формуле выше.

[x ] 12.9.2. Для low:

можно просто:

уменьшить fragmentCount до 4–8;

lifetime поменьше;

упростить столкновение с полом (без bounce).

Но даже в low куб всё равно должен разлетаться на куски, а не превращаться в пшик.

12.10. Debug / тестирование

[x ] 12.10.1. В visualDebug:

панель Destruction:

выбор уровня;

кнопка Destroy level (using real simulation).

[x ] 12.10.2. Эта кнопка должна делать:

вызов того же механизма, что и в игре:

генерировать StartLineDestruction для указанного уровня;

запускать тот же самый LineDestructionScenario + CubeDestructionSim.

[ ] 12.10.3. Отладочные инварианты:

В любой кадр:

если куб ещё не взорван – он рисуется целым и нет фрагментов для него;

если куб взорван – целый куб не рисуется, только фрагменты;

нет кадров, где не рисуется ни куб, ни фрагменты на его месте.

---

Этап 12f. High‑fidelity фрагменты куба (форма + материалы)
12f.0. Цели

Каждый куб разлетается на куски, которые выглядят как части именно ЭТОГО куба, а не абстрактные чёрные кубики.

В осколках читается:

белая “кафельная” лицевая грань;

куски иероглифа;

золотые боковые и внутренние части.

Фрагменты разного размера и формы:

крупные пластины/кирпичики;

средние куски;

мелкая “крошка”.

Ничего из текущей логики волны/физики не ломаем — только заменяем:

как мы генерируем фрагменты;

какую геометрию/материалы им выдаём.

12f.1. Аудит текущей реализации фрагментов

[x ] 12f.1.1. Найти в коде место, где сейчас создаются фрагменты:

Функция/метод, который сейчас делает:

// псевдо
const fragment: Fragment = {
  position: ...,
  velocity: ...,
  rotation: ...,
  // ...
};


и там же, скорее всего, используется один BoxGeometry с чёрным материалом.

[x ] 12f.1.2. Зафиксировать, что:

структура Fragment уже существует;

физика (обновление position/velocity/age) уже работает;

instanced‑mesh для фрагментов уже используется (хоть и с чёрным кубиком).

Важно: всё это оставляем, чтобы не ломать симуляцию и волны. Менять будем только:

типы фрагментов,

геометрию/материалы,

начальные параметры.

12f.2. Ввод типов фрагментов и их роли

[x ] 12f.2.1. Добавить в Fragment поле kind:

type FragmentKind = "faceShard" | "edgeShard" | "coreShard" | "dust";

interface Fragment {
  kind: FragmentKind;
  // остальное как сейчас:
  position: Vector3;
  velocity: Vector3;
  rotation: Quaternion;
  angularVelocity: Vector3;
  ageMs: number;
  lifetimeMs: number;
  fade: number;
  instanceId: number;
  materialId: FragmentMaterialId; // см. ниже
}


[x ] 12f.2.2. Семантика:

"faceShard" — куски лицевой белой грани:

плоские/тонкие, с текстурой плитки и фрагментами иероглифа.

"edgeShard" — куски боковин/рёбер:

вытянутые, золотые, как будто часть ребра.

"coreShard" — массивные золотые “кирпичи” из тела куба.

"dust" — мелкая золотая крошка (может быть просто маленькие кубики/плоскости, менее детализированные).

12f.3. Мультиматериалы для фрагментов

[x ] 12f.3.1. В рендер‑слое создать несколько материалов фрагментов:

faceFragmentMaterial:

та же текстура, что на лицевой грани основного куба (белый фон + иероглиф);

физически похожие параметры (roughness/metalness), что у исходного материала плитки.

goldFragmentMaterialOuter:

как материал золотой грани куба (с отражениями и блеском);

goldFragmentMaterialInner:

чуть более тёмное золото для внутренних поверхностей (можно через color или roughness);

(опционально) dustMaterial:

мелкие частицы, можно чуть менее блестящие.

[x ] 12f.3.2. Организация instanced‑мешей:

либо четыре отдельных instanced‑mesh:

faceShardsMesh, edgeShardsMesh, coreShardsMesh, dustMesh;

либо один/dva, но с полем materialId → тогда рендерим партиями по материалам.

Рекомендация: для читаемости Codex‑у проще сделать отдельные mesh’и на материал, чтобы не париться с батчингом по материалам.

12f.4. Геометрия фрагментов: несколько шаблонов

Чтобы не делать Houdini, но получить красивый результат, нужен набор готовых шаблонов фрагментов.

[x ] 12f.4.1. faceShard — плиточные куски:

Базовая геометрия: тонкий прямоугольный параллелепипед (почти “плитка”):

// BoxGeometry(width, height, depth) с depth << width/height


UV‑координаты:

важно: мы хотим, чтобы каждый кусок занимал подпрямоугольник исходной текстуры лицевой грани;

делаем 3×3 или 4×4 “сетку” по лицевой стороне, каждый фрагмент получает свой UV‑подпрямоугольник,
чтобы на одних кусках были фрагменты иероглифа, на других — фон.

[x ] 12f.4.2. edgeShard — куски рёбер:

Базовая геометрия: вытянутый брусок (“мини‑ребро”):

BoxGeometry(edgeWidth, edgeHeight, edgeDepth)


Все поверхности — золотые.

[x ] 12f.4.3. coreShard — массивные куски:

Кубики/грубые “кирпичи” из тела:

BoxGeometry разных пропорций (от почти кубика до вытянутой массы).

Все грани — золотые.

[x ] 12f.4.4. dust — мелкая крошка:

Очень мелкие кубики/плоские частицы с золотым материалом;

Их можно делать существенно больше по количеству, но меньше по размеру.

12f.5. Карта “фрагментации” куба

Чтобы фрагменты были пространственно связаны с самим кубом, нужно зафиксировать локальные позиции и UV‑зоны внутри куба.

[x ] 12f.5.1. Ввести карту шаблонов для одного куба:

interface FragmentTemplate {
  kind: FragmentKind;
  localPosition: Vector3;    // внутри куба, в локальных координатах
  localRotation: Quaternion; // базовое вращение
  localScale: Vector3;       // дополнительный масштаб, если нужен
  uvRect?: { u0: number; v0: number; u1: number; v1: number }; // для faceShard
}

type CubeFragmentPattern = FragmentTemplate[];


[x ] 12f.5.2. Сделать несколько пресетов CubeFragmentPattern:

Pattern A: “одна большая плитка, пара средних, куча золотой крошки”.

Pattern B: “много мелких плиток + массивные золотые куски”.

Pattern C: “разорванная диагональ, как будто ударили сверху”.

Codex может создать 2–3 таких массива с руками подобранными localPosition и uvRect (примеры в комментариях).

[x ] 12f.5.3. При разрушении куба:

выбираем случайный CubeFragmentPattern (или чередуем),

для каждого FragmentTemplate в паттерне:

переводим localPosition + localRotation в мировой через cube.worldPos;

на основе kind и uvRect выбираем правильную геометрию/mesh и материал.

12f.6. Генерация фрагментов с учётом шаблона

[ x] 12f.6.1. В месте, где сейчас создаются одинаковые чёрные кубики, заменить на:

function spawnFragmentsForCube(cube: CubeVisual, pattern: CubeFragmentPattern): Fragment[] {
  const fragments: Fragment[] = [];

  for (const tpl of pattern) {
    const worldPos = cube.worldPos.clone().add(tpl.localPosition);
    const worldRot = tpl.localRotation.clone(); // можно ещё чуть рандомизировать

    const frag: Fragment = {
      kind: tpl.kind,
      position: worldPos,
      rotation: worldRot,
      // velocity/ω/lifetime зададим ниже,
      // materialId зависит от kind,
      // instanceId будет присвоен при размещении во фрагментном instanced mesh
    };

    if (tpl.kind === "faceShard") {
      frag.materialId = "face";
      frag.uvRect = tpl.uvRect; // если нужно хранить
    } else if (tpl.kind === "edgeShard") {
      frag.materialId = "goldOuter";
    } else if (tpl.kind === "coreShard") {
      frag.materialId = "goldInner";
    } else {
      frag.materialId = "dust";
    }

    // физика → см. 12f.7
    fragments.push(frag);
  }

  return fragments;
}


[x ] 12f.6.2. Дальше уже использовать существующую физику (age, lifetime, gravity, drag), просто не забыть:

более крупным фрагментам — меньшую скорость / чуть другой разброс;

dust — большую скорость и более короткий lifetime.

12f.7. Настройка начальной скорости и физики под размеры

[x ] 12f.7.1. Для каждого FragmentKind задать диапазоны:

const config = {
  faceShard: {
    radialSpeed:   [min, max],
    tangential:    [min, max],
    vertical:      [min, max],
    lifetimeMs:    [min, max],
  },
  edgeShard: { ... },
  coreShard: { ... },
  dust:      { ... },
};


coreShard: медленнее, тяжелее, чуть меньше разлёта, но эффектнее падение.

faceShard: средняя скорость + чуть больше тангенциальной компоненты (летят вдоль кольца, красиво “срезая” стенку).

dust: максимальная скорость и разлёт, короткий lifetime (вспышка крошки).

[x ] 12f.7.2. Применить эти диапазоны при генерации:

исходное направление такое же, как сейчас (outward + tangent + вверх/вниз),

но модули скорости и lifetime — из конфигурации по kind.

12f.8. Материалы и UV для лицевых осколков

Это ключевой момент, чтобы было ощущение “разломанной плитки с иероглифом”.

[x ] 12f.8.1. Для faceShard:

геометрия должна иметь UV‑развёртку, где одна грань полностью соответствует uvRect (подпрямоугольнику основной текстуры).

[x ] 12f.8.2. В момент генерации геометрии/instanced mesh:

если используем один общий BoxGeometry, UV задать так:

для лицевой грани — (u0, v0) .. (u1, v1) из tpl.uvRect,

остальные грани можно сделать одноцветными или золотыми (по вкусу).

Codex может либо:

сделать несколько геометрий для разных uvRect (3×3 сетка → 9 геометрий),

либо использовать одну геометрию с атрибутом “uvOffset/uvScale” и использовать шейдер/маткап.

В терминологии плана достаточно потребовать:
на лицевых осколках должны быть фрагменты исходной текстуры (фон + иероглиф), а не чистый цвет.

12f.9. Тонкий визуальный полиш

[x ] 12f.9.1. Цвет/материал:

убрать чёрный цвет полностью;

для gold‑фрагментов использовать тот же PBR‑материал, что у золотых граней куба (можно немного варьировать roughness);

для face‑фрагментов использовать тот же материал, что и у плитки (или его вариант).

[x ] 12f.9.2. Разнообразие:

добавить небольшую рандомизацию:

localScale ±10–20%,

лёгкий разброс по rotation,

чуть-чуть variation по насыщенности/яркости цвета.

[x ] 12f.9.3. Debug‑режим:

в visualDebug добавить выпадающий список:

Fragments debug:

all,

face only,

gold only,

dust only.

Это позволит глазами проверять, что типы фрагментов реально отличаются по форме/материалу и что face‑осколки действительно содержат фрагменты иероглифа.

---

Этап 12g. Texture-faithful fracture (“реальные осколки того самого куба”)
12g.0. Цель этапа

Каждый разрушающийся куб логически действительно делится на осколки:

у каждого фрагмента есть своё место внутри исходного куба;

если собрать все осколки обратно, они воспроизведут исходный объём.

Лицевая грань (белый “кафель” с иероглифом) разрезается на куски, и:

каждый face‑осколок показывает именно тот кусок текстуры, который был виден на стене;

можно глазами проследить: “вот отсюда вырвало плитку”.

Золотые части тоже выглядят как реальные куски:

внутри — массивные золотые “комки”;

на краях — золотые пластины/щепки;

рядом с белой гранью — микс белого + золота.

Никаких уникальных текстур под каждый фрагмент не делаем:
всё берём из одной текстуры куба, через вычисляемые UV.

Всё это должно быть повторно используемо для других кубов:

логика “фрагмент = область внутри куба + участок текстуры” универсальна;

для другого скина достаточно поменять UV‑прямоугольники граней.

12g.1. Зафиксировать текущее состояние как preset

[x ] 12g.1.1. Ввести два quality‑подрежима разрушения:

destructionQuality = "ultra_v1" | "ultra_v2" (или "fragments_v1" | "fragments_v2"):

ultra_v1 — то, что есть сейчас (кирпичики/плитка по шаблонам 12f);

ultra_v2 — новый, “texture‑faithful” режим.

[x ] 12g.1.2. В коде разрушения:

не удалять текущую реализацию 12f;

обернуть генерацию фрагментов вещью типа:

if (config.destructionQuality === "ultra_v1") {
  spawnFragments_v1(cube);
} else {
  spawnFragments_v2(cube); // новый пайплайн
}


Это даст тебе безопасный fallback и возможность сравнивать.

12g.2. “Единый эталонный куб” и грани

[x ] 12g.2.1. Зафиксировать локальную систему координат куба:

куб в локе: x,y,z ∈ [-0.5, +0.5],

грань наружу башни (та, что с белой текстурой и иероглифом) назовём FaceId.Front,

остальные — Right, Left, Top, Bottom, Back (все золотые).

[x ] 12g.2.2. Зафиксировать UV‑диапазоны для каждой грани исходного куба (у тебя это уже есть для текстурирования самого куба):

interface FaceUvRect {
  face: FaceId;
  u0: number; v0: number;
  u1: number; v1: number; // прямоугольник текстуры, который занимает эта грань
}


Здесь никакой новой магии: это ровно те диапазоны, которые уже использовались для нормального куба.

12g.3. Фрактура в 2D: разрезаем грань, а потом экструдируем

Идея: не пытаемся резать полноценный 3D‑куб сложной геометрией, а сначала ломаем каждую грань в 2D:

Берём квадрат [-0.5, 0.5]×[-0.5, 0.5] в плоскости конкретной грани.

Генерируем на нём набор неровных многоугольников (шарды):

не обязательно идеальный Voronoi, но что‑то в духе:

random точки,

разрезы/сегменты, пересекающие квадрат,

последующая полигонизация.

Каждый 2D‑многоугольник → экструдируем вдоль нормали в 3D (разная глубина), получаем осколок.

[x ] 12g.3.1. Структуры:

interface FacePolygon2D {
  face: FaceId;
  vertices: Vec2[]; // локальные 2D координаты в диапазоне [0,1]x[0,1] или [-0.5,0.5]
}

interface ShardTemplate {
  id: number;
  face: FaceId;       // какая грань "основная" для этого осколка
  polygon2D: FacePolygon2D;
  depthMin: number;   // в нормализованных координатах (0..1 толщины куба)
  depthMax: number;
}


[x ] 12g.3.2. Генерация набора ShardTemplate:

Для FaceId.Front (белая грань) — делаем 6–12 многоугольников разного размера/формы;

Для боковых/верхних граней — 4–8 полигонов покрупнее;

Для задней грани можно сделать несколько крупных “ломтей” (они почти не видны, но добавляют массы).

Простая стратегия:

сгенерировать несколько случайных прямых/ломаных, разрезающих квадрат;

использовать библиотеку/свой код для нарезки полигона;

отфильтровать мелкие полигоны (слишком маленькую площадь).

12g.4. Построение 3D‑геометрии осколков из 2D полигонов

[x ] 12g.4.1. Для каждого ShardTemplate:

Берём 2D‑многоугольник polygon2D на грани.

Выбираем случайную толщину вдоль нормали грани:

const t0 = random(depthMin, depthMax);
const t1 = random(depthMin, depthMax);


Строим 3D‑вершины:

“лицевая” поверхность: полигон в плоскости грани, поднимаем в 3D;

“задняя” поверхность: тот же полигон, но сдвинутый внутрь куба;

соединяем их боковыми стенками (quad → 2 треугольника).

Результат: каждый ShardTemplate становится замкнутым выпуклым/почти выпуклым объёмом, который:

на одной стороне лежит точно на поверхности куба;

внутрь уходит на какую‑то глубину.

[x ] 12g.4.2. Нормали:

для лицевой грани — нормаль совпадает с нормалью соответствующей кубической грани;

для боковых стенок — нормали по направлению наружу относительно центроида куба;

для задней грани — нормаль внутрь (можно сделать её менее освещённой).

12g.5. UV‑координаты, привязанные к исходной текстуре куба
Ключевой принцип: НЕ трогаем существующую развёртку куба.

Просто используем её диапазоны FaceUvRect как “область”, внутри которой живут наши 2D‑многоугольники.

[x ] 12g.5.1. Для каждой вершины “лицевой” грани полигона:

есть 2D координаты p = (sx, sy) в диапазоне [0,1]×[0,1];

у соответствующей гранью есть прямоугольник текстуры (u0,v0,u1,v1).

UV для этой вершины:

u = u0 + sx * (u1 - u0);
v = v0 + (1 - sy) * (v1 - v0); // если оси перевёрнуты по вертикали


То есть, texture lookup совпадает с тем, как мы маппили целый куб.
Если взять все face‑осколки вместе и наложить, они покрывают ровно тот же UV‑прямоугольник, что исходная плита.

[x ] 12g.5.2. Для боковых стенок и задней грани:

можно использовать:

золотой материал без текстуры;

или тот же gold‑texture‑rect, но uv задаём просто пропорционально координатам.

Точность там не критична, главное, что это золото, а не белый.

[x ] 12g.5.3. Универсальность:

Для другого куба (другая текстура):

меняем только значения FaceUvRect (u0,v0,u1,v1 для каждой грани);

алгоритм фрагментации остаётся тем же, 2D‑полигоны по прежнему в [0,1]x[0,1], uv пересчитываются по формуле выше.

12g.6. Отношение “этот осколок = эта область куба”

Сейчас шаблоны 12f процедурные и не гарантируют “если собрать — получится куб”. Нам нужно добавить связность.

[x ] 12g.6.1. Ввод “карты заполнения”:

Представим куб как “суп” из нормализованных координат [-0.5,0.5]^3.

Для каждого ShardTemplate мы явно задаём объёмную область:

polygon2D в плоскости грани,

диапазон по глубине [t0,t1].

[x ] 12g.6.2. Инвариант:

Объём исходного куба примерно покрывается объединением всех ShardTemplate
(можно оставить немного “дыр” → это будет мелкая пыль, не явно представленная геометрией).

[x ] 12g.6.3. “Логическое соответствие”:

У каждого фрагмента есть localCenter: Vec3 — центр его объёма в локальных координатах;

Если этот центр лежит ближе кнаружи, чем к центру:

вероятно, фрагмент содержит кусок лицевой/боковой поверхности;

в рендере это будет видно сразу: на части осколка есть плитка/золото.

12g.7. Подключение ShardTemplate к текущей физике

Ваши структуры Fragment/DestructionSim уже работают. Новое:

[x ] 12g.7.1. Вместо генерации фрагментов “из воздуха” по шаблонам из 12f:

хранить в памяти массив ShardTemplate для единичного куба;

при разрушении конкретного куба:

for (const template of shardTemplates) {
   const frag = makeFragmentFromTemplate(template, cubeWorldTransform);
   initPhysicsForFragment(frag, cube, template);
   addToSimulation(frag);
}


[x ] 12g.7.2. makeFragmentFromTemplate:

берёт вершины полигона, extrude → заранее подготовленный BufferGeometry (для каждого шаблона);

на разрушении куба просто инстанцируем эту геометрию (instanced mesh) с:

transform = локальный объём + world‑позиция куба;

UV у геометрии уже зашиты из шага 12g.5;

materialId выбирается: face/gold.

[x ] 12g.7.3. Физика:

можно оставить твой существующий подход (gravity, drag, bounce);

но параметры скорости/lifetime почти наверняка стоит привязать к:

объёму/массе фрагмента (большие → медленнее, меньше разлёт);

расстоянию центра от “ядра взрыва” (ближе к центру → сильнее разлёт).

12g.8. Реализм формы: “мясо”, а не кубики

Чтобы оно перестало выглядеть как аккуратные прямоугольные кирпичи, нужно добавить неровность:

[x ] 12g.8.1. Для 2D‑полигона:

не ограничиваться прямоугольниками;

использовать:

случайные точки + Delaunay/Voronoi;

или базовую сетку 4×4 + случайные смещения точек и хаотичные разрезы.

[x ] 12g.8.2. При построении 3D:

слегка шумить вершины боковых граней:

const noise = randomVectorInSphere(ε);
vertex.position += noise; // но не трогать "лицевые" вершины, чтобы не ломать UV!


это даст ощущение “надлома”, а не идеально распиленного кирпича.

[x ] 12g.8.3. Толщина:

разные ShardTemplate получают разную глубину экструзии:

ближе к периферии — тонкие пластины;

ближе к центру — массивные куски.

12g.9. Debug и проверка “это реально тот кусок текстуры”

[x ] 12g.9.1. В visualDebug добавить режим:

Fragments debug mode: "show source region":

у всех кубов отключить анимацию, просто показать один куб, разломанный на осколки;

отключить motion, показать все фрагменты чуть разъехавшимися.

[x ] 12g.9.2. В этом режиме:

рисовать “wireframe” контуры исходного куба;

рядом показывать плоскую разложенную лицевую грань с UV‑сеткой;

подсвечивать:

при наведении на осколок – подсвечивать соответствующий участок на 2D‑карте (и наоборот).

Это гарантирует визуально, что:

face‑осколки действительно покрывают оригинальный участок текстуры без диких растяжений;

белый/золотой не переливается как попало.

---


Этап 12H. Volume‑true fracture 2.0 (реальные объёмные осколки)
12H.0. Жёсткие инварианты (никаких поблажек)

[ ] 12H.0.1. Куб рассматриваем как объём [-0.5, 0.5]^3 в локальных координатах.

[ ] 12H.0.2. В режиме destructionQuality = "ultra_volume" объём куба полностью и без пересечений покрывается набором 3D‑осколков:

если взять все осколки, собрать обратно и “заполнить дырки”, получается фигура, совпадающая с исходным кубом по объёму (в пределах плавающих чисел);

два разных осколка не пересекаются по объёму.

[ ] 12H.0.3. Осколки — объёмные многогранники, а не плоские пластинки:

каждый шард имеет ощутимую толщину (минимум ~10–15% от размера куба по одной из осей);

у шарда несколько граней, силуэт рваный, а не “идеальный кирпич”.

[ ] 12H.0.4. Внешняя “кожа” шарда, которая лежит на видимых гранях куба (x=±0.5, y=±0.5, z=±0.5):

получает материалы и UV точно по тем же формулам, что и исходный куб;

в сумме по осколкам эта кожа даёт ту же картинку, что целый куб (по факту — тот же UV‑квадрат, но порванный на куски).

[ ] 12H.0.5. Фрагменты не спавнятся “из воздуха” в отрыве от геометрии куба:

у каждого фрагмента есть ссылка shardIndex, которая указывает на конкретный 3D‑осколок из предрасчитанного набора;

“исчезновение” куба = мы запускаем симуляцию вылета его собственных шардов.

[ ] 12H.0.6. Уже существующие части разрушения не ломаем:

домен игры, события очистки, волна разрушения, DestructionSimulationState, основной update‑loop и renderer фрагментов остаются;

меняется только генерация CanonicalShardGeometry и логика spawnFragment… в режиме "ultra_volume".

12H.1. Подготовка: система координат и UV‑раскладка куба

[x ] 12H.1.1. Зафиксировать/обновить структуру описания граней куба:

enum CubeFace {
  Front, Back, Left, Right, Top, Bottom
}

interface CubeFaceUvRect {
  face: CubeFace;
  u0: number; v0: number;
  u1: number; v1: number;
}

interface CubeUvLayout {
  faces: Record<CubeFace, CubeFaceUvRect>;
}


CubeUvLayout – это то, что сейчас уже используется для целого куба.

[x ] 12H.1.2. Функция sampleFaceUv(face: CubeFace, localPos: Vector3, layout: CubeUvLayout): {u,v}:

общий контракт: если её вызвать на вершинах исходного куба, она вернёт UV, дающие текущее идеальное текстурирование;

эта же функция дальше будет использоваться для UV вершин шардов.

12H.2. Разделение на “оболочку” и “ядро”

Чтобы получить реалистичные осколки, разделяем куб на:

shell — внешний слой толщиной shellDepth (например, 20–25% размера куба);

core — внутренний кубик.

[x ] 12H.2.1. Ввести:

const SHELL_DEPTH = 0.2; // от полной половины, т.е. толщина слоя ~0.2*1.0


для фронтальной грани shell‑слой — z ∈ [0.5 - SHELL_DEPTH, 0.5], и т.д.

[x ] 12H.2.2. Гарантия:

shell + core точно по объёму = исходный куб (без зазоров и пересечений);

граница между ними — плоскости, параллельные граням куба (чтобы не мучиться с швами).

12H.3. 2D‑фрактура облицовки (shell) → рваные многоугольники

Сейчас у тебя основная претензия к виду — границы слишком “листовые/ровные”. Для оболочки делаем чисто 2D‑фрактуру по граням.

[x ] 12H.3.1. Для каждой видимой грани (минимум Front, при желании и остальные):

рассматриваем квадрат в 2D: (sx,sy) ∈ [0,1]×[0,1], который соответствует этой грани.

[x ] 12H.3.2. Генерируем набор случайных многоугольников (facePolygons):

interface FacePolygon2D {
  face: CubeFace;
  vertices: Vec2[]; // порядок — обход по часовой/против часовой стрелки
}


Требования к полигону:

количество вершин ≥ 5 (чтобы это не был прямоугольник);

площадь выше минимального порога (отсечь “пылинки”);

полигоны не пересекаются и полностью покрывают квадрат [0,1]².

Реализация (примерный алгоритм):

сгенерировать 6–12 случайных “seed‑точек” внутри квадрата;

построить Voronoi (или простой ломаный разрез);

получить полигоны как ячейки Voronoi, обрезанные границами квадрата;

при необходимости упростить полигоны (убрать почти коллинеарные вершины).

12H.4. Shell‑осколки: экструдируем 2D‑многоугольники внутрь куба

[x ] 12H.4.1. Для каждой граней и каждого FacePolygon2D создаём shell‑шард:

interface ShellShardTemplate {
  id: number;
  face: CubeFace;
  poly: FacePolygon2D;  // в [0,1]^2
  depthInner: number;   // глубина экструзии внутрь, в диапазоне [SHELL_DEPTH * 0.5, SHELL_DEPTH]
}


[x ] 12H.4.2. Генерация геометрии shell‑шарда:

Переводим 2D вершины (sx, sy) полигона → локальные координаты куба для лицевой грани:

для фронта (z=+0.5):

x = -0.5 + sx;
y = -0.5 + sy;
z =  0.5;


другие грани аналогично.

Внутренняя грань — те же (sx,sy), но сдвиг по нормали на -depthInner:

для фронта: zInner = 0.5 - depthInner.

Строим mesh:

лицевой n‑угольник (наружу),

такой же n‑угольник внутри,

боковые стены — соединяем пары вершин (i‑я наружняя, i+1‑я наружняя, i+1‑я внутренняя, i‑я внутренняя) → quad → 2 треугольника.

Результат: объёмный шард, у которого наружная граница — настоящий n‑угольник, а внутрь идёт “ломоть” толщиной depthInner.

[x ] 12H.4.3. UV для shell‑шарда:

для всех вершин лицевой поверхности:

// sx, sy уже в [0,1]; rect = FaceUvRect(face)
u = rect.u0 + sx * (rect.u1 - rect.u0);
v = rect.v0 + (1 - sy) * (rect.v1 - rect.v0); // если вертикаль перевёрнута


остальные грани (внутренняя/боковые) — золотой материал:

можно вообще не использовать текстуру (чистый goldPBR);

либо использовать goldenRect, но это не критично.

Важно: лицевые грани всех shell‑осколков в сумме покрывают ровно тот же FaceUvRect, что целый куб → никакой свистопляски текстур.

12H.5. Core‑объём: jitter‑решётка внутри, объёмные “камни”

Shell‑слой забирает внешнюю “кожуру”. Внутри остаётся кубик [-coreHalf, coreHalf]^3, где coreHalf = 0.5 - SHELL_DEPTH.

[x ] 12H.5.1. Строим jitter‑решётку внутри core:

const CORE_GRID_X = 3;
const CORE_GRID_Y = 3;
const CORE_GRID_Z = 3;


узлы от -coreHalf до coreHalf;

внутренние узлы смещаем случайно в пределах небольшого jitter (например, 10% от шага);

границы core оставляем ровными (чтобы стык shell/core был чистым).

[x ] 12H.5.2. Формируем VolumeCell’ы как гексаэдры между соседними узлами (как в 12h старой версии).

[x ] 12H.5.3. Кластеризация core‑ячеек в “камни”:

группируем ячейки в CoreShardCluster:

interface CoreShardCluster {
  id: number;
  cells: VolumeCell[];
}


условия:

каждая ячейка принадлежит ровно одному кластеру;

кластеры связны (cells соседствуют по рёбрам/граням);

число кластеров и размеры → выбрать так, чтобы были и крупные “камни”, и несколько средних.

Простейший вариант:

делаем flood‑fill по случайно выбранным seed‑ячейкам, пока не распределим все.

[x ] 12H.5.4. Генерация геометрии core‑шарда по кластеру (как в старом 12h):

собираем все faces ячеек;

те, что внутри кластера (разделяют две cells кластера) → выбрасываем;

остаются внешние faces, собранные из quad‑ов → разбиваем в треугольники.

Материал: цельное золото (outer/inner).

12H.6. Объёмное покрытие без дыр и пересечений

[x ] 12H.6.1. Гарантия покрытия:

shell‑шарды занимают слои:

для фронта: z ∈ [0.5 - depthInner, 0.5],

для других граней аналогично;

core‑шарды живут строго внутри [-coreHalf, coreHalf]^3.

Так:

shell‑слой + core‑слой по объёму = куб;

пересечений нет (граница по координате ±coreHalf чёткая);

швы между shell и core можно либо оставить как есть (маленькие изломы), либо слегка сгладить jitter, чтобы не было зазора.

12H.7. CanonicalShardGeometry и связка с фрагментами

[x ] 12H.7.1. Собираем все shell‑шарды и core‑шарды в единый массив:

interface CanonicalShard {
  id: number;
  positions: Float32Array;
  normals: Float32Array;
  uvs: Float32Array;
  indices: Uint16Array | Uint32Array;
  materialKind: "faceAndGold" | "goldInnerOnly";
  approximateVolume: number;
}

const canonicalShards: CanonicalShard[] = [...shellShards, ...coreShards];


[x ] 12H.7.2. В структуру Fragment:

добавить shardId: number;

в режиме "ultra_volume" при разрушении куба:

for (const shard of canonicalShards) {
  const frag = createFragmentFromShard(cubeTransform, shard);
  // задать скорость/ω по текущей физике
  destructionState.fragments.push(frag);
}


[x ] 12H.7.3. Рендер:

вместо процедурной геометрии под фрагменты — использовать canonicalShards как источники:

либо один BufferGeometry + атрибуты с offset/scale,

либо отдельные геометрии/instanced‑mesh по materialKind.

Главное: каждый Fragment рисует один CanonicalShard, трансформированный в мир и анимируемый по физике.

12H.8. Debug‑режим: “показать куб, собранный из осколков”

[x ] 12H.8.1. В visualDebug добавить режим:

Fragments mode → "Cube fracture debug":

отключить движение/вылеты;

показать один тестовый куб, полностью “склеенный” из его shard‑геометрии.

[x ] 12H.8.2. В этом режиме:

отрисовать все CanonicalShard с нулевой скоростью;

показать прозрачный “идеальный” куб вокруг (wireframe);

добавить опцию highlight:

при выборе shardId подсвечивать его;

в отдельном виджете показать эту грань в UV‑координатах (для лицевых).

Цель: глазами проверить, что:

швы реально составляют куб без дыр;

texturing лицевых частей непрерывный: иероглиф и белый фон не режутся криво/растянуты.

12H.9. Физика вылета под новые осколки

[x ] 12H.9.1. Скорость фрагмента:

базовый радиальный вектор: от центра куба к центру шарда;

модуль скорости зависит от расстояния до центра (чуть сильнее наружные куски);

плюс добавка вдоль направления волны (как сейчас), плюс лёгкий хаос.

[x ] 12H.9.2. Масса:

пропорциональна approximateVolume из CanonicalShard → тяжёлые куски летят чуть медленнее и падают “увесистее”.

[x ] 12H.9.3. Коллизии с полом/стволом башни можно оставить как на текущей стадии (или вынести в отдельный 12I‑этап).

---

Этап 12P. Real‑world physics polish для осколков

Цель: чтобы разрушение ощущалось как настоящий взрыв плитки/золота: тяжёлые куски летят по баллистическим траекториям, мелочь — как пыль, есть отскоки от пола/стен, движение затухает естественно.

Файлы, в которые Codex уже смотрел и которые надо будет доработать:

src/app/destruction/fragmentSimulation.ts

src/app/destruction/destructionPresets.ts

src/app/destruction/fragmentKindConfig.ts

src/app/destruction/explosionLifecycle.ts

src/app/destruction/fragmentVelocity.ts

src/app/destruction/fragmentAngular.ts

src/app/destruction/fragmentLifetime.ts

src/app/destruction/simulationManager.ts

12P.1. Привязать физику к “разумным” единицам

[x ] 12P.1.1. В fragmentSimulation.ts и пресетах явно зафиксировать “физические” константы:

Ввести PHYSICS_UNITS‑комментарий: что считается 1 юнитом (сейчас куб ~1×1×1; принять это за 1 м условно).

Константы:

GRAVITY = -9.81 * gravityScale (по Y).

AIR_DRAG_LINEAR и AIR_DRAG_ANGULAR (малые положительные коэффициенты, зависящие от качества пресета).

Все ускорения/скорости, которые сейчас “подогнаны на глаз”, привязать к этим константам (чтобы было понятно, что мы делаем и что тюнинг — осознанный).

12P.2. Масса, объём и инерция фрагментов

У тебя уже есть volumeEstimate и объём/центр в shardFragmentFactory.ts. Нужно это использовать всерьёз.

[x ] 12P.2.1. Ввести эффективную массу:

В fragmentSimulation.ts или отдельном helper’e ввести:

effectiveMass = clamp(volumeEstimate * densityFactor, mMin, mMax)


где densityFactor ≈ 1, mMin > 0 (чтобы пыль не становилась “невесомой”).

[x ] 12P.2.2. Линейная и угловая скорость зависят от массы:

В fragmentVelocity.ts:

Уменьшить случайную скорость для тяжёлых фрагментов (масса ↑ → начальная скорость ↓).

В fragmentAngular.ts:

Лёгкие/мелкие фрагменты вращаются быстрее;

Ограничить спин у крупных кусков (чтобы не крутились, как бумажки).

12P.3. Более реалистичная баллистика и затухание

[x ] 12P.3.1. В fragmentSimulation.ts перейти на явную интеграцию с затуханием:

Для каждого шага:

// v: скорость, a: ускорение (гравитация + доп. силы), dt: deltaTime
v += a * dt;
v *= (1.0 - linearDrag * dt); // экспоненциальное затухание

omega += angAccel * dt;
omega *= (1.0 - angularDrag * dt);


linearDrag и angularDrag брать из пресета + kind‑конфига:

dust — высокая drag (быстро тормозится, “повисает”);

core/gold — низкая drag.

[x ] 12P.3.2. Lifetime привязывать к скорости, а не чистому таймеру:

В fragmentLifetime.ts или fragmentSimulation.ts:

Если модуль скорости < minSpeedThreshold и фрагмент ниже некой высоты (лежит на полу/подальше от камеры) — можно начинать fadeout, даже если таймер не истёк.

Таймер всё ещё есть (safety), но основная логика: “остановился → потух”.

12P.4. Простые, но заметные столкновения с полом и башней

Без полноценного physics engine можно сделать аналитические коллизии.

[x ] 12P.4.1. Столкновение с полом:

В fragmentSimulation.ts, после обновления позиции:

const floorY = FLOOR_LEVEL; // взять из board/towerBounds
if (pos.y < floorY) {
  pos.y = floorY;
  if (v.y < 0) {
    v.y = -v.y * restitution; // отскок
    v.x *= floorFriction;
    v.z *= floorFriction;
  }
  // если скорость мала → считаем, что фрагмент лежит
}


restitution и floorFriction задавать в destructionPresets.ts (ultra — мягкие, низкие отскоки; low — можно ещё проще).

[x ] 12P.4.2. Столкновение с внутренней цилиндрической поверхностью башни:

Радиус башни R взять из towerBounds.ts/boardToWorldMapper.ts.

Если фрагмент рядом с башней:

const radial = new Vector2(pos.x, pos.z);
const dist = radial.length();
if (dist < R && dist > 0) {
  const n = radial.clone().normalize(); // нормаль наружу
  const penetration = R - dist;
  pos.x -= n.x * penetration;
  pos.z -= n.y * penetration;

  const vRadial = v.x * n.x + v.z * n.y;
  if (vRadial < 0) {
    // отражаем радиальную компоненту, оставляя тангенциальную
    v.x -= (1 + wallRestitution) * vRadial * n.x;
    v.z -= (1 + wallRestitution) * vRadial * n.y;
    // небольшой тангенциальный damping для трения
    const tangentFriction = wallFriction;
    // можно уменьшить компоненты, перпендикулярные n
  }
}


Этого достаточно, чтобы куски отскакивали/скользили по внутренней стенке башни и не проходили сквозь неё.

12P.5. Реалистичное начальное распределение скоростей (взрыв волной)

Сейчас, скорее всего, скорость берётся как “случайный вектор наружу + вверх”. Это даёт ощущение “конфетти”.

[x ] 12P.5.1. В fragmentVelocity.ts сделать поле сил, а не просто рандом:

Для каждого фрагмента:

Посчитать:

nRadial — нормаль наружу от оси цилиндра.

nTangential — единичный вектор вдоль окружности (по φ).

nUp — (0,1,0).

Базовый импульс:

v0 =
  radialStrength * nRadial +
  upStrength * nUp +
  waveStrength * nTangential * waveDirectionSign;


Добавить небольшой стохастический шум (малый):

v0 += randomInCone(..., coneAngle);


Силы зависят от позиции фрагмента в слое:

ближе к началу волны → сильнее вдоль nTangential;

ближе к концу → чуть меньше.

[x ] 12P.5.2. Учитывать массу в начальной скорости:

radialStrength, upStrength, waveStrength масштабировать через 1 / sqrt(mass) → лёгкие осколки летят чуть дальше от того же взрыва.

12P.6. Лёгкий “ветер”/турбулентность для ультра‑режима

Чтобы движение было менее “идеально баллистическим” и чуть живее.

[x ] 12P.6.1. В fragmentSimulation.ts для destructionQuality = 'ultra_volume' добавить слабый псевдо‑шум:

На каждом шаге для лёгких фрагментов (dust/face мелкие):

const wind = samplePseudoNoise3D(pos, time) * windStrength; // можно простой hash по позиция+время
v += wind * dt;


Держать windStrength очень маленьким, чтобы это не превращало всё в “вьюгу”, а только слегка ломало идеальные траектории.

12P.7. Тюнинг пресетов и debug‑визуализация

[x ] 12P.7.1. В destructionPresets.ts расширить ultra‑пресет:

Добавить поля:

gravityScale

linearDrag, angularDrag

floorRestitution, wallRestitution

floorFriction, wallFriction

диапазоны начальных radialStrength, upStrength, waveStrength.

[x ] 12P.7.2. В destructionDebugPanel.ts добавить (только для visualDebug):

Слайдеры:

“Explosion strength” (масштабирование всех начальных скоростей).

“Gravity scale”.

“Drag”.

Флажок “Show velocity vectors” (если не лень: отдельный overlay в visualDebugMode.ts — рисовать стрелочки для небольшой выборки фрагментов).

Это позволит тебе глазами “поймать” тот диапазон, который выглядит максимально приятно, и потом зафиксировать его в пресете.

12P.8. Критерий завершения

Симуляция разрушения воспринимается так:

Осколки летят по понятным дугам: видно гравитацию, нет ощущение “летающего мусора без веса”.

Тяжёлые фрагменты падают ближе и вращаются медленнее, мелкие — разлетаются дальше, суетятся.

Есть понятные отскоки от пола и башни (хотя бы один‑два), потом движение затухает, фрагменты “успокаиваются”.

Волна разрушения читается как направленный взрыв по кольцу, а не равномерный шум.

---

Этап 12Q. Боевой destruction + единый визуал кубиков
12Q.1. Подключить симуляцию разрушения в обычный игровой режим

Цель: использовать ту же систему разрушения, что и в visualDebugMode, при реальном очищении рядов в игре.

12Q.1.1. Пробросить события destruction из gameController

Файлы:
src/app/gameController.ts, src/app/events.ts, src/core/state/clearing.ts.

Сделать так, чтобы при переходе домена в фазу очистки (когда clearing в core/state/clearing.ts понимает, что линия/уровень заполнена) в gameController генерировалось явное событие уровня "start destruction визуала", аналогичное тому, что используется в visualDebugMode:

Посмотреть, какие типы событий/команд уже описаны в src/app/events.ts и какие из них используют destruction‑модули (см. destructionStarter.ts / orchestrator.ts / lineDestructionScenario.ts).

Если в events.ts уже есть что‑то вроде StartLineDestruction / DestructionRequested, использовать его; если нет — добавить новый тип событий (например, GameEventType.LinesDestructionRequested) с полезной нагрузкой:

номера уровней/рядов;

world‑позиции/радиус башни (если нужно для сценария).

В gameController при фиксации факта “эти уровни заполнены и переходят в фазу clearing”:

НЕ сразу удалять логически клетки;

а:

перевести домен в статус “clearing” (как и сейчас),

сгенерировать LinesDestructionRequested для приложенческого слоя.

12Q.1.2. Использовать те же starter/orchestrator, что и visualDebug

Файлы:
src/app/destruction/destructionStarter.ts, orchestrator.ts, simulationManager.ts,
src/app/visualDebugMode.ts.

Открыть visualDebugMode.ts и посмотреть, как там запускается debug‑разрушение:

где создаётся SimulationManager / DestructionStarter;

как вызывается сценарий (lineDestructionScenario, rowDestructionSim и т.п.);

как связывается DestructionSimulationState с рендером.

В gameController создать такие же объекты (DestructionStarter, SimulationManager) один раз (при инициализации контроллера/рендера) и хранить их:

или внутри gameController;

или в общей структуре приложения, если она уже есть (см. как это сделано в visualDebugMode).

На событие LinesDestructionRequested (см. 12Q.1.1):

вызывать тот же метод destructionStarter.startLineDestruction(...) / аналогичный, который используется в debug.

передавать номера уровней/рядов и параметры сценария (скорость волны и т.п. — можно брать из тех же пресетов).

12Q.1.3. Обновлять destruction‑симуляцию в основном game‑loop

Файлы:
src/main.ts, src/app/destruction/simulationManager.ts.

В main.ts в основном цикле (где уже обновляется gameController и renderer):

добавить вызов simulationManager.update(deltaTime) (тот же, что используется в visualDebug).

Убедиться, что SimulationManager знает:

ссылку на DestructionSimulationState;

конфиги пресета;
(копировать подход из visualDebugMode.ts).

12Q.1.4. Подключить визуальное отображение фрагментов и маску к renderer’у

Файлы:
src/render/renderer.ts, src/render/sceneRenderer.ts,
src/render/destruction/fragmentInstancedMesh.ts, instanceUpdater.ts,
src/app/destruction/fragmentInstances.ts, visualMask.ts.

Скопировать схему wiring’а из visualDebugMode.ts:

Создание фрагментных instanced‑mesh’ей:

В renderer.ts уже есть код, создающий FragmentInstancedResources через createFragmentInstancedMeshes.

Убедиться, что этот ресурс создаётся и в боевом режиме, и хранится внутри renderer/sceneRenderer.

Обновление инстансов по состоянию симуляции:

В sceneRenderer.ts добавить шаг, который:

Берёт текущий FragmentInstances/FragmentInstanceUpdate из destruction‑слоя.

Передаёт их в instanceUpdater.applyFragmentInstanceUpdates(...) для каждого соответствующего InstancedMesh.

Маскировка целых кубов в процессе разрушения:

Использовать visualMask.ts (как в visualDebug):

при активном разрушении рядов не рисовать целые кубы этих рядов;

но продолжать рисовать остальные уровни.

Для этого sceneRenderer.ts должен при рендеринге board‑instanced mesh учитывать mask‑битовую карту/индексы из visualMask.

Критерий:
В обычной игре, когда игрок собирает полный круг/ряд, запускается та же симуляция, что в visualDebug: ряд скрывается, кубы этого ряда реально разлетаются, сверху падают уровни, доменное состояние после завершения симуляции переходит обратно в running.

12Q.2. Единый внешний вид кубиков до и после lock

Цель: внешний вид блоков после фиксации полностью совпадает с видом активного падающего тетримино (цвет, металл, roughness, освещение и текстуры).

12Q.2.1. Выбрать “канонический” материал

Файлы:
src/render/activePieceInstancedMesh.ts,
src/render/boardInstancedMesh.ts,
src/render/beveledBoxGeometry.ts, src/render/textures.ts.

Принять за эталон вид активной фигуры (падающее тетримино, с красивыми золотыми боками и лицевыми тайлами).

Проверить:

Какие именно материалы создаются в activePieceInstancedMesh (обычно массив из faceMaterial, goldSidesMaterial).

Какие материалы/геометрия используются в boardInstancedMesh (скорее всего один упрощённый материал/геометрия без бокового gold).

12Q.2.2. Вынести создание материалов в общий helper

В textures.ts или новом файле (например, tileMaterials.ts) сделать функцию:

export interface TileMaterials {
  face: THREE.MeshStandardMaterial;
  goldOuter: THREE.MeshStandardMaterial;
  goldInner?: THREE.MeshStandardMaterial;
}

export function createCanonicalTileMaterials(atlasSize: number): TileMaterials { ... }


которая:

использует тот же createMahjongTileTexture / createMahjongMaterialMaps;

создаёт ровно те же материалы, что сейчас используются для active piece.

Обновить activePieceInstancedMesh.ts:

вместо локального создания материалов — вызывать createCanonicalTileMaterials.

12Q.2.3. Заставить boardInstancedMesh использовать те же материалы и геометрию

В boardInstancedMesh.ts:

Использовать ту же beveled‑box‑geometry, что и активная фигура (beveledBoxGeometry.ts), с идентичной UV‑развёрткой;

Присвоить mesh’у те же материалы (TileMaterials) / тот же массив материалов:

либо один instanced mesh с multi‑material;

либо два instanced mesh (face + gold), если так проще — главное, чтобы визуально он совпадал.

Убедиться, что:

настройки metalness, roughness, envMapIntensity, aoMap, roughnessMap, metalnessMap совпадают;

receiveShadow/castShadow включены так же, как у active piece.

12Q.2.4. Согласовать сцену при lock’е

Файл: src/render/sceneRenderer.ts.

Логика такая:

Пока фигура активна → она рендерится через ActivePieceInstancedMesh (с canonical‑материалами).

После lock’а:

соответствующие клетки записываются в board‑state;

active piece просто перестаёт рисоваться;

boardInstancedMesh, у которого та же геометрия и материалы, рисует эти же кубы на тех же местах.

Проверить, что:

позиционирование board‑ячейки совпадает с позиционированием активного блока (никакого сдвига/масштаба).

никаких “альтернативных” материалов не подставляется в зависимости от статуса клетки.

Критерий:
Визуально нет ни единого кадра, где цвет/глянец кубика “прыгает” в момент lock’а. Куб выглядел так во время падения — и точно так же выглядит, став частью стены.

---

## Этап 13. Производительность, оптимизация и полировка

### 13.1. Оптимизация рендера

[ ] 13.1.1. Убедиться, что:

* используется instancing для большого числа блоков;
* не создаются/не удаляются Mesh‑объекты каждый кадр без необходимости.

[ ] 13.1.2. При необходимости:

* ввести LOD‑механику (для отдалённых объектов упрощать геометрию);
* оптимизировать материалы (минимум текстур/шейдеров).

### 13.2. Оптимизация домена

[ ] 13.2.1. Проверить горячие места (обновление доски, поиск полных слоёв):

* заменить очевидные неоптимальные операции (например, полные копии массивов) на более простые.

### 13.3. UX‑полировка

[ ] 13.3.1. Добавить небольшие эффекты:

* лёгкая анимация камеры при разрушении;
* мерцание или подсветка активной фигуры;
* звуки (позже, отдельным мини‑этапом).

[ ] 13.3.2. Настроить чувствительность управления:

* задержка повторения движения;
* отзывчивость soft/hard drop.

---

## Этап 14. Сценарии, похожие на рекламный ролик

### 14.1. Предзаполненные конфигурации башни

[ ] 14.1.1. Добавить возможность загружать стартовые конфигурации поля (уровни):

* через JSON или встроенные пресеты.

[ ] 14.1.2. Создать пресет, имитирующий рекламный ролик:

* почти полностью заполненная башня;
* одна вертикальная зигзагообразная “шахта” для идеального хода.

### 14.2. Режим демонстрации (автоигра)

[ ] 14.2.1. Реализовать простой “скрипт” действий:

* последовательность команд, которые ставят нужную фигуру в нужное место;
* запуск автоматического демо без участия игрока.

**Критерий завершения Этапа 14:**
Можно запустить игру в режиме, визуально напоминающем рекламу: красиво ломается башня, есть “идеальный” ход.

---

## Этап 15. Финальная зачистка и документация

[ ] 15.1. Пройтись по коду:

* убрать мёртвый/комментированный код;
* унифицировать стиль в соответствии с `convention.txt`.

[ ] 15.2. Обновить/написать README:

* описание игры;
* как запускать;
* краткое описание архитектуры (ссылки на `architecture.txt` и `plan.txt`).

[ ] 15.3. Проверить, что:

* все тесты проходят;
* проект собирается без ошибок;
* игра запускается и работает стабильно.

---

На этом план заканчивается.
Дальше можно брать любой подэтап (например, `2.2.1` или `7.2.3`), цитировать его в запросе к нейросети и требовать **строгого следования** `architecture.txt` + `convention.txt` при реализации именно этого фрагмента.
