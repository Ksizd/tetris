Ниже — содержимое `plan.txt`. Это **рабочий план для нейросети и людей**, по которому можно поэтапно собирать весь проект, соблюдая `architecture.txt` и `convention.txt`.

---

# План разработки 3D Tower Tetris (plan.txt)

## Контекст проекта и использование 3d_helper_system

Этот план относится к браузерной 3D‑игре «Tower Tetris 3D» — вариации тетриса,
где игровое поле представляет собой цилиндрическую башню из кубиков в стиле
Mahjong. Игрок управляет падающими фигурами в 3D‑пространстве, вращая их вокруг
башни и заполняя уровни. При заполнении полного кольца этаж башни разрушается
с визуальными эффектами.

План описывает последовательность реализации функциональности, но **умышленно
не расписывает подробно 3D‑диагностику и тестовые стенды**. Для любых этапов,
которые затрагивают:

- 3D‑геометрию и преобразование координат;
- движение и ориентацию объектов;
- коллизии, физику и размещение в пространстве;
- камеру и визуальные эффекты разрушения;

при необходимости должны использоваться методологии из файла
`3d_helper_system.txt` (лаборатории, инварианты, логи, диагностические отчёты).

Этот файл является **кросс‑проектным дополнением**: он задаёт общие подходы к
тестированию и диагностике 3D‑сцен, поэтому его можно применять и в других
3D‑проектах с другим планом, но с общей архитектурой и конвенциями.


## 0. Как пользоваться этим планом

* Работать **по этапам и подэтапам**, не перепрыгивая вперёд.
* В каждом запросе к нейросети явно указывать, **какой пункт / подпункт** сейчас реализуется (например: `Этап 3.2`).
* В одном запросе — **ограниченный, чёткий подэтап**, чтобы код получался сфокусированным.
* При реализации подэтапа нейросеть:

  * следует архитектуре (`architecture.txt`);
  * следует конвенциям (`convention.txt`);
  * не меняет другие части проекта без необходимости;
  * при необходимости затронуть существующий код — описывает, **какие именно изменения** и почему.

Структура плана:

* **Этапы** (1, 2, 3, …) — крупные блоки работ.
* **Подэтапы** (1.1, 1.2, …) — то, что разумно делать за 1–3 запроса к нейросети.
* **Подподэтапы** (1.2.1…) — если нужно ещё сильнее раздробить задачу.

---

## Этап 1. Инициализация проекта и инфраструктуры

### 1.1. Базовая структура проекта

**Цель:** создать минимальный, но аккуратный каркас проекта без реализации игры.

[ ] 1.1.1. Создать базовый проект (без сборщика или с простым Vite/webpack/esbuild по выбору).
[ ] 1.1.2. Организовать корневую структуру каталогов, например (пример, а не жёсткое требование):

* `src/`

  * `core/` — доменный слой (логика игры, без браузера).
  * `app/` — слой приложения (игровая сессия, команды, главный цикл).
  * `render/` — рендеринг 3D.
  * `input/` — ввод.
  * `ui/` — HUD, меню.
  * `util/` — общие утилиты.
* `public/` — статические ресурсы (иконки, текстуры и т.д.).

[ ] 1.1.3. Создать пустой `index.html` с `<canvas>` или контейнером для WebGL и базовым `<div>` для HUD.
[ ] 1.1.4. Создать **главную точку входа** (например `src/main.ts`), которая пока просто:

* находит в DOM контейнер для рендера;
* пишет в консоль, что приложение запущено.

### 1.2. Настройка языка и качества кода

[ ] 1.2.1. Включить TypeScript:

* настроить `tsconfig` с strict‑режимом;
* указать целевой стандарт ES2020+.

[ ] 1.2.2. Настроить форматирование и линтинг (по желанию):

* Prettier / ESLint или аналог, согласно `convention.txt`.

[ ] 1.2.3. Добавить базовую структуру тестов (если используется тестовый фреймворк):

* решить, какой фреймворк (Jest/Vitest и т.д.);
* подготовить 1 простой тест «Hello test», чтобы убедиться, что всё работает.

**Критерий завершения Этапа 1:**
Проект собирается и запускается, в консоли браузера видно простое сообщение, тесты (если есть) проходят.

---

## Этап 2. Доменный слой: геометрия поля и базовые типы

Цель этапа — создать ядро, описывающее цилиндрическое поле и ячейки, **без фигур и правил**.

### 2.1. Базовые типы и константы домена

[ ] 2.1.1. Определить конфигурационный тип для размеров поля:

* ширина (кол-во секторов по окружности),
* высота (кол-во уровней по вертикали).

[ ] 2.1.2. Определить перечисления/типы для:

* типа содержимого ячейки (`empty`, `block` и т.п.);
* статуса игры (будет использоваться позже, но можно описать тип уже сейчас).

[ ] 2.1.3. Создать набор доменных констант:

* стандартные размеры поля (по умолчанию, но не жестко захардкоженные);
* параметры по умолчанию для уровней (будут расширены на Этапе 4).

### 2.2. Координаты цилиндрического поля

[ ] 2.2.1. Реализовать утилиту для манипулирования координатами:

* структура `CellCoord { x: number; y: number; }` (или аналогичный тип).

[ ] 2.2.2. Реализовать функции:

* нормализация `x` по ширине (`wrapX`, модуль по ширине поля);
* проверка валидности координат (`isInsideBoard`);
* получение соседних ячеек (влево/вправо/вверх/вниз) в терминах цилиндра.

[ ] 2.2.3. Написать **юнит‑тесты** на:

* корректность обёртки по `x`;
* корректность проверки границ по `y`;
* сценарии `x = -1`, `x = width`, большие/отрицательные значения.

### 2.3. Модель поля (Board)

[ ] 2.3.1. Спроектировать тип/класс `Board` (без логики фигур):

* хранит сетку `height x width` с флагами занятости (занято / пусто / тип блока);
* предоставляет методы:

  * чтения клетки (`getCell`),
  * записи (`setCell`),
  * очистки строки по `y`,
  * проверки, полностью ли заполнен слой (строка `y`).

[ ] 2.3.2. Реализовать конструктор/фабрику для создания пустой доски с заданными размерами.

[ ] 2.3.3. Реализовать методы:

* `isLayerFull(y)` — заполнен ли этот уровень;
* `clearLayer(y)` — очистить один уровень (без «гравитации»);
* `clone()` или безопасный способ получить копию (для тестов/симуляций).

[ ] 2.3.4. Написать тесты:

* создание пустой доски;
* установка и считывание ячейки;
* работа `isLayerFull` при разных конфигурациях;
* очистка строки и сохранение остальных.

**Критерий завершения Этапа 2:**
Есть устойчивый доменный модуль `Board` + утилиты координат, полностью покрытые базовыми тестами, без привязки к рендеру и UI.

---

## Этап 3. Доменный слой: фигуры (тетримино) и коллизии

Цель — описать фигуры, их вращение и базовую коллизию с полем.

### 3.1. Описание фигур

[ ] 3.1.1. Создать тип `PieceType` (enum: I, O, T, S, Z, J, L).

[ ] 3.1.2. Сформировать структуру данных для базовых форм фигур (например, в локальных координатах 4x4):

* каждая фигура описывается списком относительных координат блоков;
* для квадрата `O` вращения тривиальны (можно не хранить отдельные ориентации).

[ ] 3.1.3. Определить тип/структуру `PieceOrientation` (0..3).

[ ] 3.1.4. Создать модуль/серивис, который:

* предоставляет данные о блоках фигуры для заданного `PieceType` и ориентации;
* не знает о поле, только о фигуре.

### 3.2. Вращение фигур

[ ] 3.2.1. Реализовать функцию/метод:

* `rotatePiece(piece, direction)` — возвращает новую ориентацию, учитывая 4 состояния.

[ ] 3.2.2. Определить, используем ли **простое вращение** или систему wall‑kick (на старте можно простое, без сложных стенок).

[ ] 3.2.3. Написать тесты:

* корректность ориентаций и последовательности вращений;
* наличие всех блоков после вращения (их количество не меняется);
* для фигур, где форма “не меняется” (O), убедиться, что результат стабилен.

### 3.3. Позиционирование фигуры на поле

[ ] 3.3.1. Определить тип `ActivePiece`:

* `type` (PieceType);
* `orientation`;
* `position` (CellCoord) — базовая точка, относительно которой считаются блоки фигуры (например, левый нижний блок или условный центр).

[ ] 3.3.2. Реализовать функцию:

* `getWorldBlocks(piece)` — возвращает список координат всех блоков фигуры в мировых координатах поля с учётом обёртки по `x`.

[ ] 3.3.3. Написать тесты:

* простое позиционирование;
* обёртка по `x` при `position.x` у границы;
* корректность `y` (наружу поля не делаем обёртку, только проверку).

### 3.4. Проверка коллизий фигуры с полем

[ ] 3.4.1. Реализовать функцию:

* `canPlacePiece(board, piece)` — проверяет, что все блоки:

  * находятся в пределах по `y` (не ниже 0, но могут быть выше `height - 1` при спауне);
  * не пересекаются с занятыми ячейками доски (если `y` в пределах доски).

[ ] 3.4.2. Реализовать функции:

* `canMove(piece, dx, dy)` — проверяет возможность смещения;
* `canRotate(piece, direction)` — проверяет возможность вращения.

[ ] 3.4.3. Написать тесты:

* коллизия с нижней границей;
* коллизия со стенками в терминах цилиндра (левая/правая сравниваются через обёртку);
* коллизия с уже занятыми блоками.

**Критерий завершения Этапа 3:**
Фигуры и коллизии полностью работают и покрыты тестами, без каких‑либо 3D или UI.

---

## Этап 4. Доменный слой: правила игры и состояние

### 4.1. Структура `GameState`

[ ] 4.1.1. Создать тип/класс `GameState`, который содержит:

* `board` — игровое поле;
* `currentPiece` — активная фигура или `null`;
* `nextPieces` — очередь следующих фигур;
* `score`, `level`, `linesCleared` (этажей очищено);
* флаг/enum `gameStatus` (`running`, `paused`, `clearing`, `gameOver`, и т.п.);
* любые дополнительные счётчики для таймингов (progress падения и т.д. — можно в отдельной структуре).

[ ] 4.1.2. Реализовать функцию/конструктор `createInitialGameState(config)`.

### 4.2. Генерация фигур

[ ] 4.2.1. Создать модуль генерации фигур:

* тип генератора (например, класс/функция), которому можно передать seed (для тестов);
* простой алгоритм (рандом с равномерным распределением или классический “мешок” из 7 фигур).

[ ] 4.2.2. Реализовать методы:

* `getNextPiece()` — достаёт фигуру из генератора/очереди;
* `peekNextPiece()` — смотрит следующую для HUD.

[ ] 4.2.3. Обновить `GameState`, чтобы при создании сразу заполнялась очередь следующих фигур.

### 4.3. Логика падения и шаг симуляции

[ ] 4.3.1. Определить в домене параметры для скорости падения:

* базовый интервал падения в секундах/тик;
* зависимость от уровня (будет масштабировать время).

[ ] 4.3.2. Реализовать функцию `tickGame(state, deltaTime)`, которая:

* обновляет внутренний таймер падения;
* когда накоплено достаточно времени:

  * пытается опустить фигуру вниз (`dy = -1`);
  * если не может — запускает **процесс фиксации фигуры**.

[ ] 4.3.3. Обработать сценарий, когда текущей фигуры нет (например, после фиксации до генерации новой):

* создать новую фигуру сверху;
* проверить, не завершена ли игра (коллизия при спауне);
* при невозможности спауна — `gameStatus = gameOver`.

### 4.4. Фиксация фигуры и очистка слоёв

[ ] 4.4.1. Реализовать функцию `lockCurrentPiece(state)`, которая:

* записывает блоки фигуры в `board`;
* сбрасывает `currentPiece` в `null`.

[ ] 4.4.2. Реализовать функцию `findFullLayers(board)`:

* возвращает массив уровней `y`, где строка полностью заполнена.

[ ] 4.4.3. Спроектировать 2‑стадийную очистку:

1. После фиксации:

   * найти все заполненные уровни;
   * если их нет — перейти к спауна новой фигуры;
   * если есть:

     * сохранить список очищаемых уровней в состояние;
     * поменять статус игры на `clearing` (для визуальных эффектов).
2. Отдельная функция/стадия:

   * по завершении анимации (об этом сообщит Application/Rendering) вызвать доменную функцию:

     * окончательно удалить эти уровни;
     * “ронять” верхние строки вниз;
     * обновить счёт и уровень;
     * вернуть статус в `running` и сгенерировать новую фигуру.

### 4.5. Система очков и уровней

[ ] 4.5.1. Определить и реализовать:

* шкалу очков за количество очищенных уровней за один ход (1,2,3,4 и т.д.);
* бонусы за «комбо» (опционально).

[ ] 4.5.2. Реализовать логику повышения уровня:

* при достижении определённого количества очищенных слоёв или очков;
* уменьшать интервал падения.

### 4.6. Обработка команд игрока на уровне домена

[ ] 4.6.1. Определить абстрактный тип команд (например `GameCommand`):

* `MoveLeft`, `MoveRight`,
* `RotateCW`, `RotateCCW`,
* `SoftDrop`, `HardDrop`,
* `TogglePause` и т.п.

[ ] 4.6.2. Создать функцию `applyCommand(state, command)`, которая:

* в зависимости от команды:

  * пытается сместить/повернуть фигуру (через `canMove` / `canRotate`);
  * выполняет soft/hard drop;
  * переключает паузу (статус игры).

[ ] 4.6.3. Написать тесты:

* серия команд приводит к ожидаемой конфигурации;
* hard drop действительно доводит фигуру до упора и запускает фиксацию;
* soft drop ускоряет падение без “телепорта”.

**Критерий завершения Этапа 4:**
Доменный слой умеет:

* поддерживать полное состояние игры;
* двигать и вращать фигуры по командам;
* фиксировать фигуры, чистить слои и считать очки/уровни;
  — всё это без единой строчки WebGL/DOM кода.

---

## Этап 5. Application Layer: игровой контроллер и главный цикл

Цель — создать “мозг” приложения, который связывает домен с временем и командами, но ещё не знает о 3D‑рендере.

### 5.1. Командный интерфейс приложения

[ ] 5.1.1. Создать класс/модуль Application‑слоя (условно `GameController`), который:

* держит экземпляр `GameState`;
* предоставляет методы:

  * `update(deltaTime)` — один шаг симуляции;
  * `enqueueCommand(command)` — передать команду от ввода;
  * `getSnapshot()` — вернуть **read‑only** снимок состояния для рендера и UI.

[ ] 5.1.2. Внутри `update`:

* забрать очередь команд;
* последовательно применить их к состоянию через `applyCommand`;
* вызвать `tickGame` с `deltaTime`;
* возвращать/сохранять информацию о произошедших **событиях** (см. 5.2).

### 5.2. Система событий

[ ] 5.2.1. Определить тип/enum событий (**Domain Events**), например:

* `LinesCleared` (с информацией, какие уровни и сколько);
* `PieceLocked`;
* `NewPieceSpawned`;
* `GameOver`.

[ ] 5.2.2. В `update` накапливать события за шаг симуляции:

* чтобы рендер и UI могли реагировать (например, запускать анимации разрушения).

[ ] 5.2.3. Реализовать метод `getEvents()` или возвращать события из `update`.

### 5.3. Интеграционные тесты (без рендера)

[ ] 5.3.1. Написать несколько сценариев:

* фигура падает и блокируется;
* последовательность, приводящая к очистке уровня;
* переход в состояние `gameOver`.

[ ] 5.3.2. Убедиться, что через `GameController` корректно прокладывается весь поток:

* команда → изменения состояния → события.

**Критерий завершения Этапа 5:**
Есть “чистый” игровой контроллер, который можно запускать в любой среде (даже в Node.js), чтобы симулировать игру.

---

## Этап 6. Rendering: базовая 3D‑сцена

Цель — поднять минимальную 3D‑сцену с башней из кубиков и без полноценной игры.

### 6.1. Инициализация рендера

[ ] 6.1.1. Создать модуль рендера, который:

* инициализирует Three.js (или выбранную 3D‑библиотеку);
* создаёт `Scene`, `Camera`, `Renderer`.

[ ] 6.1.2. Камера:

* перспективная;
* расположена так, чтобы башня целиком помещалась в кадр;
* смотрит на центр сцены.

[ ] 6.1.3. Освещение:

* хотя бы один `AmbientLight` и один `DirectionalLight`.

[ ] 6.1.4. Отрисовать тестовый примитив (один куб), чтобы проверить, что всё работает.

### 6.2. Связь рендера с DOM и resize

[ ] 6.2.1. Подключить canvas рендера к DOM (через контейнер).
[ ] 6.2.2. Реализовать обработку изменения размера окна:

* изменять размер рендера;
* обновлять aspect ratio камеры.

### 6.3. Главный рендер‑цикл

[ ] 6.3.1. Реализовать анимационную петлю:

* `requestAnimationFrame`;
* вычисление `deltaTime` (в секундах).

[ ] 6.3.2. На каждом кадре:

* вызывать `GameController.update(deltaTime)` (позже, после подключения контроллера);
* вызывать ф-цию `renderScene(snapshot)`.

На этом этапе snapshot можно временно подделывать (статичный тестовый стейт), чтобы просто видеть башню.

**Критерий завершения Этапа 6:**
В браузере видна 3D‑сцена, рендер обновляется по кадрам, камера и свет настроены базово.

---

## Этап 7. Rendering: отображение башни и поля

Цель — научиться визуализировать `Board` как цилиндрическую башню из кубиков.

### 7.1. Преобразование координат поля в 3D‑пространство

[ ] 7.1.1. Создать модуль/утилиту `BoardToWorldMapper`:

* функции:

  * `cellToWorldPosition(x, y)` → `Vector3`;
  * учитывает:

    * радиус цилиндра;
    * высоту блока;
    * обёртку `x` на окружность.

[ ] 7.1.2. Задать константы для:

* `blockSize`;
* `towerRadius`;
* `verticalSpacing` (обычно = `blockSize`).

[ ] 7.1.3. Написать небольшие тесты (необязательно авто‑, можно ручные):

* убедиться, что соседние `x` формируют равномерную окружность;
* `y` растёт вверх.

### 7.2. Меши для блоков башни

[ ] 7.2.1. Реализовать базовую геометрию куба (одна форма для всех блоков):

* материал просто цветной (белый / жёлтый), текстуры пока не нужны.

[ ] 7.2.2. Использовать instanced mesh или собственный пул мешей:

* чтобы не создавать тысяч отдельных объектов в сцене.

[ ] 7.2.3. Реализовать функцию `renderBoard(boardSnapshot)`:

* очищает/обновляет инстансы в зависимости от состояния поля;
* отрисовывает только занятые ячейки.

### 7.3. Визуализация пустоты / внутренней стенки

[ ] 7.3.1. Добавить внутренний цилиндр:

* радиус чуть меньше `towerRadius`;
* материал жёлтый, создающий вид «заполненной» башни внутри.

[ ] 7.3.2. Убедиться, что через “дыры” в башне видно внутреннюю стенку.

**Критерий завершения Этапа 7:**
Игровая доска домена отображается как цилиндрическая башня; изменения в `Board` отражаются в 3D.

---

## Этап 8. Rendering: активная фигура и базовая анимация

### 8.1. Отрисовка активной фигуры

[ ] 8.1.1. Создать отдельный набор мешей/инстансов для текущей фигуры.

[ ] 8.1.2. Реализовать функцию `renderActivePiece(pieceSnapshot)`:

* использует те же правила координат, что и `BoardToWorldMapper`;
* визуально отличает активную фигуру (например, другим оттенком или эмиссией).

### 8.2. Плавная анимация падения и движения

[ ] 8.2.1. В Application‑слой добавить представление “прогресса падения” между клетками (для интерполяции).
[ ] 8.2.2. В рендере:

* позиционировать кубики фигуры с учётом этого прогресса (между `y` и `y-1`);
* при горизонтальном смещении — при желании тоже интерполировать углы.

[ ] 8.2.3. Убедиться визуально, что фигура:

* плавно падает вниз;
* мгновенно/быстро реагирует на команды игрока.

**Критерий завершения Этапа 8:**
Фигура падает, двигается и вращается в 3D в соответствии с доменной логикой.

---

## Этап 9. Input Layer: управление с клавиатуры

### 9.1. Маппинг клавиш на команды

[ ] 9.1.1. Создать модуль ввода (например, `KeyboardInput`), который:

* подписывается на события `keydown` и, возможно, `keyup`;
* отображает клавиши на `GameCommand`:

  * `←` / `→` — MoveLeft / MoveRight;
  * `↑` — RotateCW;
  * `Z` — RotateCCW (опционально);
  * `↓` — SoftDrop;
  * `Space` — HardDrop;
  * `P` — TogglePause.

[ ] 9.1.2. Иметь очередь команд:

* при событии клавиши складывать соответствующую команду в очередь;
* Application‑слой периодически забирает и очищает эту очередь.

### 9.2. Поведение повторения и анти‑дребезг

[ ] 9.2.1. Решить, поддерживаем ли повтор (`auto repeat`) для MoveLeft/MoveRight/SoftDrop:

* можно реализовать простой таймер задержки для начала повторения.

[ ] 9.2.2. Избежать многократного срабатывания hard drop и паузы:

* по `keydown` реагировать только на первый `keydown` до `keyup`.

**Критерий завершения Этапа 9:**
Игрок может управлять фигурой с клавиатуры, команды доходят до домена через Application‑слой.

---

## Этап 10. UI / HUD и игровые статусы

### 10.1. HUD (очки, уровень, следующая фигура)

[ ] 10.1.1. Создать простой 2D‑HUD (DOM или Canvas 2D) поверх WebGL:

* панель с текущим счётом;
* уровень;
* количество очищенных этажей.

[ ] 10.1.2. Добавить окно превью следующей фигуры:

* 2D‑рисунок маленькими квадратиками.

[ ] 10.1.3. Обновлять HUD при каждом рендер‑кадре на основе snapshot из Application‑слоя.

### 10.2. Стартовый экран, пауза, Game Over

[ ] 10.2.1. Определить состояния приложения:

* `mainMenu`, `playing`, `paused`, `gameOver`.

[ ] 10.2.2. Добавить простое меню:

* кнопка “Start Game”;
* опционально “Restart” при Game Over.

[ ] 10.2.3. Реализовать:

* затемнение/оверлей при паузе;
* экран “Game Over” с очками и предложением начать заново.

**Критерий завершения Этапа 10:**
Игра выглядит как цельное приложение: есть HUD, старт/пауза/конец, всё управляется через Application‑слой.

---

## Этап 11. Визуальный стиль: Mahjong‑текстуры, освещение, пол

Цель — приблизиться к рекламному ролику по визуалу.

### 11.1. Материалы и текстуры блоков

[ ] 11.1.1. Подготовить/подключить текстуры Mahjong‑плитки:

* белая “плитка” с красным символом;
* корректная UV‑развёртка для кубика.

[ ] 11.1.2. Обновить материалы блоков:

* внешний слой — текстурированный материал;
* внутренние грани и/или внутренний цилиндр — жёлтый материал.

### 11.2. Свет и тени

[ ] 11.2.1. Настроить освещение:

* направленный свет с мягкой тенью;
* ambient‑свет для заполнения.

[ ] 11.2.2. По возможности включить тени:

* блоки/башня отбрасывают тень на пол.

### 11.3. Пол с отражением

[ ] 11.3.1. Добавить чёрный глянцевый пол:

* плоскость под башней;
* использовать отражения (либо с помощью зеркального материала, либо фейковый отражающий шейдер, либо дублирование сцены вниз с масштабом по Y = -1).

**Критерий завершения Этапа 11:**
Башня выглядит узнаваемо: Mahjong‑блоки, жёлтая внутренняя часть, отражение на полу и приятное освещение.

---

Этап 11x. Визуальный сверх‑полиш башни
Цели этапа

Сделать башню визуально неотличимой от “рекламного” референса или лучше:

правильный ракурс камеры (виден и верх, и низ, башня выглядит монументально, а не “палкой вдали”);

высокая “круглость” цилиндра (52–55 кубиков в окружности или эквивалент);

реалистичные кубики:

белая лицевая грань с красным иероглифом строго по центру;

остальные грани — красивое золото;

сглаженные рёбра (bevel);

заметные, аккуратные зазоры между кубами;

сочный PBR‑материал (блики, отражения, мягкие тени, приятные цвета).

Сделать всё так, чтобы:

это ложилось поверх уже существующей архитектуры рендера;

не ломало доменную логику;

легко расширялось для будущей анимации разрушения.

11x.1. Анализ текущего состояния и выделение параметров

Задача: ввести “набор ручек”, которые можно крутить (камера, размеры, материалы, свет).

[ ] 11x.1.1. Вынести в конфиг (render‑layer) параметры:

towerRadius

blockSize

boardWidth (количество кубиков по окружности)

положение камеры (cameraPosition, cameraTarget)

FOV камеры (cameraFov)

параметры света (интенсивность, цвет, направление)

включение/выключение пост‑эффектов (bloom и т.п.)

[ ] 11x.1.2. Сделать небольшой “режим девелопмента визуала”:

переключатель visualDebugMode или отдельная сцена;

в этом режиме:

нет геймплея (можно поставить статичную конфигурацию башни);

рядом/в консоль выводятся текущие значения основных параметров.

[ ] 11x.1.3. (Опционально) Подготовить простенький UI для твика (например, через dat.GUI / lil-gui):

слайдеры для:

FOV

дистанции камеры

высоты камеры

radius башни

интенсивности света и отражений.

Это сильно ускорит ручную подгонку.

11x.2. Камера и композиция кадра

Цель: башня должна выглядеть как в референсе — целиком в кадре, чуть сверху, с запаса по верх/низ.

[ ] 11x.2.1. Настроить позицию камеры:

камера чуть выше середины башни, смотрит немного вниз:

Y камеры ≈ 0.55–0.65 от высоты башни;

расстояние до центра башни такое, чтобы:

башня полностью влезала по вертикали;

по горизонтали оставался небольшой отступ (чёрный фон или рамка).

[ ] 11x.2.2. Настроить FOV:

подобрать FOV так, чтобы:

башня не выглядела “размазанной палкой” (слишком узкий FOV);

и не была с огромной перспективной деформацией (слишком широкий FOV).

ориентир: FOV ~ 30–45° — но подбирать экспериментально с учётом радиуса.

[ ] 11x.2.3. Реализовать адаптацию под размер окна:

при изменении размера окна:

пересчитывать aspect ratio;

при необходимости чуть подстраивать Z‑позицию камеры, чтобы башня по вертикали всегда целиком помещалась в кадр с небольшим запасом.

[ ] 11x.2.4. Добавить микро‑анимацию камеры (потом, когда всё настроено):

лёгкий “дыхательный” motion:

едва заметное покачивание/орбита вокруг башни с очень маленькой амплитудой,

но это можно оставить ближе к финалу, главное — чтобы базовый статичный ракурс был идеален.

11x.3. Геометрия башни: количество кубиков и “круглость”

Цель: сделать цилиндр визуально гладким, как в референсе (52–55 кубиков вокруг).

[ ] 11x.3.1. Определиться с boardWidth (логической шириной):

вариант A (прямой): установить boardWidth ≈ 52–56, чтобы логика и визуал один к одному → одна логическая колонка = один куб.

вариант B (двухуровневый): оставить логическую ширину меньше (например, 24), но:

визуально рисовать “подсетку” фоновых золотых кубиков с шагом в 52–56 сегментов;

а активные белые кубы занимать несколько визуальных ячеек по окружности.

Для чистоты и простоты (особенно пока проект не в продакшне), лучше:

прямо увеличить boardWidth до требуемого количества, чтобы потом не страдать с проекцией.

[ ] 11x.3.2. Пересчитать радиус башни исходя из:

размер кубика blockSize;

количество кубиков по окружности boardWidth.

Цель: чтобы кубы:

стояли плотно, без зазоров/нахлёстов по окружности;

между ними были видны вертикальные швы (маленький зазор);

но не было видимых “ступенек”.

Формула:
окружность ≈ boardWidth * (blockSize + gap) →
radius ≈ окружность / (2π).

[ ] 11x.3.3. Проверить, что:

при отрисовке уровня:

каждый кубик повёрнут наружу (нормаль лицевой грани смотрит от центра);

отсутствуют визуальные пересечения соседних кубов;

зазоры между кубами не “слишком жирные” и не “слишком нулевые”.

[ ] 11x.3.4. Если логическая ширина была изменена:

убедиться, что все доменные операции (фигуры, вращение, очистка слоёв) корректно работают с новым boardWidth;

возможно, обновить стартовые уровни и настройки (скорость, формы фигур).

11x.4. Кубик как объект: форма, сглаженные рёбра, фаски

Цель: уйти от “плоского простого куба” к “реалистичной плитке”.

[ ] 11x.4.1. Определить пропорции кубика:

чуть сплющенный “брусок” вместо идеального 1×1×1:

например, толщина < ширины/высоты (по желанию);

но важно, чтобы:

лицевая грань была чуть больше выделена;

куб не выглядел “кирпичом для стен”.

[ ] 11x.4.2. Реализовать bevel / chamfer (сглаженные рёбра):

вариант A: геометрия с фасками:

создать кастомную геометрию куба с небольшими скошенными гранями;

или использовать параметризированный “rounded box” (можно написать свой генератор).

вариант B: normal map, если не хочется увеличивать полигоны:

сгенерить/нарисовать нормал‑карту, которая имитирует сглаженные рёбра;

применить её к материалу плитки.

На старте:

лучше сделать реальный геометрический bevel (как минимум по 1 сегменту на ребро),
а потом, если сильно бьёт по производительности, оптимизировать.

[ ] 11x.4.3. Убедиться, что:

фаски не слишком большие (чтобы не было ощущения “резинового кубика”);

на фасках хорошо считываются блики;

не возникает геометрических артефактов (перекрученные нормали, дырки).

11x.5. Текстурирование и UV‑развёртка куба

Цель: лицевая грань — белая плитка с красным иероглифом; остальные — золото. Всё без растягивания/смещений.

[ ] 11x.5.1. Спроектировать UV‑развёртку для куба:

карта 1×1, где:

лицевая грань (та, что смотрит наружу) занимает, например, верхнюю часть текстуры (top area),

остальные 5 граней — нижнюю часть (bottom area) или отдельные сегменты.

[ ] 11x.5.2. Подготовить или описать текстуру:

единая текстура, где:

участок A — белая плитка с красным иероглифом, выровненным по центру;

участок B — золото (можно с лёгким шумом/градиентом для реализма);

важно:

достаточное разрешение (например, 512×512 или 1024×1024, без пикселизации);

иероглиф — не “мыльный”.

[ ] 11x.5.3. Прописать в материале:

лицевой грани UV‑координаты → участок A;

боковым и задним граням → участок B;

следить, чтобы:

иероглиф не обрезался;

не растягивался по диагонали;

не зеркалился.

[ ] 11x.5.4. Проверить куб:

один куб в тестовой сцене;

камеру поднести близко;

убедиться, что:

лицевая плитка читается идеально;

золото выглядит целостно по всем небелым граням.

11x.6. PBR‑материалы: золото и белая керамика

Цель: реализовать реалистичный материал, а не “плоскую заливку”.

[ ] 11x.6.1. Материал белой лицевой грани:

базовый цвет: чуть тёплый белый (слегка кремовый, а не чистый #FFFFFF);

лёгкий shininess:

roughness маленький, но не нулевой;

metalness ближе к 0 (керамика/фарфор, не металл);

опционально:

тонкая карта отражений или AO;

микрошум на roughness для более живого блика.

[ ] 11x.6.2. Материал золота:

базовый цвет — насыщенный жёлто‑золотой;

metalness высокий (~0.8–1.0);

roughness средний или чуть ниже:

не зеркало (это будет “пластилин”), но и не матовая краска;

хорошо реагирует на environment map (отражения окружающего мира);

можно использовать отдельную золото‑текстуру:

с лёгкими вариациями яркости/оттенка;

чтобы не было ощущения “однотонной пластмассы”.

[ ] 11x.6.3. Убедиться, что:

материалы раздельные (не один и тот же для всех граней);

при изменении света золотые грани дают красивые спекулярные блики;

белые плитки не “горят” (не пересвечиваются до клиппинга).

11x.7. Внутренняя поверхность башни и зазоры

Цель: создать ощущение “полой башни”, как в референсе.

[ ] 11x.7.1. Внутренняя стенка:

отдельный цилиндр радиусом чуть меньше, чем радиус кубиков;

материал:

золотой, но чуть менее зеркальный, чем боковые грани кубиков;

без текстуры или с лёгкой шумихой.

[ ] 11x.7.2. Зазоры между кубами:

по окружности → небольшой gap (gapAngle или gapWidth);

по вертикали → небольшой verticalGap:

чтобы между рядами была тонкая тень/щель и кубы не слипались в “монолит”.

[ ] 11x.7.3. Проверить, что:

через зазоры видна внутренняя золотая стенка;

нет пересечений:

кубы не врезаются внутрь цилиндра;

не пересекаются между собой.

11x.8. Свет: постановка “студийного” освещения

Цель: чтобы башня выглядела как предмет в студии product‑фото.

[ ] 11x.8.1. Сцена освещения:

Ambient/Environment light:

мягкий общий свет, чтобы не было полностью чёрных теней;

Key light (главный источник):

направленный свет, имитирующий студийный прожектор;

слегка сбоку и сверху;

тёплый оттенок.

Rim light (контурный):

слабый источник позади башни или сбоку;

подчёркивает границы силуэта.

[ ] 11x.8.2. HDRI‑окружение:

использовать environment map:

для отражений на золотых гранях;

не обязательно видимую фоном (фон может быть просто чёрным);

подобрать карту, которая даёт интересные блики без грязного цвета.

[ ] 11x.8.3. Тени:

включить тени для ключевого света:

башня отбрасывает тень на пол;

кубики отбрасывают тени на внутреннюю стенку и друг на друга;

настроить:

разрешение shadow map;

bias (чтобы не было “лесенок” и дыр).

[ ] 11x.8.4. Пройтись по сцене глазами:

при вращении башни/камеры (даже если это временная отладочная орбита) отражения должны:

“играть” на гранях;

но не превращаться в сплошной наркоманский калейдоскоп.

11x.9. Пол и отражение

Цель: глянцевый чёрный пол с красивым отражением башни, как в референсе.

[ ] 11x.9.1. Геометрия пола:

плоский диск или квадрат под башней;

чуть больше радиуса башни.

[ ] 11x.9.2. Материал пола:

почти чёрный, но не идеально:

чтобы можно было увидеть слабое отражение;

средний metalness, низкий roughness;

пол ловит отражения environment map.

[ ] 11x.9.3. Отражение башни:

вариант A: “фейковое” отражение:

дублировать башню вниз, инвертируя по оси Y, с постепенным Fade по альфе;

вариант B: planar reflection (если захочешь заморочиться);

важно:

не переборщить с яркостью (зеркало пола не должно отвлекать от башни).

11x.10. Пост‑обработка и финальный “кинематограф”

Цель: аккуратно добавить “дорогой” вид: bloom, лёгкая виньетка и т.п.

[ ] 11x.10.1. Bloom:

очень аккуратный:

чтобы золотые и белые блики чуть мягче светились;

но не превращались в засвеченный ад.

[ ] 11x.10.2. Цветокор:

лёгкий контраст;

можно чуть подсогреть общую картинку (тёплый gold + легкая холодная тень → приятно смотрится).

[ ] 11x.10.3. Виньетка:

слабая затемняющая рамка по краям, фокусируя взгляд на башне.

[ ] 11x.10.4. Anti‑aliasing:

убедиться, что:

используется MSAA/WebGL2‑подход или post‑AA (FXAA/SMAA);

на гранях кубиков нет зубцов.

11x.11. Тестовые ракурсы и контроль качества

Цель: гарантировать, что башня выглядит круто во всех разумных ситуациях.

[ ] 11x.11.1. Сделать несколько контрольных ракурсов:

классический референсный вид (как в рекламном видео);

чуть ближе (полукадр верхней части);

общая сцена с низом и отражением.

[ ] 11x.11.2. Для этих ракурсов сделать скриншоты:

сохранить как ref_view_01.png, ref_view_02.png и т.п.

Использовать как “визуальные тесты”:

при дальнейших правках рендера сравнивать, чтобы не ухудшать картинку.

[ ] 11x.11.3. Визуальные инварианты:

кубы никогда не пересекаются визуально;

зазоры читаются, но не режут глаз;

иероглиф всегда в центре белой плитки, без смещения;

золото выглядит как металл, а не как жёлтый пластик;

при любом масштабировании окна башня красиво кадрируется.

11x.12. Связь с 3d_helper_system и дальнейшими этапами

[ ] 11x.12.1. Для визуальных аспектов создать “лабоработорию визуала”:

отдельная сцена/режим, где:

башня загружается в фиксированную конфигурацию;

можно:

переключать разные наборы параметров (presets света/материалов);

делать автоматический рендер скриншотов.

[ ] 11x.12.2. Зафиксировать в документации:

какую комбинацию параметров считать “эталонной” (камера, FOV, свет, материалы);

какие менять нельзя (или только очень осознанно).

[ ] 11x.12.3. Подготовить всё так, чтобы:

Этап 12 (анимация разрушения) уже работал на этой красивой картинке;

любые частицы/обломки наследовали материалы кубиков, чтобы не выпадали из стиля.

---

Этап 11y. Визуальный Overkill: золото, свет, камера
11y.0. Цели этапа

Довести материалы (золото + белая плитка) до состояния “дорогой рекламный рендер”:

золото светлое, металлическое, блестящее, с богатой игрой отражений;

белая лицевая грань — чистая, чуть глянцевая керамика с чётким иероглифом.

Поставить освещение уровня студийной предметной съёмки:

несколько источников света с понятной ролями (key, fill, rim);

HDRI‑окружение с красивыми отражениями;

мягкие тени без шумов и лесенок.

Перестроить камеру и управление:

комфортный игровой ракурс по умолчанию (как в референсе, виден верх и низ башни);

удобная свободная орбитальная камера для осмотра (мышь/колесо, ограничения, сглаживание);

быстрые пресеты (переключение подготовленных ракурсов).

Закрепить всё в виде качественного рендер‑пайплайна:

правильная гамма, тон‑мэппинг, post‑effects;

возможность включать/выключать “ультра‑режим” качества;

набор контрольных скриншотов, по которым можно проверять, что мы не деградировали.

11y.1. Проверка и настройка цвет/гамма пайплайна

Цель: убедиться, что всё, что мы делаем с материалами и светом, не убивается неправильной гаммой.

[ ] 11y.1.1. Проверить, что:

рендерер использует sRGB для цветового пространства:

включена корректная кодировка вывода;

color‑текстуры помечены как sRGB.

линейные значения освещения и PBR рассчитываются в линейном пространстве.

[ ] 11y.1.2. Настроить тон‑мэппинг и экспозицию:

выбрать адекватный оператор (Reinhard / ACES / другой);

подобрать экспозицию так, чтобы:

блики на золоте яркие, но не клипуются в “белое пятно”;

тени остаются читаемыми (не проваливаются в чёрное).

[ ] 11y.1.3. Сделать маленький тест‑сценарий:

один золотой куб и один белый куб над чёрным полом;

один свет;

несколько значений экспозиции;

визуально выбрать “золотую середину” и зафиксировать её как дефолт.

11y.2. Точная настройка материалов плитки
11y.2.1. Белая лицевая грань (керамика/фарфор)

[ ] 11y.2.1.1. Базовый цвет:

использовать слегка тёплый белый, не чистый #FFFFFF;

лёгкий оттенок в сторону кремового, чтобы не было “монитора”.

[ ] 11y.2.1.2. PBR‑параметры:

metalness ≈ 0.0–0.1 (керамика не металл);

roughness ≈ 0.15–0.35:

чтобы был аккуратный блеск, но не зеркало.

[ ] 11y.2.1.3. Текстура:

скорректировать карту белой плитки:

добавить микро‑шум / лёгкую неоднородность;

но не превращать в грязь — плитка должна оставаться “чистой”.

[ ] 11y.2.1.4. Проверка:

крупный план одной плитки:

иероглиф читается чётко;

блики плавно движутся по поверхности при вращении света/камеры.

11y.2.2. Золотые грани

[ ] 11y.2.2.1. Подбор базового цвета:

начать с яркого жёлто‑золотого:

H ≈ жёлтый, S высокий, V высокий;

поэкспериментировать с несколькими вариациями и зафиксировать одну “эталонную” в конфиге.

[ ] 11y.2.2.2. PBR‑параметры:

metalness ≈ 1.0 (почти чистый металл);

roughness ≈ 0.2–0.35:

ниже → слишком зеркально, выше → слишком матово.

[ ] 11y.2.2.3. Текстуры:

при желании — ввести лёгкую gold‑texture:

вариации яркости/цвета на уровне 2–5% от базового;

микрошум, полосочки и т.п. для “жизни”, но очень аккуратно.

[ ] 11y.2.2.4. Спекуляр и отражения:

убедиться, что envMap реально сказывается на золоте:

вращаем башню — видим, как отражения скользят по граням;

есть чёткие блики на фасках и мягкие отражения на плоскостях.

11y.3. HDRI‑окружение и студийный свет
11y.3.1. HDRI / environment map

[ ] 11y.3.1.1. Выбрать HDRI окружение:

светлое, с несколькими яркими источниками (окна, студийные панели);

без слишком яркого мусора/цветных пятен (чтобы отражения были “дорогими”, а не кислотными).

[ ] 11y.3.1.2. Настроить envMapIntensity:

для золота — чуть выше (чтобы отражения были богаче);

для белой плитки — умеренно, чтобы не перебивать сам цвет.

[ ] 11y.3.1.3. Сделать тест:

один золотой куб в центре;

вращать камеру вокруг;

оценить, как играют отражения;

при необходимости скорректировать интенсивность и гамму HDRI.

11y.3.2. “Студийный” свет: key / fill / rim

[ ] 11y.3.2.1. Key‑light (главный):

направленный свет (spot/directional) или area;

позиция: слегка сверху и спереди/сбоку;

цвет: чуть тёплый (например, 5000–6000K условно);

интенсивность:

достаточно высокая, чтобы сформировать яркие блики и читаемые тени.

[ ] 11y.3.2.2. Fill‑light (заполняющий):

более слабый мягкий источник;

позиция со стороны теней;

цвет ближе к нейтральному/слегка холодному;

задача — убить “чёрную дыру” в тенях, оставить детали.

[ ] 11y.3.2.3. Rim‑light (контровой):

источник позади башни или сверху сзади;

слабый, но дающий обводку по краю башни;

помогает отделить башню от фона.

[ ] 11y.3.2.4. Интеграция с HDRI:

сбалансировать, чтобы:

HDRI давал общую “атмосферу” и отражения;

key/fill/rim отвечали за акценты и скульптурность формы.

11y.4. Тени: качество и мягкость

[ ] 11y.4.1. Включить тени для главного света:

башня и кубики отбрасывают тени на пол и внутреннюю поверхность.

[ ] 11y.4.2. Настроить параметры:

достаточное разрешение shadow map (чтобы не было пиксельной лесенки);

shadowBias и аналогичные параметры:

чтобы убрать self‑shadowing артефакты и перескакивание;

при возможности — использовать soft‑shadows / PCF.

[ ] 11y.4.3. Проверить:

на средних и близких дистанциях:

тени от кубиков на других кубиках читаются;

нет грязи в местах контакта.

11y.5. Камера: UX, ракурсы, управление
11y.5.1. Игровой ракурс по умолчанию

[ ] 11y.5.1.1. Определить “эталонный” игровой кадр:

башня целиком в кадре:

виден верхний край;

виден нижний край и отражение на полу;

камера чуть выше середины, смотрит немного вниз;

башня занимает ~60–70% высоты кадра (без огромных пустых полей).

[ ] 11y.5.1.2. Зафиксировать этот ракурс в конфиге:

позиция камеры;

точка, на которую она смотрит;

FOV.

11y.5.2. Орбитальная камера для осмотра

[ ] 11y.5.2.1. Реализовать Orbit‑камеру (или эквивалент) для режима инспекции:

ЛКМ (drag) — вращение вокруг башни;

СКМ (drag) или Shift+ЛКМ — панорамирование (медленное смещение);

колесо — zoom (изменение расстояния).

[ ] 11y.5.2.2. Добавить ограничения:

минимальная и максимальная дистанция до центра башни;

ограничение вертикального угла:

чтобы камера не уходила строго снизу/сверху без нужды;

запрет на прохождение камеры “внутрь” башни или под пол.

[ ] 11y.5.2.3. Сглаживание:

добавить damping:

плавное затухание движения;

отсутствие рывков при резких остановках мыши;

чувствительность должна быть настроена так, чтобы:

небольшие движения мыши → аккуратный поворот;

быстрые махи → быстрый разворот, но без нервоза.

11y.5.3. Переключение режимов камеры

[ ] 11y.5.3.1. Минимум два режима:

Game View — фиксированный/почти фиксированный игровой ракурс;

Inspect View — свободная орбита.

[ ] 11y.5.3.2. Сделать переключатель:

клавиша (например, C) или кнопка UI;

плавный переход между текущей позицией и целевым ракурсом (lerp за 0.3–0.6 сек), чтобы не “телепортировать” камеру.

[ ] 11y.5.3.3. В Game View:

блокировать лишний input (например, отключить панорамирование);

allowed:

небольшое вращение вокруг оси башни для “живости”;

но с жёсткими ограничениями.

11y.6. Допиливание геометрии: фаски и нормали (если ещё не доведено)

[ ] 11y.6.1. Убедиться, что кубики имеют:

геометрический bevel (скошенные рёбра) или корректную normal map;

нормали:

сглаженные на фасках;

ровные на плоскостях.

[ ] 11y.6.2. Проверка крупным планом:

на стыке двух кубов видна тонкая тень;

на фаске кубика плавно меняется яркость блика по мере движения камеры.

11y.7. Настройки качества: Ultra / Medium / Low

Цель: чтобы можно было включить “ультра‑качество” для красоты и урезать для слабых машин.

[ ] 11y.7.1. Ввести уровни качества:

Ultra:

максимальное разрешение shadow map;

HDRI высокого разрешения;

активный bloom/AA;

много сегментов фаски и ровная геометрия.

Medium:

более низкое качество теней;

простой AA;

тот же материал, но меньше сегментов.

Low:

тени отключены или сильно упрощены;

без bloom;

упрощённый материал (без нормал карт).

[ ] 11y.7.2. Добавить переключатель качества:

через config или UI;

так, чтобы легко было переключить и сравнить (для разработки можно держать Ultra).

11y.8. Визуальные отладочные режимы (debug‑view)

[ ] 11y.8.1. Режим проверки материалов:

возможность переключить башню:

в matcap‑режим (проверка нормалей);

в режим, где различным материалам назначены простые цвета;

чтобы убедиться, что лицевая грань всегда правильно отрисована.

[ ] 11y.8.2. Режим проверки освещения:

отключение envMap → только лампы;

отключение ламп → только envMap;

видны ли артефакты в тенях, есть ли паразитные засветки.

[ ] 11y.8.3. Быстрая перезагрузка материала/света:

хоткей или кнопка “Reset lighting/materials to defaults”.

11y.9. Финальный визуальный QA

[ ] 11y.9.1. Сделать набор контрольных скриншотов:

view_game_01.png — игровой ракурс (как в рекламе);

view_inspect_closeup_01.png — крупный план верхней части башни;

view_inspect_bottom_01.png — низ + отражение.

[ ] 11y.9.2. Критерии “готово”:

золото светлое, с чёткими, но не слепящими бликами;

белая плитка читабельна, иероглиф чёткий;

зазоры между кубами заметны, но не дикие;

тени мягкие, без лесенок и дерганья;

при вращении камеры в Inspect‑режиме:

отражения на гранях прекрасно играют;

никаких странных провалов в чёрный.

[ ] 11y.9.3. Если что‑то не устраивает:

фиксировать в TODO/BUGS конкретно:

“золото всё ещё выглядит слишком тёмным при таком‑то ракурсе”;

“камера на Ultra‑качестве даёт тряску при zoom‑in”;

повторять локальные подпункты (например, 11y.2 или 11y.3) до получения эффекта “в восторге”.

11y.10. Подготовка к Этапу 12 (анимации)

[ ] 11y.10.1. Зафиксировать параметры:

материалы и свет → отдельный конфиг, не трогать без веской причины;

камера:

игровой ракурс, который будет использоваться как база для анимаций.

[ ] 11y.10.2. Убедиться, что:

все эффекты (золото, отражения, свет) выглядят стабильно при движении камеры;

ничего не “ломает” FPS настолько, чтобы анимации разрушения стали невозможными.

---

## Этап 12. Анимация разрушения этажей и спецэффекты

### 12.1. Связь с доменными событиями очистки

[ ] 12.1.1. В Application‑слое на событие `LinesCleared` запускать визуальную анимацию:

* создать структуру `ClearingAnimationState`, которая хранит:

  * какие уровни очищаются;
  * время начала/длительность анимации;
  * ссылки на соответствующие блоки/инстансы.

### 12.2. Анимация разлёта кубиков

[ ] 12.2.1. Реализовать систему “обломков”:

* для блоков очищаемого слоя:

  * временно создать отдельные инстансы/меши;
  * задать каждому случайный вектор скорости (наружу башни, немного вверх/в сторону);
  * задать случайную угловую скорость (вращение).

[ ] 12.2.2. На каждом кадре:

* обновлять позицию и ориентацию обломков по `deltaTime`;
* постепенно уменьшать их прозрачность (`opacity`) до 0;
* по окончании lifetime — удалять из сцены.

### 12.3. Синхронизация с логикой очистки

[ ] 12.3.1. Пока идёт анимация очистки:

* доменное состояние находится в статусе `clearing`;
* падение новых фигур приостанавливается или замедляется (в зависимости от задумки).

[ ] 12.3.2. По окончании анимации:

* Application‑слой уведомляет домен (вызывает функцию окончания очистки);
* домен физически удаляет слои и роняет верхние блоки вниз;
* статус возвращается в `running`, и игра продолжается.

**Критерий завершения Этапа 12:**
При уничтожении полного кольца башни игрок видит зрелищное разрушение с разлетающимися блоками, а логика удаления и падения слоёв работает корректно.

---

## Этап 13. Производительность, оптимизация и полировка

### 13.1. Оптимизация рендера

[ ] 13.1.1. Убедиться, что:

* используется instancing для большого числа блоков;
* не создаются/не удаляются Mesh‑объекты каждый кадр без необходимости.

[ ] 13.1.2. При необходимости:

* ввести LOD‑механику (для отдалённых объектов упрощать геометрию);
* оптимизировать материалы (минимум текстур/шейдеров).

### 13.2. Оптимизация домена

[ ] 13.2.1. Проверить горячие места (обновление доски, поиск полных слоёв):

* заменить очевидные неоптимальные операции (например, полные копии массивов) на более простые.

### 13.3. UX‑полировка

[ ] 13.3.1. Добавить небольшие эффекты:

* лёгкая анимация камеры при разрушении;
* мерцание или подсветка активной фигуры;
* звуки (позже, отдельным мини‑этапом).

[ ] 13.3.2. Настроить чувствительность управления:

* задержка повторения движения;
* отзывчивость soft/hard drop.

---

## Этап 14. Сценарии, похожие на рекламный ролик

### 14.1. Предзаполненные конфигурации башни

[ ] 14.1.1. Добавить возможность загружать стартовые конфигурации поля (уровни):

* через JSON или встроенные пресеты.

[ ] 14.1.2. Создать пресет, имитирующий рекламный ролик:

* почти полностью заполненная башня;
* одна вертикальная зигзагообразная “шахта” для идеального хода.

### 14.2. Режим демонстрации (автоигра)

[ ] 14.2.1. Реализовать простой “скрипт” действий:

* последовательность команд, которые ставят нужную фигуру в нужное место;
* запуск автоматического демо без участия игрока.

**Критерий завершения Этапа 14:**
Можно запустить игру в режиме, визуально напоминающем рекламу: красиво ломается башня, есть “идеальный” ход.

---

## Этап 15. Финальная зачистка и документация

[ ] 15.1. Пройтись по коду:

* убрать мёртвый/комментированный код;
* унифицировать стиль в соответствии с `convention.txt`.

[ ] 15.2. Обновить/написать README:

* описание игры;
* как запускать;
* краткое описание архитектуры (ссылки на `architecture.txt` и `plan.txt`).

[ ] 15.3. Проверить, что:

* все тесты проходят;
* проект собирается без ошибок;
* игра запускается и работает стабильно.

---

На этом план заканчивается.
Дальше можно брать любой подэтап (например, `2.2.1` или `7.2.3`), цитировать его в запросе к нейросети и требовать **строгого следования** `architecture.txt` + `convention.txt` при реализации именно этого фрагмента.
