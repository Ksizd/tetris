
---

## 15.1. Радиусы и зал вокруг камеры

### 15.1.0. Жёсткие инварианты (НЕ нарушать)

1. **Камеру не трогаем.**

   * Запрещено менять:

     * формулы позиционирования камеры;
     * дистанцию / FOV / высоту / авто‑орбиту;
     * ввод пользователя.
   * Разрешено **считать** из уже настроенной камеры её реальный радиус орбиты и использовать это в расчёте зала.

2. **Башня и геймплей не меняются.**

   * Радиус башни (tower radius) и координаты world‑origin — читаем из существующих утилит (`towerBounds`, `boardToWorldMapper` и т.п.), не трогаем логику.
   * Разрушение, тетримино, footprint — никак не модифицируем в этом шаге (кроме **чтения** радиуса и высоты).

3. **Зал всегда снаружи камеры.**

   * В любой момент (игровой режим, visualDebug):

     * внутренняя поверхность зала (стены/колонны/примитивы) **никогда** не пересекает луч из камеры к центру башни;
     * камера *всегда* находится строго внутри пустого пространства зала.

4. **Ни одного «магического» числа без конфигурации.**

   * Все зазоры и толщины (safety margin, толщина стен) — выносятся в конфиг `HallLayoutConfig`, а не хардкодятся по месту.

---

### 15.1.1. Найти и зафиксировать источники радиусов

**Цель:** понять, откуда берутся все ключевые радиусы, и завести для них единый «слой истинности».

1. **Tower radius / габариты башни.**

   * Посмотреть существующий код (имена могут чуть отличаться, но идея такая):

     * `src/render/towerBounds.ts` – функции типа `getTowerOuterRadius` / `computeTowerBounds`.
     * `src/render/boardConfig.ts` – там есть `towerRadius`, `cellSize`, `towerInnerRadius`, etc.
   * Зафиксировать:

     * `R_tower_outer` — минимальный радиус, который гарантированно **вмещает все кубы башни** (включая внешний bevel).
     * `R_footprint` — радиус footprint‑сетки (может быть чуть меньше, пригодится в следующих этапах).

2. **Радиус орбиты камеры.**

   * Визуальная камера создаётся примерно в:

     * `src/render/cameraSetup.ts` и/или `src/render/cameraMotion.ts` / `sceneRenderer.ts`.
   * Нужно **после** полной инициализации камеры (когда уже выставлены позиция / target) вычислить:

     * `towerOriginWorld` — центр башни в world‑координатах (скорее всего `(0, 0, 0)` либо берётся из `boardToWorldMapper`).

     * Вектор `delta = camera.position - towerOriginWorld`.

     * Проекция на XZ‑плоскость: `deltaXZ = new Vector2(delta.x, delta.z)`.

     * `R_camera = deltaXZ.length()`.

   > Это важный момент: **не** повторяем формулы из cameraSetup, а берём реальный результат — это убивает расхождения и не требует править камеру.

3. **Текущий радиус зала / платформы.**

   * Найти модуль, где сейчас создаётся зал:

     * ищем по проекту `hallShell`, `goldenHall`, `createHall`, `hallCylinder` и т.п.
     * пусть условно это `src/render/goldenHall.ts` (название не критично, но в плане так будем называть).
   * Выписать:

     * на каком радиусе сейчас строится цилиндр/оболочка (`R_hall_previous`);
     * на каком радиусе / диаметре строится постамент (`R_platform_previous`).

---

### 15.1.2. Вводим HallLayoutConfig и чистую функцию вычисления радиусов

**Цель:** один центр принятия решения по радиусам, завязанный на реальные `R_tower_outer` и `R_camera`.

1. **Создать новый модуль, например:**

   * `src/render/hallLayout.ts`.

2. **Добавить типы:**

   ```ts
   export interface HallLayoutConfig {
     /** минимальный зазор от камеры до внутренней стены зала */
     cameraInnerMargin: number;   // в world‑юнитах
     /** минимальный зазор от башни до внутренней стены зала */
     towerInnerMargin: number;
     /** толщина стены зала по радиусу */
     shellThickness: number;
     /** зазор между внутренней стеной зала и внешним радиусом платформы (чтобы стена не прорезала пол) */
     platformWallGap: number;
   }

   export interface HallLayoutRadii {
     towerOuterRadius: number;
     cameraOrbitRadius: number;
     hallInnerRadius: number;
     hallOuterRadius: number;
     platformOuterRadius: number;
   }
   ```

   * Реальные числа (по умолчанию) можно будет взять из уже существующих настроек (например, 0.5–1.5 cellSize), но они должны быть **параметрами**, а не захардкожены в геометрии.

3. **Чистая функция `computeHallLayout`:**

   ```ts
   export function computeHallLayout(
     params: {
       towerOuterRadius: number;
       cameraOrbitRadius: number;
     },
     cfg: HallLayoutConfig
   ): HallLayoutRadii { ... }
   ```

   Внутри:

   * Сначала вычисляем **минимально допустимый радиус** внутренней стены:

     ```ts
     const minByCamera = params.cameraOrbitRadius + cfg.cameraInnerMargin;
     const minByTower  = params.towerOuterRadius + cfg.towerInnerMargin;
     const hallInnerRadius = Math.max(minByCamera, minByTower);
     ```

   * Внешний радиус стены:

     ```ts
     const hallOuterRadius = hallInnerRadius + cfg.shellThickness;
     ```

   * Радиус платформы:

     * платформа должна быть *чуть меньше* внутреннего радиуса стены, чтобы не влезать в геометрию стены,
     * но *не меньше* башни.

     ```ts
     const platformOuterRadius =
       hallInnerRadius - cfg.platformWallGap;
     // safety: платформа всегда >= башни
     const safePlatformOuterRadius =
       Math.max(platformOuterRadius, params.towerOuterRadius + 0.01);
     ```

   * Вернуть все радиусы в одном объекте.

4. **Отдельный helper для вычисления `HallLayoutConfig` по текущим cellSize.**

   * В этом же файле (или в `renderConfig.ts`) можно завести `DEFAULT_HALL_LAYOUT_CONFIG`, где:

     * `cameraInnerMargin` ≈ одна ширина башенного куба;
     * `towerInnerMargin` — 0.5–1 ширины куба;
     * `shellThickness` — 1–2 ширины куба (пока просто параметр толщины, чисто про геометрию);
     * `platformWallGap` — узкий зазор (0.2–0.5 куба).

---

### 15.1.3. Привязка HallLayout к реальной сцене

**Цель:** чтобы реальная камера и реальная башня передавали свои радиусы в `computeHallLayout`.

1. **Где это делать.**

   * Найти место, где создаётся вся сцена:

     * `src/render/renderer.ts` или `src/render/sceneRenderer.ts` — там, где создаются:

       * камера,
       * tower instanced mesh,
       * золотой зал (из 14‑го этапа),
       * освещение.
   * Мы должны вызвать `computeHallLayout` **после** того, как:

     * башня уже сконфигурирована (есть `towerOuterRadius`),
     * камера уже выставлена на свою орбиту (есть `camera.position`).

2. **Получаем входные значения:**

   * `towerOuterRadius` взять из:

     * либо из `BoardRenderConfig` (если там есть поле вроде `tower.radiusWorld`),
     * либо через вызов функции типа `getTowerOuterRadius(dimensions, config)`.
   * `cameraOrbitRadius` — как выше:

     * берём `camera.position`, вычитаем центр башни,
     * берём длину проекции на XZ‑плоскость.

3. **Вычисляем layout:**

   ```ts
   const hallLayout = computeHallLayout(
     {
       towerOuterRadius,
       cameraOrbitRadius,
     },
     DEFAULT_HALL_LAYOUT_CONFIG
   );
   ```

4. **Сохраняем layout в Renderer / SceneRenderer.**

   * В объекте `SceneRenderer` добавить поле `hallLayout: HallLayoutRadii`.
   * При создании zала/платформы/footprint — использовать не свои локальные радиусы, а `renderer.hallLayout`.

---

### 15.1.4. Перепривязка зала и платформы к новым радиусам

**Цель:** заставить текущие «золотые трубы» и «таблетку» подчиняться `hallLayout`, не меняя пока их визуальный дизайн (это 15.2+).

1. **Hall shell / стены.**

   * В модуле, где создаётся цилиндр зала:

     * убрать любые хардкоды типа `const hallRadius = towerRadius * 2.4`.
     * заменить на использование:

       * внутренний радиус стены = `hallLayout.hallInnerRadius`,
       * внешний / толщина = `hallLayout.hallOuterRadius` (или построение цилиндра радиусом `hallOuterRadius` с вырезом).
   * Важно: если сейчас зал строится как одна толстая труба с прозрачностью — всё равно радиус берётся из layout.

2. **Постамент / платформа.**

   * Там, где создаётся «золотая таблетка»:

     * внешний радиус = `hallLayout.platformOuterRadius`.
     * если сейчас есть отдельные кольца/ступени — на этом этапе можно им всем задать одинаковый внешний радиус, а структуру ступеней уже чинить в 15.2.

3. **Проверка на пересечения.**

   * В момент создания зала можно сделать простую runtime‑assert (в dev режиме / non‑prod build):

     ```ts
     console.assert(
       hallLayout.hallInnerRadius >
         hallLayout.cameraOrbitRadius + 0.001,
       'Hall inner radius must be outside camera orbit'
     );
     console.assert(
       hallLayout.hallInnerRadius >
         hallLayout.towerOuterRadius + 0.001,
       'Hall must not intersect tower.'
     );
     ```

   * Если что‑то пойдёт не так — узнаем сразу в консоли, а не по скриншотам через неделю.

---

### 15.1.5. Реакция на изменения камеры в visualDebug

**Цель:** в debug‑режиме камера может двигаться слайдерами (towerRadius, cameraDistance и т.д.), зал обязан *перестраиваться* и продолжать обрамлять камеру.

1. **Где слушать изменения.**

   * В `src/app/visualDebugMode.ts` уже есть wiring для:

     * изменения FOV,
     * `camera.distance`, `camera.height`,
     * `tower radius` слайдера.
   * Нужно:

     * после каждого изменения, которое влияет на позицию камеры или towerRadius,
     * заново вызвать тот же код, что и при инициализации:

       1. переустановить позицию камеры (уже делается);
       2. пересчитать `cameraOrbitRadius`;
       3. пересчитать `hallLayout` через `computeHallLayout`;
       4. обновить геометрию зала и платформы.

2. **Обновление геометрии.**

   * На этом шаге не надо строить «новый зал» каждый кадр. Достаточно:

     * либо пересоздать CylinderGeometry / Mesh (один раз при изменении),
     * либо, если там сложная геометрия, масштабировать mesh по XZ в соответствии с отношением нового радиуса к старому.
   * Предпочтительнее всё‑таки **перестраивать геометрию** по радиусу (`createHallGeometry(hallLayout)`), чтобы последующие этапы с узорами не страдали.

3. **Синхронизация с footprint.**

   * В этом подэтапе **не** трогаем визуальный вид footprint’а, но:

     * если towerRadius меняется в debug (например, для визуального теста), `towerOuterRadius` тоже изменится,
     * значит новый layout и платформа должны корректно вписаться,
     * footprint пока остаётся прежним, но его радиус должен быть ≤ `hallLayout.platformOuterRadius`.

---

### 15.1.6. Debug‑оверлеи радиусов

**Цель:** чтобы ты мог одним взглядом увидеть, что зал, камера и башня живут в правильных кружочках.

1. **Новый debug‑режим: Hall Radii Overlay.**

   * В `src/render/debugOverlays.ts` (или аналогичном модуле) добавить helper, например:

     * `createHallRadiiOverlay(scene, hallLayout, towerOriginWorld)`.
   * Он создаёт три тонких кольцевых/линейных mesh’а или LineLoop’а в плоскости XZ (на высоте пола + небольшая дельта):

     * круг `R_tower_outer` (цвет, например, зелёный),
     * круг `R_camera` (голубой),
     * круг `R_hall_inner` (жёлтый).

2. **Подключение к visualDebug.**

   * В `visualDebugControls.ts` / `visualDebugMode.ts` добавить чекбокс:

     * `[ ] Show hall radii`.
   * При включении:

     * создаём/показываем overlay,
     * при пересчёте layout обновляем радиусы этих окружностей.

3. **Acceptance глазами:**

   * При включенном оверлее:

     * **зелёный круг** (башня) всегда самый внутренний,
     * **голубой** (камера) — между башней и внутренней стеной зала,
     * **жёлтый** (стена) — всегда снаружи голубого и зелёного.

---

### 15.1.7. Тесты (минимальный набор, но жёсткие)

Добавить тесты, которые гарантируют, что Codex не сможет «лениво» схалтурить.

1. **`hallLayout.test.ts` (новый файл в `src/render/__tests__`).**

   * Тест 1: базовый случай.

     ```ts
     const cfg: HallLayoutConfig = {
       cameraInnerMargin: 1,
       towerInnerMargin: 0.5,
       shellThickness: 0.5,
       platformWallGap: 0.25,
     };

     const res = computeHallLayout(
       { towerOuterRadius: 5, cameraOrbitRadius: 7 },
       cfg
     );

     expect(res.hallInnerRadius).toBeGreaterThan(7 + 0.999); // camera margin
     expect(res.hallInnerRadius).toBeGreaterThan(5 + 0.499); // tower margin
     expect(res.hallOuterRadius).toBe(res.hallInnerRadius + 0.5);
     expect(res.platformOuterRadius).toBeGreaterThanOrEqual(5 + 0.01);
     expect(res.platformOuterRadius).toBeLessThan(res.hallInnerRadius);
     ```

   * Тест 2: камера ближе, чем башня.

     * Проверяет, что выбирается max(tower + margin, camera + margin).

2. **`cameraHallIntegration.test.ts`.**

   * Использовать уже существующие helper’ы создания камеры/конфига (как в `cameraSetup.test.ts`).
   * Смоделировать типичную сцену, построить камеру, затем:

     * вычислить `R_camera` за счёт `camera.position`,
     * вызвать `computeHallLayout`,
     * проверить инварианты:

       * `hallInnerRadius > R_camera + cameraInnerMargin - eps`,
       * `hallInnerRadius > R_tower_outer + towerInnerMargin - eps`.

3. **Не правим существующие тесты камеры/башни.**

   * Если из‑за наших изменений начнут падать тесты, значит мы где‑то залезли в камеру или tower config — это запрещено.

---

### 15.1.8. Визуальные acceptance‑критерии (что ты должен увидеть)

После завершения 15.1 (ещё без новых материалов и красивостей) в **обычном игровом режиме** и в **visualDebug** должно быть так:

1. **Камера всегда внутри зала.**

   * При любой позиции активного тетримино и вращении башни:

     * стены/колонны/оболочка зала **никогда не проходят между камерой и башней**;
     * не бывает случая, где тетримино или часть башни перекрыта стеной при стандартной камере.

2. **Зал и платформа расширены.**

   * Внешняя граница платформы и внутренняя стенка зала теперь заметно дальше от башни:

     * визуально башня стоит не «впритык к стенам», а в центре свободного пространства.
   * Текущий примитивный дизайн (труба + таблетка) останется, но просто **раздвинут** в сторону от камеры и башни.

3. **Hall Radii Overlay (в debug).**

   * При включении нового чекбокса видно три круга:

     * башня — самый внутренний,
     * камера — вокруг башни,
     * зал — ещё дальше.
   * При изменении `tower radius`/`camera distance` в debug:

     * камера движется,
     * hallLayout пересчитывается,
     * все три круга **обновляются** и порядок остаётся тем же.

4. **Ни одного клиппинга / прохождения стен по кадру.**

   * При экстремальных значениях слайдеров в visualDebug (минимальная/максимальная дистанция камеры в разумных пределах) стены не входят в кадр так, чтобы отрезать башню.

---


---

## 15.2. Постамент: геометрия «царской тарелки»

### 15.2.0. Жёсткие инварианты

1. **Ничего не ломаем в геймплее.**

   * Координаты всех кубов башни и логика падения/разрушения **не меняются**.
   * Верх платформы **ровно совпадает** с уровнем нижнего этажа башни (там, где раньше рисовался footprint).

2. **Башня не проваливается и не висит в воздухе.**

   * Нижние кубы башни опираются на платформу, но не пересекаются с ней.
   * Между платформой и «дном» куба допускается зазор ≤ 0.01 world‑юнита (для избежания z‑файтинга).

3. **Все размеры постамента привязаны к `HallLayoutRadii` и boardConfig.**

   * Никаких «2.75» просто так. Только:

     * `hallLayout.platformOuterRadius`,
     * `hallLayout.towerOuterRadius`,
     * `cellSize`, `board.width`.

4. **Ось башни остаётся мировым центром.**

   * Платформа всегда центрирована по тому же origin, что и tower/footprint. Никаких смещений.

---

### 15.2.1. Дизайн постамента в терминах колец и высот

Хотим не «золотую таблетку», а **многослойную тарелку**:

1. **Сечения по радиусу (от центра к стене):**

   * **Ring A — центральный пьедестал под башней**

     * Радиус ≈ `R_baseInner = towerOuterRadius + marginBaseInner`.
     * Чуть приподнят над остальной платформой (на 0.05–0.1 world‑юнита).
     * Поверхность почти матовая, но с мягким reflection (будто золото истёрлось под весом башни).

   * **Ring B — «инкрустация вокруг башни»**

     * Между `R_baseInner` и `R_footprintOuter`.
     * Тонкий по высоте, но с подчёркнутым фаской по краю.
     * Поверхность с **радиальными/секторными** сегментами (для parquet‑узора — позже в 15.2.4/15.3).

   * **Ring C — основной паркетный зал (главный визуал)**

     * От `R_footprintOuter` до `hallLayout.platformOuterRadius`.
     * В несколько концентрических полос (C1, C2, C3) — для разных материалов/паттернов.

2. **Высоты по Y:**

   * `y_floorBase` — абсолютная высота низа постамента.
   * `h_platformCore` — высота «толстой» части (Ring C).
   * `h_ringB` — чуть выше/ниже Core, создавая ступень.
   * `h_ringA` — самая высокая зона (под башней).

3. **Переходы между кольцами:**

   * Между разными по высоте кольцами — **скошенные фаски**, а не вертикальные ступеньки.
   * Это решается геометрией: дополнительный маленький кольцевой сегмент с наклонёнными полигонами.

---

### 15.2.2. Расчёт радиусов и высот (HallLayout → PlatformLayout)

**Новый модуль:** `src/render/platformLayout.ts`

1. **Типы:**

   ```ts
   export interface PlatformLayout {
     baseY: number;              // y-низ платформы
     heightCore: number;         // высота основного кольца
     ringA: { inner: number; outer: number; height: number; };
     ringB: { inner: number; outer: number; height: number; };
     ringC: { inner: number; outer: number; height: number; };
     // возможно, ещё массив generic-колец, но минимум эти три
   }
   ```

2. **Функция `computePlatformLayout(hallLayout, boardRenderConfig, cellSize)`**

   * Входы:

     * `hallLayout.towerOuterRadius` / `hallLayout.platformOuterRadius`
     * `boardRenderConfig` (для радиуса footprint)
     * `cellSize` (толщина куба по Y)

   * Алгоритм:

     * `R_tower = hallLayout.towerOuterRadius`.

     * `R_platformOuter = hallLayout.platformOuterRadius`.

     * Вычислить `R_footprintOuter`:

       * либо взять из существующей `createTowerFootprint`, либо определить как `R_tower + cellSize.x * 0.5` (но **одна формула в одном месте**).

     * Ввести маргины:

       ```ts
       const marginBaseInner   = cellSize.x * 0.2;
       const marginFootprint   = cellSize.x * 0.3; // расстояние от башни до начала footprint-декора
       const marginOuterParquet = cellSize.x * 0.5;
       ```

     * `ringA.inner = 0` (можно чуть побольше, если не хотим дырку);
       `ringA.outer = R_tower + marginBaseInner`.

     * `ringB.inner = ringA.outer`;
       `ringB.outer = R_footprintOuter + marginFootprint`.

     * `ringC.inner = ringB.outer`;
       `ringC.outer = R_platformOuter`.

   * Высоты:

     ```ts
     const hCore = cellSize.y * 0.6;
     const hA    = hCore + cellSize.y * 0.1;     // башня чуть выше
     const hB    = hCore + cellSize.y * 0.05;    // чуть ниже A, чуть выше Core
     ```

   * `baseY` — так, чтобы верх Ring A совпал с базой кубов:

     ```ts
     const cellBottomY = boardToWorldMapper.bottomCellWorldY(); // или cell center - cellSize.y / 2
     const baseY = cellBottomY - hA;
     ```

     Это **обязательное** место выравнивания: верх ringA = `baseY + hA` == `cellBottomY`.

3. **Инвариантные проверки внутри layout‑функции:**

   * `ringA.outer < ringB.inner + eps` и т.д. (если нет — значит маргины выбраны неверно, кидаем ошибку/console.warn).
   * `ringC.outer <= hallLayout.platformOuterRadius + eps`.

---

### 15.2.3. Геометрия постамента: генератор кольцевых мешей

**Новый модуль:** `src/render/goldenPlatformGeometry.ts`

1. **Задача:** из `PlatformLayout` собрать один `THREE.BufferGeometry` или набор геометрий с **группами** для материалов:

   * Группа материала для:

     * Ring A top
     * Ring B top
     * Ring C top (можно для каждой подполосы свой индекс)
     * Внешний боковой цилиндр
     * Фаски между уровнями

2. **Разбиение по сегментам:**

   * Число сегментов по окружности — **равно количеству колонок башни** (`boardDimensions.width`), чтобы:

     * стыки сегментов **совпадали** с границами ячеек.
   * Для визуальных узоров можно потом делить каждый сегмент на 2–3 под‑сегмента по углу, но базово — `segments = board.width`.

3. **Алгоритм для одного кольца c высотой:**

   * Для каждого углового сегмента `i`:

     * `theta0 = (i / segments) * 2π`

     * `theta1 = ((i+1) / segments) * 2π`

     * вершины верхнего кольца:

       ```text
       v0 = (inner * cos θ0, yTop, inner * sin θ0)
       v1 = (outer * cos θ0, yTop, outer * sin θ0)
       v2 = (inner * cos θ1, yTop, inner * sin θ1)
       v3 = (outer * cos θ1, yTop, outer * sin θ1)
       ```

     * Из них составить два треугольника: (v0,v1,v2) и (v2,v1,v3) или с корректным winding.

   * Аналогично генерировать **нижнее кольцо** для боковой поверхности (yBottom = baseY).

   * Для фаски между кольцами:

     * используем intermediate‑радиус и intermediate‑y (линейная интерполяция между высотами кольца A и B).

4. **Материальные группы:**

   * Каждый сегмент Ring A/B/C top получает **отдельный group** с собственным materialIndex (например: 0,1,2).
   * Боковины и фаски могут делить один материалIndex (3–4).

   Это позволит в дальнейшем легко навесить разные PBR‑материалы: матовое золото, глянцевый лак, инкрустации.

5. **Нормали и UV:**

   * Нормали:

     * верхние поверхности — (0,1,0);
     * боковины — направлены по радиусу (из центра).
   * UV‑координаты:

     * пока достаточно полярного маппинга:

       * `u = (theta / 2π)`
       * `v = (radiusNormalized = (r - inner)/(outer - inner))`.
     * Для parquet‑паттерна этого хватит.

6. **Выход функции:**

   ```ts
   export function createGoldenPlatformGeometry(
     layout: PlatformLayout,
     segments: number
   ): THREE.BufferGeometry
   ```

---

### 15.2.4. Интеграция платформы в сцену

**Модуль:** `src/render/sceneRenderer.ts` или `renderer.ts`, плюс новый `goldenPlatform.ts`.

1. **createGoldenPlatform(scene, hallLayout, boardConfig, mapper):**

   * вычислить `platformLayout` (через `computePlatformLayout`);
   * создать `geometry = createGoldenPlatformGeometry(platformLayout, board.width)`;
   * создать материалы (пока можно взять существующее золото и пару вариаций, детально украсим позже);
   * собрать `THREE.Mesh` с MultiMaterial;
   * позиция mesh: `(0, baseY + heightCore/2, 0)` или точная по layout.

2. **Ось вращения и origin то же, что и у башни.**

   * Mesh добавляется в общую группу башни/зала, использующую один центр.

3. **Не пересекаться с footprint.**

   * Footprint будет сверху платформы, поэтому:

     * верх ringA/B/C должны быть **ниже** уровня footprint’а минимум на 0.001;
     * или footprint рисуется чуть выше (`+0.001`).

---

### 15.2.5. Тесты по постаменту

1. **`platformLayout.test.ts`**

   * Проверяем, что:

     * `ringA.outer < ringB.inner < ringC.inner < ringC.outer ≤ platformOuterRadius`;
     * верх ringA == `bottomCubeY` (с точностью до 1e‑3);
     * baseY < все верхние высоты.

2. **`goldenPlatformGeometry.test.ts`**

   * Генерируем геометрию для простых значений (segments = 8):

     * количество вершин > 0;
     * нет NaN;
     * boundingBox покрывает `[−ringC.outer, baseY] .. [ringC.outer, baseY + maxHeight]`.

3. **Интеграционный тест с башней:**

   * Строим платформу + башню для dummy‑конфига:

     * проверяем, что boundingBox нижнего ряда кубов **не заходит** ниже верхней поверхности Ring A более чем на eps.

---

## 15.3. Footprint: «гравировка» и прицел

### 15.3.0. Инварианты

1. **Footprint всегда геометрически совпадает с сеткой первого уровня башни.**

   * Проекция клетки `(col, row = 0)` на пол через `boardToWorldMapper` попадает:

     * в центр соответствующего «квадратика»/«сектора» footprint’а.

2. **Никакого влияния footprint на логику.**

   * Это чисто визуальный слой.

3. **Никакого z‑fighting.**

   * Footprint либо:

     * вырезан/«гравирован» в геометрии платформы (via материал/нормали/цвет),
     * либо рисуется отдельными мешами **выше** платформы на дельту (0.001–0.002).

---

### 15.3.1. Рефакторинг текущего towerFootprint

Сейчас это, по сути, debug‑оверлей.

1. **Файл:** `src/render/towerFootprint.ts`

   * Вытащить из него чистую часть, которая:

     * знает радиус footprint’а,
     * знает количество сегментов = board.width,
     * строит геометрию круговой сетки.

2. **Разделить на два API:**

   * `createTowerFootprintDebug(...)` — старый вид (wireframe, для debug’а).
   * `createTowerFootprintDecor(...)` — новый «боевой» footprint для игры.

3. **Функция для радиуса:**

   ```ts
   export function getFootprintRadius(boardConfig): number;
   ```

   * Используется и layout‑платформы, и декором.

---

### 15.3.2. Новый декоративный footprint: слои

**Дизайн:**
Не просто линии, а **двухслойная гравировка**:

1. **Layer 1 — «кольцевая гравировка» (интеграция с Ring B/A)**

   * Тонкое кольцо шириной ≈ половина толщины клетки:

     * радиус ~ `R_footprint ± cellSize.x * 0.25`.
   * Материал:

     * тёмное золото/бронза, слегка более матовое, чем пол.
   * Вариант реализации:

     * либо отдельный Mesh (тонкий диск) поверх Ring B (чуть выше Y),
     * либо добавление ещё одного материала/группы в геометрию Ring B.

2. **Layer 2 — «клеточная сетка»**

   * Для каждой колонки `col` (0..board.width-1):

     * Секторный «квадрат» на кольце:

       * внутренний радиус: `R_footprint - cellSize.x * 0.5`,
       * внешний: `R_footprint + cellSize.x * 0.5`.
       * углы `θ0, θ1` как у платформы.
     * Возможные формы:

       * либо прямой сектор (4–6 вершин),
       * либо ромб/шестиугольник, направленный к центру.

   * Материал:

     * светящееся, но не ядрёное золото;
     * можно добавить лёгкий эмиссивный градиент к внутренней части.

3. **Layer 3 — «прицел клеток» (опционально, стыкуется с системой проекции фигуры)**

   * См. твой пункт про золотой «прицел».
   * На этом шаге можно только подготовить **геометрию**:

     * маленькие диски/ромбы в центрах клеток первого уровня.
   * Позже (другим этапом) туда будем заливать цвет по тому, куда «целится» фигура.

---

### 15.3.3. Геометрия footprint‑декора

**Новый модуль:** `src/render/footprintDecor.ts`

1. **API:**

   ```ts
   export interface FootprintDecorParams {
     board: BoardDimensions;
     cellSize: number;
     platformLayout: PlatformLayout;
   }

   export function createFootprintDecor(params: FootprintDecorParams): THREE.Group;
   ```

2. **Внутри:**

   * Вычислить `R_footprint = getFootprintRadius(boardConfig)` либо напрямую.
   * Y‑координаты:

     * `yBase = platformLayout.ringB.heightTop + 0.001` (чуть выше Ring B).
   * Построить:

     * Mesh `ringEngraving` (Layer 1):

       * геометрия кольца (как для платформы, но очень узкого),
       * материал `footprintBaseMaterial`.

     * Mesh `cellSectors` (Layer 2):

       * один `BufferGeometry` с `segments = board.width`, 4–6 вершин на сектор,
       * uv: можно повторить полярную схему,
       * материал `footprintCellMaterial` (emissive + map).

     * (Опционально) InstancedMesh `cellCenters` (Layer 3):

       * маленькие цилиндры/квадраты в центрах клеток.

3. **Важно:**

   * geometry и материалы **не должны** перекрывать башню:

     * максимальный внешний радиус Layer 2 < ringC.inner (или <= ringB.outer).

---

### 15.3.4. Интеграция footprint‑декора в сцену

1. **Где подключать:**

   * Там же, где создаётся башня и платформа (`sceneRenderer`):

     * после `createGoldenPlatform(...)`,
     * до создания башни/активного тетримино.

2. **Добавить новый экспорт:**

   * `src/render/index.ts` — `createFootprintDecor`.

3. **Слои/отрисовка:**

   * Footprint попадает в тот же render‑путь, что и платформа (game mode + visualDebug).
   * Не завязан на `debugOverlays`.

4. **Параметр в конфиге:**

   * В `renderConfig.ts` добавить опцию:

     ```ts
     showFootprintDecor: boolean; // default true
     ```

   * В visualDebugControls — чекбокс, чтобы можно было отключить для «чистого» вида.

---

### 15.3.5. Устранение старого debug‑оверлея footprint

1. **Старый wire‑footprint в debugOverlays:**

   * Либо оставить как «DEBUG: raw footprint», но:

     * rename, чтобы не путать с новым декором (`showRawFootprintOverlay`).
   * Либо полностью заменить на более тонкий вид (тонкие линии поверх платформы).

2. **Следить, чтобы не было дублирования:**

   * В обычной игре — только `createFootprintDecor`.
   * В debug‑режиме:

     * опционально добавляется `rawFootprintOverlay` (wireframe + радиусы).

---

### 15.3.6. Тесты по footprint

1. **`footprintGeometry.test.ts`**

   * Для искусственного board.width=8:

     * создать `FootprintDecorParams` с простыми значениями;
     * построить `createFootprintDecor`;
     * проверить:

       * количество дочерних mesh’ей >= 2,
       * boundingSphere радиуса в разумных пределах (`≈ R_footprint`).

2. **`footprintMapping.test.ts`**

   * Прогнать по всем `col` в `board.width`:

     * позиция центра клетки (`boardToWorldMapper`),
     * найти ближайшую вершину footprint‑сектора (или вычислить по формуле),
     * убедиться, что расстояние ≤ 0.01.

3. **Интеграционный тест с платформой:**

   * Построить `PlatformLayout + FootprintDecor`,
   * проверить, что `maxY(platform) ≤ minY(footprint) + eps` — footprint выше пола.

---

### 15.3.7. Визуальные acceptance‑критерии (что ты должен увидеть)

После 15.2–15.3 (без ещё супер‑материалов, но с нормальной геометрией):

1. **Постамент:**

   * Башня стоит на **сложной многослойной золотой тарелке**:

     * видна ступенька под башней (Ring A),
     * вокруг — аккуратное кольцо (Ring B),
     * дальше — широкое внешнее поле (Ring C), которое уже не просто «таблетка».

2. **Footprint:**

   * В центре платформы вокруг башни — **чёткая, красивая гравировка**:

     * круговая линия/кольцо,
     * сегменты по колонкам, считывающиеся как «слоты» под кубики первого ряда.
   * Когда башня пуста (начало игры):

     * footprint ясно показывает, куда ляжет первый слой кубов.
   * Когда башня частично заполнена:

     * footprint виден между кубами (где есть пробелы).

3. **Никаких провалов/пересечений:**

   * Кубы первого уровня не пересекаются с платформой.
   * Footprint не «тонет» в платформе и не висит в воздухе.

4. **В visualDebug:**

   * При изменении радиусов/камеры platform и footprint аккуратно «дышат» вместе с башней:

     * всё остаётся центрированным,
     * ничего не лезет в стены зала.

---



---

## 15.4. Кремлёвский паркет и подсветка постамента

### 15.4.0. Жёсткие инварианты

1. **Геймплей не трогаем.**

   * Никаких изменений в логике падения/локов/разрушения.
   * Только материалы / текстуры / шейдерные твики платформы и footprint’а.

2. **Геометрию 15.2–15.3 не ломаем.**

   * Радиусы/высоты `PlatformLayout`, форма колец, footprint‑декор **не меняются**.
   * Все изменения — через материалы (`MeshStandardMaterial`, `onBeforeCompile`) и UV/vertexColor.

3. **Остаёмся в PBR‑мире Three.js.**

   * Базовый материал — `MeshStandardMaterial`.
   * Никаких кастомных шейдерМатериалов, которые выкинут нас из postprocessing/tonemapping.

4. **Ultra‑режим — никакого упрощения.**

   * В `visualDefaults`/`renderConfig` появится флаг `hallDetailLevel = "ultra" | "low"`.
   * Для `"ultra"`:

     * полный паркетный паттерн,
     * анимированные блики,
     * эмиссивные вставки.
   * Для `"low"`:

     * упрощённый статичный материал без тяжёлых шейдерных фич (но без визуального мусора).

---

### 15.4.1. Файлы: что трогаем, что нельзя

**Трогаем:**

* `src/render/textures.ts`

  * генерация новых текстур/атласов для платформы и parquet‑узора;
  * общие PBR‑карты (roughness/metalness/ao) могут переиспользоваться.

* `src/render/renderConfig.ts`

  * новый флаг detail‑уровня / включение parquet’а.

* `src/render/goldenPlatformGeometry.ts` *(из 15.2)*

  * только добавляем UV‑координаты под паркет;
  * без изменения позиций/индексов.

* `src/render/footprintDecor.ts` *(из 15.3)*

  * добавляем UV/vertexColor/emissive‑преднастройки.

* `src/render/sceneRenderer.ts`

  * подключаем новые материалы к платформе/footprint’у;
  * подкидываем время (`elapsedTime`) в `onBeforeCompile` через `uniform`.

* `src/render/materialDebug.ts`

  * добавить возможность в дебаг‑панели смотреть отдельно:

    * «Platform parquet»,
    * «Footprint emissive».

**НЕ трогаем категорически:**

* всё в `src/core/**` (логика игры, коллизии, падения);
* `src/app/destruction/**` (осколки);
* камера и следящий режим (`orbitCamera`, `cameraMotion`, твой новый follow).

---

### 15.4.2. Палитра и роли материалов

Сначала определяем **роли**, а не просто «ещё одно золото».

1. **Base Gold (Platform Body)**

   * Тёплое, довольно матовое золото для тела платформы (боковины, Ring C низ).
   * Меньше отражений, чтобы не слепило и не спорило с кубами.

2. **Polished Inlay (Parquet + Ring A/B верх)**

   * Полированное дерево+золото/камень в стиле Кремля:

     * цветовая модуляция: тёплые коричневые/бордовые/кремовые;
     * маленькие яркие золотые линии.

3. **Engraving Lines (Footprint + разделители)**

   * Тёмная «гравировка» — почти чёрно‑золотая, почти без roughness, но и без сильной metalness.
   * Виден как тонкий рисунок на полированном полу.

4. **Soft Glow Inlays (Emission)**

   * Тонкие линии и символы, слегка светящиеся:

     * эмиссивный цвет ≈ мягкий лимонно‑золотой,
     * яркость малЮсенькая, но заметная.

5. **Highlight Mask (только на будущем прицеле)**

   * Мы пока только заложим материал, который сможет менять эмиссию/цвет по инстансам.
   * Логика подсветки прицела будет отдельным этапом.

---

### 15.4.3. Процедурный паркетный атлас

**Цель:** CANVAS‑генератор «кремлёвского» паттерна, чтобы:

* не завязываться на внешние картинки,
* иметь мегачёткий рисунок без мыла.

1. **textures.ts: новый генератор**

   ```ts
   export interface GoldenParquetOptions {
     size?: number;      // 1024, 2048
     seed?: number;      // для случайных вариаций, но детерминированно
   }

   export function createGoldenParquetAtlas(opts?: GoldenParquetOptions): {
     map: THREE.Texture;
     roughnessMap: THREE.Texture;
     metalnessMap: THREE.Texture;
     aoMap: THREE.Texture;
     emissiveMap: THREE.Texture; // где надо подсветить
   }
   ```

2. **Структура атласа (UV‑пространства 0..1):**

   * Верхняя половина (0..1 x 0.5..1):

     * **Central Medallion** — круглый паттерн (по сути квадрат с вписанным кругом):

       * сложные радиальные узоры, «звезда», «крест», маленькие ромбы.

   * Нижняя левая четверть (0..0.5 x 0..0.5):

     * **Ring Pattern A** — тайлимый паттерн для внешних ячеек (широкий паркет).

   * Нижняя правая четверть (0.5..1 x 0..0.5):

     * **Ring Pattern B** — альтернативный паттерн (чуть другая геометрия), чтобы чередовать кольца.

3. **Логика рисования (канвас 2D):**

   * Фон:

     * плавный радиальный градиент (от светлого центра к чуть более тёмному краю).

   * Паркетные «плашки»:

     * линиями + заливками рисуем длинные прямоугольники под углом 45°, 135°, 0°, 90°;
     * разные оттенки «дерева».

   * Вставки:

     * тонкие золотые полоски вдоль швов (ширина 1–2 px);
     * небольшие медальоны в углах/центре (кружочки, ромбы).

   * Отдельный холст для roughness/metalness:

     * использовать те же фигуры, но:

       * тёмные зоны = более rough,
       * светлые = глянец / металл.

   * AO:

     * под швами и вокруг медальонов затемнить.

   * Emissive:

     * рисуем только те участки, которые должны чуть светиться:

       * тонкие контуры медальона,
       * маленькие «звёздочки».

4. **Настройки текстуры:**

   * `map.wrapS/T = THREE.RepeatWrapping;`
   * `map.anisotropy = renderer.capabilities.getMaxAnisotropy();`
   * `map.encoding = sRGBEncoding;`
   * Остальные (roughness/metalness/ao/emissive) — `LinearEncoding`, `RepeatWrapping`.

---

### 15.4.4. UV‑раскладка платформы под паркет

**goldenPlatformGeometry.ts:**

1. **Принцип:**

   * Для **центрального кольца Ring A**:

     * `uv` попадает в область Central Medallion ( верхняя половина атласа ).
     * Чтобы картинка не искажалась, `u/v` строим так:

       * `u = 0.5 + (r_norm * cos θ) * 0.5`
       * `v = 0.75 + (r_norm * sin θ) * 0.25` (примерно)
     * но проще: сделать для медиальонной зоны **отдельное геометрическое кольцо** с uv как для обычного окружного маппинга (по углу) и radial‑координатой по v.

   * Для **Ring B/C**:

     * используем тайлимые области Ring Pattern A/B.
     * `u` — по дуге (wrap 0..N), `v` — по радиусу.
     * Значение `u` можно умножить на factor, чтобы увеличить частоту паттерна.

2. **Распределение по атласу:**

   * Ring A:

     * `uvRect = { u0: 0, u1: 1, v0: 0.5, v1: 1 }` (medallion).

   * Ring B:

     * `uvRect = { u0: 0, u1: 0.5, v0: 0, v1: 0.5 }` (pattern A).

   * Ring C:

     * `uvRect = { u0: 0.5, u1: 1, v0: 0, v1: 0.5 }` (pattern B).

3. **Реализация:**

   * В генераторе геометрии при добавлении вершин:

     * помимо позиции и нормали, рассчитываем uv:

       * сначала местные `uLocal`/`vLocal` (0..1 внутри своего кольца),
       * затем маппим их в общий атлас через uvRect.

---

### 15.4.5. Материалы платформы

**textures.ts + новый helper в `sceneRenderer`:**

1. **Создаём материал «GoldenParquetMaterial»**

   ```ts
   export function createGoldenParquetMaterial(atlas: GoldenParquetAtlas): THREE.MeshStandardMaterial;
   ```

   * `map = atlas.map`
   * `roughnessMap = atlas.roughnessMap`
   * `metalnessMap = atlas.metalnessMap`
   * `aoMap = atlas.aoMap`
   * `emissiveMap = atlas.emissiveMap`
   * `color` — базовый тёплый (слегка коричнево‑золотой).
   * `metalness` ~ 0.6–0.8
   * `roughness` ~ 0.3–0.5
   * `emissive` = мягкий золотистый (0x5e4b1a, условно).
   * `emissiveIntensity` ~ 0.15 (в ultra).

2. **Два экземпляра одного материала с разными настройками:**

   * `parquetMedallionMaterial` (Ring A/B):

     * чуть больше emissive.
   * `parquetOuterMaterial` (Ring C):

     * меньше emissive, больше roughness.

3. **BaseGoldMaterial для тела платформы:**

   * Тот, что у нас есть для золота, но:

     * чуть увеличенная roughness,
     * без emissive.

4. **Назначение по группам geometry:**

   * В `goldenPlatformGeometry.ts` каждая группа получает materialIndex.
   * В `sceneRenderer` создаём массив материалов:

     * `materials[0] = baseGoldMaterial` (боковины, низ);
     * `materials[1] = parquetMedallionMaterial` (Ring A/B top);
     * `materials[2] = parquetOuterMaterial` (Ring C top, фаски).

---

### 15.4.6. Паркет «живой»: анимация бликов и свечение

**onBeforeCompile‑тюнинг** — аккуратно и локально.

1. **Анимированный highlight по углу (лёгкое «дыхание» пола)**

   * В `sceneRenderer` при создании материалов:

     * вводим общий `uniform float uTime;` для parquet‑материалов.
     * каждый кадр обновляем `material.userData.uTime` и `material.needsUpdate = false` (только uniform меняем, через `material.uniforms` после onBeforeCompile).

   * В самом `onBeforeCompile`:

     * добавляем `uniform float uTime;` в вершинник/фрагментник.

     * модифицируем `emissiveColor`:

       ```glsl
       float wave = 0.5 + 0.5 * sin(uTime * 0.3 + vUv.x * 12.0 + vUv.y * 8.0);
       float amp  = 0.15 * wave;  // максимум +15% к яркости
       totalEmissiveRadiance += vec3(amp);
       ```

     * Главное — **минимальная амплитуда**, чтобы не превращать пол в дискотеку.

2. **Дополнительный «крест»/«медальон» под башней**

   * Только для Ring A:

     * в фрагментнике можем сделать:

       ```glsl
       vec2 c = vUv - vec2(0.5, 0.75); // центр медальона
       float r = length(c);
       float star = smoothstep(0.3, 0.28, r) * smoothstep(0.0, 0.2, abs(c.x) + abs(c.y));
       totalEmissiveRadiance += vec3(star * 0.2);
       ```

   * Это создаст мягкий крест/круг вокруг башни.

3. **Переключение по конфигу:**

   * В `renderConfig`:

     ```ts
     hallDetailLevel: 'low' | 'ultra';
     parquetAnimation: boolean;
     ```

   * Если `low` или `parquetAnimation = false`:

     * не подключаем onBeforeCompile; используем статичный материал.

---

### 15.4.7. Footprint: подсветка и гравировка

**footprintDecor.ts:**

1. **Базовый материал гравировки (`footprintBaseMaterial`):**

   * `MeshStandardMaterial`:

     * `color` ~ очень тёмное золото (0x261d10),
     * `metalness` ~0.5,
     * `roughness` ~0.4,
     * без map/roughnessMap (можно использовать те же карты, но необязательно),
     * без emissive.

2. **Светящаяся клеточная сетка (`footprintCellMaterial`):**

   * `color` ~ нейтральное золото (не слишком яркое).

   * `emissive` ~ 0x8a6d2a.

   * `emissiveIntensity` ~ 0.2–0.3.

   * `transparent = true`, `opacity = 0.9`.

   * В `onBeforeCompile`:

     * добавляем лёгкую пульсацию:

       ```glsl
       float pulse = 0.5 + 0.5 * sin(uTime * 0.8);
       totalEmissiveRadiance *= (0.7 + 0.3 * pulse);
       ```

   * В будущем логика прицела просто будет менять эмиссию цветом/масштабом.

3. **Слои:**

   * В группе `createFootprintDecor`:

     * `ringEngraving` получает `footprintBaseMaterial`.
     * `cellSectors` — `footprintCellMaterial`.
     * (позже `cellCenters` — отдельный InstancedMesh под прицел.)

---

### 15.4.8. Дебаг‑режимы и настройки

1. **Visual Debug Controls:**

   * Добавить секцию «Hall / Platform»:

     * `Hall detail` — селектор: `low / ultra`.
     * `Parquet animation` — чекбокс.
     * `Show raw footprint overlay` — чекбокс (для старой wire‑версии).

2. **Материал‑дебаг:**

   * В dropdown `Material debug` добавить варианты:

     * `Platform parquet only` — отключить всё кроме платформы и башни для оценки пола.
     * `Footprint glow` — особый режим, где остальное приглушено.

---

### 15.4.9. Тесты

1. **textures.goldenParquet.test.ts**

   * Проверяем:

     * размеры атласа,
     * что все текстуры не `null`, `image` присутствует;
     * min/max значений для roughnessMap/metalnessMap/aoMap в допустимых диапазонах (через чтение pixel‑данных).

2. **goldenPlatformMaterial.test.ts**

   * Создаём платформу с parquet‑материалами:

     * проверяем массив materials (наличие нужных materialIndex),
     * проверяем, что `onBeforeCompile` присваивает `uTime`.

3. **footprintDecorMaterial.test.ts**

   * Проверяем, что `cellSectors` mesh использует emissive и зависит от `uTime`.

---

### 15.4.10. Что ты должен увидеть глазами

После выполнения 15.4:

1. **Платформа** перестаёт быть «таблеткой» и превращается в **богатую тарелку**:

   * центр — яркий медальон с замороченным узором, будто под башней гербовый круг;
   * вокруг — сложный паркет, похожий на кремлёвский:

     * полосы под разными углами,
     * небольшие контрастные вставки.

2. **При движении камеры** пол «дышит» очень мягко:

   * тонкие блики по parquet’у гуляют,
   * эмиссивные линии слегка пульсируют.

3. **Footprint**:

   * не выглядит как дебажная сетка,
   * считывается как **гравированные круги и светящиеся деления**, чётко привязанные к колонкам.

4. **При выключении анимации** (или low‑детале):

   * всё остаётся красивым, но без лишних «фокусов»,
   * производительность не проседает.

---



---

## 15.5. Стены дворцового зала

### 15.5.0. Жёсткие инварианты

1. **Камеру и геймплей не трогаем.**

   * Никаких изменений в:

     * follow‑камере,
     * орбите, FOV, управлении мышью/клавой,
     * логике падения/локов/разрушений.
   * Стены — чисто визуальный слой, который подчиняется *уже настроенным* `HallLayoutRadii`.

2. **Радиусы и высоты берём только из layout’ов.**

   * Радиус внутренних стен = `hallLayout.hallInnerRadius` (из 15.1), никаких своих формул.
   * Высота стен — функция от:

     * высоты башни (boardDimensions.height * cellSize.y),
     * высоты платформы (`PlatformLayout` из 15.2),
     * но **не** от магических чисел.

3. **Стены не перекрывают башню и тетримино.**

   * Ни один элемент стены (колонна, панель, ниша, голограмма) не выступает внутрь радиуса:

     * `towerOuterRadius + safetyGapWall`
   * Мин. вертикальный зазор между верхом башни и нижним краем карниза/купола > 0.5 высоты куба.

4. **Ultra‑режим = настоящий рельеф, а не текстура на цилиндре.**

   * В ultra:

     * стены имеют **реальную глубину** (карниз, пилястры, панели выступают/утоплены),
     * есть 3D‑орнамент/лепнина, а не просто нарисованный нормал‑мап.
   * В low:

     * можно упростить геометрию, но не превращать всё в одну серую трубу.

5. **Ритм стен синхронизирован с башней.**

   * Вертикальный ритм (колонки/панели) выровнен по:

     * `board.width` (числу колонок тетриса),
     * чтобы визуально совпали «сектора» башни и «сектора» зала.

---

### 15.5.1. Файлы: что трогаем и что нельзя

**Трогаем / добавляем:**

* `src/render/hallLayout.ts`

  * добавляем параметры по высотам стен (но без ломки радиусов).

* `src/render/platformLayout.ts`

  * только читаем (верх платформы, чтобы «пристегнуть» базу стены).

* `src/render/goldenHallWalls.ts` *(новый модуль)*

  * генерация геометрии стен.

* `src/render/textures.ts`

  * генерация атласа/карт для стен: панелей, лепнины, голографических вставок.

* `src/render/sceneRenderer.ts`

  * сборка стен в сцену, привязка к layout’ам.

* `src/render/materialDebug.ts`, `visualDebugMode.ts`, `visualDebugControls.ts`

  * новые режимы дебага стен.

**Нельзя трогать:**

* всё в `src/core/**`;
* `src/app/destruction/**`;
* `src/render/cameraSetup.ts`, `orbitCamera.ts`, `cameraMotion.ts` (камера);
* уже реализованные `HallLayoutRadii`, `PlatformLayout` (кроме чтения).

---

### 15.5.2. Концепция стены: вертикальные зоны

Стена делится по высоте на **три зоны + карниз**:

1. **Base Zone (цоколь)**

   * Низ стены, от уровня пола платформы до ~0.3 высоты стены.
   * Визуально: тяжёлая каменно‑золотая «подошва»:

     * толстые плиты,
     * горизонтальные пояса,
     * минимум деталей (спокойный фон для низких рядов кубиков).

2. **Middle Zone (основная декоративная зона)**

   * От 0.3 до 0.8 высоты стены.
   * Главная часть:

     * вертикальные пилястры/колонны,
     * глубокие панели между ними,
     * ниши с голографическими элементами.

3. **Upper Zone**

   * От 0.8 до 1.0 высоты стены.
   * Более лёгкая по визуалу:

     * орнаментальный фриз,
     * ритм мелких деталей,
     * плавный переход к карнизу/куполу.

4. **Cornice (карниз)**

   * Толстый выступающий элемент по самому верху:

     * несколько ступенчатых профилей (как классическая мебельная филёнка),
     * формирует «границу» с куполом/небом (который будет в 15.6).

---

### 15.5.3. HallWallsLayout: высоты и секции

В `hallLayout.ts` вводим ещё один layout для стен:

```ts
export interface HallWallsLayout {
  innerRadius: number;        // == hallLayout.hallInnerRadius
  outerRadius: number;        // innerRadius + wallThickness
  baseY: number;              // от чего считаем высоту стен
  height: number;             // общая высота стены (до карниза)
  zones: {
    baseTopY: number;
    midTopY: number;
    upperTopY: number;
    corniceTopY: number;
  };
  segmentCount: number;       // количество вертикальных секций по окружности
}
```

Функция:

```ts
export function computeHallWallsLayout(
  hallLayout: HallLayoutRadii,
  platform: PlatformLayout,
  board: BoardDimensions,
  cellSize: { y: number; x: number; }
): HallWallsLayout;
```

**Логика:**

* `innerRadius = hallLayout.hallInnerRadius`;

* `outerRadius = innerRadius + wallThickness` (wallThickness из конфига, 0.5–1 cellSize.x).

* `baseY = platform.baseY + platform.heightCore`; // верх основной платформы.

* Высота стены:

  * towerHeight = `board.height * cellSize.y`;
  * `height ≈ towerHeight * 1.2` (чтобы стена была чуть выше башни, но не уходила в бесконечность).

* Зоны:

  * `baseTopY = baseY + height * 0.25`;
  * `midTopY = baseY + height * 0.7`;
  * `upperTopY = baseY + height * 0.9`;
  * `corniceTopY = baseY + height * 1.0`.

* `segmentCount = board.width` (один сегмент на колонку тетриса).

---

### 15.5.4. Сегментация стены по окружности

Внутреннюю сторону стены делим на `segmentCount` вертикальных секций:

* Каждая секция соответствует **одной колонке башни**.
* Для секции `i` (0..segmentCount-1):

  * углы:

    * `θ0 = 2π * i / segmentCount`
    * `θ1 = 2π * (i + 1) / segmentCount`
  * четыре вертикальные линии (inner/outer * θ0/θ1).

В каждой секции будут:

* **central panel** (утоплена вглубь от innerRadius),
* **left/right pilaster** (немного выступает внутрь),
* опциональные **ниши/голограммы**.

---

### 15.5.5. Геометрия Base Zone (цоколь)

**Модуль:** `goldenHallWalls.ts`

1. **Форма:**

   * Внутренний радиус: `innerRadius`.
   * Внешний: `outerRadius`.
   * Y: от `baseY` до `baseTopY`.

2. **Элементы:**

   * Цельный цилиндрический сегмент по окружности (как у платформы), но:

     * разбит по `segmentCount` на прямоугольные участки;
     * каждый участок — плита, которую можно слегка смещать/наклонять.

   * Внутри каждого сегмента:

     * горизонтальные «пояса» (2–3 уровня):

       * экструзия на ±0.02–0.05 внутрь/наружу.
       * создаёт рельеф.

3. **Геометрия:**

   * Похожа на платформу: берём прямоугольник по развертке (θ0..θ1, baseY..baseTopY).
   * Строим tristrip:

     * две вертикальные линии на inner, две на outer,
     * в нужных местах сдвигаем радиус для полос (поясов).

4. **Цель:**

   * Лёгкий, спокойный низ, который считывается как массивная опора.

---

### 15.5.6. Middle Zone: пилястры, панели, ниши

Это сердце стены — самое «дворцовое» место.

1. **Пилястры/колонны (вертикальный ритм)**

   * Для каждой секции:

     * слева и справа от центральной панели — *плоские* пилястры:

       * внутренний радиус: `innerRadius - pilasterDepth` (немного выступают внутрь),
       * ширина ~ 15–20% секции,
       * от `baseTopY` до `midTopY`.

   * Геометрия:

     * простые прямоугольные экструзии по высоте,
     * на них позже навешиваем нормал‑мэп с рёбрами.

2. **Центральные панели**

   * В центре каждой секции — утопленная панель:

     * внутренний радиус: `innerRadius + panelInset` (панель чуть «впала» внутрь).
     * ширина ~ 60–70% секции.

   * Панели разделены по высоте на 2–3 «кадра»:

     * middle‑frame (основной),
     * верхний небольшой сегмент (под нишу),
     * нижний (декоративный пояс).

3. **Ниши с голограммами**

   * В части сегментов (через один, или по паттерну) внутрь панели врезается **ниша**:

     * внутренняя плоскость ещё дальше внутрь (innerRadius + panelInset + nicheInset),
     * по высоте в середине `baseTopY..midTopY`.

   * Внутри ниши:

     * плоский прямоугольник (plane) с emissive‑материалом:

       * «голографический» орнамент: абстрактный узор, иероглифы, цифры счёта, что угодно.
       * Альфа + additive emissive.

   * Количество ниш и их распределение регулируются `HallWallsConfig`:

     * чтобы в low‑качестве можно было их отключать.

---

### 15.5.7. Upper Zone: фриз и мелкие детали

1. **Фриз (горизонтальная полоса орнамента)**

   * От `midTopY` до `upperTopY`.

   * Структура:

     * непрерывная лента по окружности, разбитая на сегменты;
     * для каждого сегмента — «рамка» и 1–2 небольших медальона.

   * Мотивы:

     * повторяющийся паттерн (ромбы, трилистники, острые формы),
     * 3D‑рельеф небольшой глубины.

2. **Мелкие выступы / «зубчики»**

   * По верхнему краю `upperTopY` можно добавить небольшие зубцы/ребра:

     * маленькие прямоугольные выступы через 1/2 сегмента,
     * это сделает линию верха более сложной и интересной.

---

### 15.5.8. Карниз (Cornice)

Карниз — это переход между стеной и куполом/небом (будет в 15.6).

1. **Геометрия:**

   * Несколько «ступеней»:

     * innerRadius чуть уменьшается/увеличивается по мере подъёма:

       * ступень 1: innerRadius — 0.02,
       * ступень 2: innerRadius — 0.04,
       * ступень 3: innerRadius — 0.03 (слегка назад).

   * По высоте: от `upperTopY` до `corniceTopY`.

2. **Назначение:**

   * Создать насыщенную, «дорогую» линию отрыва:

     * свет будет красиво скользить по ступенчатому профилю,
     * теневые переходы добавят глубины.

---

### 15.5.9. Материалы стен

Добавляем в `textures.ts`:

```ts
export interface HallWallsAtlas {
  map: THREE.Texture;
  roughnessMap: THREE.Texture;
  metalnessMap: THREE.Texture;
  aoMap: THREE.Texture;
  normalMap: THREE.Texture;
  emissiveMap: THREE.Texture;
}
```

Функция:

```ts
export function createHallWallsAtlas(opts?: { size?: number; seed?: number }): HallWallsAtlas;
```

1. **Содержимое атласа:**

   * Тайл для Base Zone:

     * крупные каменные плиты с чуть разными оттенками золота/камня.
   * Тайл для Middle Panels:

     * рамки, филёнки, лёгкие растительные/абстрактные мотивы.
   * Тайл для Pilasters:

     * вертикальные полосы с рёбрами.
   * Тайл для Frieze:

     * повторяющийся орнамент (ромбоидные формы).
   * Emissive channel:

     * небольшие точки/линиИ в нишах и орнаментах.

2. **Материалы:**

   * `hallWallBaseMaterial`

     * для Base Zone, уменьшенная metalness, повышенная roughness.

   * `hallWallMidMaterial`

     * для панелей/пилястр,
     * более зеркальное золото, но без перегиба.

   * `hallWallFriezeMaterial`

     * чуть более яркая emissive, чтобы фриз легко читался.

   * `hallNicheHologramMaterial`

     * чисто emissive, `transparent = true`,
     * с `onBeforeCompile` для анимации.

---

### 15.5.10. Анимации: голограммы и динамика на стенах

1. **Ниши‑голограммы:**

   * В `hallNicheHologramMaterial.onBeforeCompile`:

     * добавляем `uniform float uTime;`.

     * анимация:

       ```glsl
       float scan = fract(uTime * 0.2 + vUv.y * 2.0);
       float glow = smoothstep(0.0, 0.2, scan) * smoothstep(1.0, 0.8, scan);
       vec3 hologramColor = vec3(0.9, 0.8, 0.4); // тёплое золото
       gl_FragColor.rgb = hologramColor * glow;
       gl_FragColor.a = glow;
       ```

     * Даёт эффект «сканирующей» полоски сверху вниз.

2. **Лёгкая анимация фриза:**

   * В `hallWallFriezeMaterial`:

     * чуть изменяем emisiveIntensity по синусу:

       ```glsl
       float wave = 0.5 + 0.5 * sin(uTime * 0.1 + vUv.x * 10.0);
       totalEmissiveRadiance *= (0.8 + 0.2 * wave);
       ```

3. **Конфиги:**

   * В `renderConfig`:

     ```ts
     hallWallsAnimation: boolean;
     hallNicheCount: number;      // сколько ниш использовать (для performance tuning)
     ```

   * В low‑режиме:

     * отключаем onBeforeCompile‑анимации,
     * уменьшаем или отключаем ниши.

---

### 15.5.11. Интеграция в сцену

**Модуль:** `goldenHallWalls.ts`

1. **API:**

```ts
export interface HallWallsResources {
  mesh: THREE.Mesh;           // основной mesh стен с группами материалов
  nichesGroup: THREE.Group;   // голограммы и отдельные элементы
}

export function createHallWalls(
  scene: THREE.Scene,
  hallLayout: HallLayoutRadii,
  platformLayout: PlatformLayout,
  board: BoardDimensions,
  cellSize: { x: number; y: number },
  config: RenderConfig
): HallWallsResources;
```

2. **Порядок:**

   * Вычислить `wallsLayout = computeHallWallsLayout(...)`.
   * Создать геометрию Base/Mid/Upper/Cornice в одном BufferGeometry с группами.
   * Подготовить материалы из `createHallWallsAtlas`.
   * Собрать Mesh и добавить в сцену.
   * Создать группу ниш‑голограмм (одна плоскость per ниша, с emissive‑материалом).
   * Ниш разместить в сегментах (например, через один):

     * сектора `i % 2 === 0` — ниша, `i % 2 === 1` — глухая панель.

3. **Подключение uTime:**

   * В `sceneRenderer` (или главном renderer’е):

     * держать общий `timeUniform` для всех анимированных материалов,
     * на каждом кадре обновлять.

---

### 15.5.12. Debug‑режимы и тесты

1. **Visual Debug:**

   * Добавить опции:

     * `[ ] Show walls only` (выключает башню/кубы/эффекты, оставляет стены + платформу).
     * `[ ] Highlight wall segments` — раскрашивает сегменты по номеру (чтобы видеть выравнивание с колонками башни).
     * `[ ] Freeze wall animation` — фиксирует `uTime` для сравнения.

2. **Юнит‑тесты:**

   * `hallWallsLayout.test.ts`:

     * проверка, что:

       * `innerRadius == hallLayout.hallInnerRadius`,
       * `outerRadius > innerRadius`,
       * `baseY` >= верх платформы,
       * `height` >= towerHeight * 1.1.

   * `hallWallsGeometry.test.ts`:

     * генерируем геометрию для маленького board.width,
     * убеждаемся, что:

       * число вершин > 0,
       * boundingBox включает [innerRadius, outerRadius] по XZ,
       * no NaN.

3. **Интеграционный тест:**

   * Софтовый (вручную, глазами):

     * включить `Show walls only`,
     * включить hall radii overlay (из 15.1),
     * убедиться, что:

       * внутренняя поверхность стен строго за жёлтым кругом (inner hall),
       * стены выше башни,
       * сегментные границы совпадают с колонками башни.

---

### 15.5.13. Что ты должен увидеть глазами

После реализации 15.5 (вместе с уже сделанными 15.1–15.4):

1. **Не гараж, а дворцовый зал.**

   * Башня стоит в центре:

     * снизу — кремлёвский паркет и инкрустированный footprint,
     * вокруг — массивные золотые стены с глубокими панелями, пилястрами и украшениями.

2. **Видимый ритм секций.**

   * Если посмотреть вокруг:

     * каждая колонка тетриса соответствует своей вертикальной секции стены,
     * можно мысленно «совместить» линию башни и линию стены.

3. **Никакой «полутрубы» и половинной высоты.**

   * Стены доходят до карниза, который дальше в 15.6 логично поддержит купол/небо.

4. **Голограммы/ниши.**

   * Между панелями видны ниши с мягко переливающимся светом (без кислотного кринжа):

     * эффект «живой» стены,
     * но тетримино и ряды остаются читаемыми.

5. **При движении камеры.**

   * Свет и тени красиво играют по рельефу:

     * карниз даёт яркие бликовые линии,
     * пилястры и панели создают глубину сцены.

---


---

## 15.6. Купол / небо + свет

### 15.6.0. Жёсткие инварианты

1. **Камеру и геймплей не трогаем.**

   * Никаких изменений в:

     * follow‑камере,
     * орбите, FOV, управлении,
     * логике тетриса, разрушений, скоростей, UI.
   * Можно только **читать** позицию/настройки камеры, чтобы подстроить свет и купол.

2. **Ничего не ломаем из 15.1–15.5.**

   * Радиусы/высоты:

     * `HallLayoutRadii` (inner/outer hall),
     * `PlatformLayout` (постамент),
     * `HallWallsLayout` (стены),
       — только используем, не меняем.
   * Башня, платформа, стены, паркет, footprint — должны выглядеть как раньше, только освещёнными лучше.

3. **Свет — физически правдоподобный (на уровне PBR), но без цирка.**

   * Остаёмся в парадигме:

     * `MeshStandardMaterial`,
     * environment map,
     * несколько источников света.
   * Никаких «белых шариков» как лампочек в кадре, которые только мешают.

4. **Ultra‑режим: максимум красоты, Low‑режим: аккуратное упрощение, но не уродство.**

   * В ultra:

     * купол/небо, environment‑карта, несколько слоёв света, лёгкие «бог‑рейсы» (фейки), тонкая дымка.
   * В low:

     * 1–2 ключевых источника + environment map попроще, без тяжёлых шейдерных фокусов.

5. **Никакого мерцающего говна и стробоскопов.**

   * Анимации (если будут) — **мягкие**, медленные.
   * Никаких резких скачков яркости, цветов, резкого «дышания» света.

---

### 15.6.1. Файлы: что трогаем, что нельзя

**Добавляем / модифицируем:**

* `src/render/hallLayout.ts`

  * уже есть HallLayout / HallWallsLayout — добавим высоты для купола/неба.

* `src/render/goldenDome.ts` *(новый модуль)*

  * геометрия купола/потолка.

* `src/render/environmentMap.ts`

  * генерация/загрузка HDR/диффузной env‑карты под «золотой зал».

* `src/render/lightingRig.ts` *(новый модуль)*

  * сборка световой схемы зала (key/fill/rim/accents).

* `src/render/postProcessing.ts`

  * аккуратная подстройка bloom / fog / exposure под новый свет.

* `src/render/renderConfig.ts`

  * флаги:

    * `hallLightingQuality: 'low' | 'ultra'`,
    * `hallFogEnabled: boolean`,
    * `hallGodRaysEnabled: boolean`.

* `src/render/sceneRenderer.ts`

  * вызовы:

    * `createGoldenDome(...)`,
    * `createLightingRig(...)`,
    * подключение envMap к материалам.

* `src/render/envDebug.ts`, `visualDebugControls.ts`, `visualDebugMode.ts`

  * новые debug‑панели:

    * показать только env/light,
    * переключать пресеты освещения.

**НЕ трогаем:**

* всё под `src/core/**`;
* `src/app/**` (управление, события, destruction);
* `src/render/cameraSetup.ts`, `orbitCamera.ts`, `cameraMotion.ts` (камера логически готова, используем её).

---

### 15.6.2. Концепция: что именно мы делаем

Высокий уровень:

1. **Геометрия купола / верхнего объёма**

   * Внутренний «потолок» над стенами:

     * круглый, сегментированный по тем же секциям, что стены/башня;
     * с большим центральным «световым оком» / оракулом, через которое будто льётся свет.

2. **Небо / фоновый свет**

   * Либо:

     * абстрактный «небесный» градиент под куполом,
   * либо:

     * бледное HDR‑небо без конкретного солнца (чтобы не превращаться в реалистичный пейзаж, а остаться в «абстрактной золотой бесконечности»).

3. **Световая схема (lighting rig)**

   * **Key light** — основной направленный свет сверху под углом, даёт читаемые тени башни.
   * **Fill light** — мягкий заполняющий свет, чтобы золото не превращалось в чёрные дыры.
   * **Rim/Accent lights** — подсветки:

     * по кругу у основания купола,
     * на стенах/карнизах,
     * лёгкий up‑light от постамента.

4. **Environment map (IBL)**

   * Специально под «золотой зал»:

     * светлые участки сверху,
     * тёплое окружение по бокам,
     * отражения на золотых кубах / платформе / осколках.

5. **Атмосферка**

   * Очень лёгкий volumetric‑fake:

     * мягкая туманная дымка наверху,
     * чуть‑чуть glow от центра купола,
     * контролируемый bloom.

---

### 15.6.3. HallDomeLayout: высоты и радиусы купола

В `hallLayout.ts` добавляем:

```ts
export interface HallDomeLayout {
  innerRadius: number;     // >= hallLayout.hallInnerRadius
  outerRadius: number;     // innerRadius + domeThickness
  baseY: number;           // y: верх карниза
  apexY: number;           // y: вершина купола
  skyInnerRadius: number;  // радиус "отверстия"/светового центра
}
```

Функция:

```ts
export function computeHallDomeLayout(
  wallsLayout: HallWallsLayout,
  hallLayout: HallLayoutRadii,
  board: BoardDimensions,
  cellSize: { x: number; y: number }
): HallDomeLayout;
```

**Логика:**

* `innerRadius = wallsLayout.innerRadius` — купол опирается на внутренний край стен.

* `outerRadius = innerRadius + domeThickness` (из конфигурации, 0.3–0.7 * cellSize.x).

* `baseY = wallsLayout.zones.corniceTopY`.

* `towerHeight = board.height * cellSize.y`.

* `apexY ≈ baseY + towerHeight * 0.6–0.8` (чтобы купол не был слишком приплюснутым и не слишком», но визуально доминировал).

* `skyInnerRadius`:

  * радиус внутреннего «светящегося» круглого окна:

    * ≈ `innerRadius * 0.35–0.45`.

Инварианты:

* `apexY > topOfTowerY + cellSize.y * 0.5` (чёткий зазор между верхом башни и куполом).
* `skyInnerRadius < innerRadius - margin`.

---

### 15.6.4. Геометрия купола

**Модуль:** `src/render/goldenDome.ts`

1. **Базовая форма купола (сферический сегмент / smooth dome)**

   * Используем что‑то вроде «сферического колпака»:

     * по радиусу: от `innerRadius` до `outerRadius`,
     * по высоте: от `baseY` до `apexY`.

   * Сегментация по окружности:

     * `segmentCount = wallsLayout.segmentCount` (совпадает с башней/стенами).

   * По высоте:

     * 8–16 сегментов (в ultra), 4–8 в low.

   * Внутренняя сторона купола — то, что видно камере:

     * нормали направлены **внутрь**.

   * Выделить отдельные **группы geometry**:

     * `domeBody` — основная поверхность.
     * `domeRibs` — декоративные ребра (см. ниже).
     * `domeOculus` — область вокруг центрального «окна/неба».

2. **Декоративные рёбра / секции**

   * От каждой стеновой секции вверх идут **радиальные рёбра** купола:

     * по окружности совпадают с границами сегментов,
     * слегка выступают внутрь (на 0.02–0.05).

   * Геометрия:

     * либо отдельные узкие полоски, идущие по поверхности купола,
     * либо небольшие выпуклости, экструзии.

   * Можно сделать арки: каждая пара сегментов образует «арку» с пересечением в верхней части.

3. **Область «светового ока» (sky area)**

   * В центре купола (по проектору на XZ):

     * небольшая окружность радиуса `skyInnerRadius`.
   * Внутренний круговый «обод» вокруг «неба»:

     * богатый рельеф (как медальон, но вертикальный),
     * отдельный материал с более сильными отражениями.

4. **UV‑раскладка купола**

   * Для тела купола:

     * cylindrical/polar mapping:

       * `u = θ / (2π)`,
       * `v = (y - baseY) / (apexY - baseY)`.

   * Для ока/ограничивающего кольца:

     * как для круглого медальона (центр в apex, радиус).

   * Все UV мапятся в HallWallsAtlas или отдельный `DomeAtlas`,
     чтобы получить:

     * широкие мягкие градиенты,
     * структурный узор (мелкие золотые плитки, резьбу).

---

### 15.6.5. Небо / фон: sky dome или sky plane

Есть два уровня:

1. **Внутренний купол (уже сделали)** — «твёрдый» потолок.

2. **Светящийся центр (sky / void)**

   * Внутри `skyInnerRadius` — **отдельная геометрия**:

     * либо полупрозрачный «небесный диск» немного выше apexY,
     * либо шаровой сегмент, уходящий вверх (внутреннее «небо»).

   * Материал:

     * `MeshBasicMaterial` или `MeshStandard` с:

       * сильным emissive,
       * soft градиентом: центр ярче, к краям темнее.

   * Цветовая схема:

     * не «голубое земное небо», а:

       * мягкий тёплый «небесный свет»: бело‑золотой с лёгкими пастельными оттенками.

3. **Процедурный sky‑gradients:**

   * В textures.ts:

     ```ts
     export function createHallSkyTexture(options?: { size?: number }): THREE.Texture;
     ```

   * Рисуем градиент:

     * центр: почти белый,
     * радиально к краям: тёплые светло‑золотые/слегка розоватые,
     * добавляем subtle шум (перлин/воронои), чтобы он не был абсолютно гладким.

   * Это можно навесить на «sky disk/plane», который находится над куполом
     и виден через центральное отверстие / полупрозрачный купол.

---

### 15.6.6. Environment Map (IBL для золотого зала)

**Модуль:** `src/render/environmentMap.ts`

1. **Новый пресет env для «Golden Hall»**

   ```ts
   export interface HallEnvMap {
     envMap: THREE.Texture;
     diffuseEnvMap: THREE.Texture;   // pmrem-перефильтрованная
     intensity: number;
   }

   export function createGoldenHallEnvMap(
     renderer: THREE.WebGLRenderer,
     options?: { resolution?: number; useHDR?: boolean; }
   ): Promise<HallEnvMap>;
   ```

2. **Варианты реализации:**

   * **Минимальный (без внешних HDR):**

     * генерировать простой кубмап/сфермап в runtime:

       * верх — очень светлый,
       * боковины — золотистые,
       * низ — темнее.
     * Прогнать через `PMREMGenerator`.

   * **Расширенный (если пользователь потом захочет):**

     * дать возможность подхватить внешний HDR‑кубмап:

       * `hallEnvMapUrl` в конфиге,
       * fallback — процедурный.

3. **Подключение к материалам:**

   * В `sceneRenderer` после создания envMap:

     * для всех **золотых** материалов (кубы, платформа, стены, осколки):

       * `material.envMap = envMap;`
       * `material.envMapIntensity = ...` (разное для разных типов):

         * кубы башни — 1.0–1.4;
         * платформы/паркет — 0.8–1.0;
         * стены — 0.6–0.9;
         * осколки при разрушении — до 1.6 (чтобы вспышка была сочной).

   * Добавить в `renderConfig`:

     * `hallEnvIntensityMultiplier`.

---

### 15.6.7. Световая схема (Lighting rig)

**Новый модуль:** `src/render/lightingRig.ts`

Интерфейс:

```ts
export interface HallLightingRig {
  keyLight: THREE.DirectionalLight;
  fillLight: THREE.HemisphereLight | THREE.DirectionalLight;
  rimLights: THREE.Light[];
  accentLights: THREE.Light[];
  ambientLight: THREE.AmbientLight;
}

export function createHallLightingRig(
  scene: THREE.Scene,
  domeLayout: HallDomeLayout,
  hallLayout: HallLayoutRadii,
  config: RenderConfig
): HallLightingRig;
```

1. **Key light (главный)**

   * `THREE.DirectionalLight`.

   * Направление:

     * сверху, чуть со стороны:

       * из точки примерно `(innerRadius * 0.3, apexY + towerHeight, innerRadius * 0.6)` в центр башни.

   * Интенсивность:

     * в ultra: 1.2–1.7;
     * в low: 0.8–1.2.

   * Цвет:

     * тёплый белый (не оранжевый):

       * примерно RGB(1.0, 0.93, 0.85).

   * Shadow:

     * (опционально, если не слишком тяжело)

       * `castShadow = true` для кубов/платформы/частично стен,
       * аккуратно подобрать shadowMapSize, bias.

2. **Fill light (заполняющий)**

   * `THREE.HemisphereLight` или слабый `DirectionalLight`:

     * skyColor — чуть холоднее (белый с лёгким голубым),
     * groundColor — тёплый, чуть темнее.

   * Интенсивность:

     * 0.2–0.5.

3. **Rim lights (обводка)**

   * 2–4 точечных/spot‑света по кольцу над башней:

     * позиции: вокруг innerRadius * 0.7–1.0, на высоте `midTopY + 0.5 towerHeight`.
     * цвет — чуть более холодное золото (с лёгкой зелёной/голубой примесью), чтобы отличалось от key.

   * Интенсивность малая:

     * 0.1–0.3, задача — чуть подсветить грани кубов и карниз.

4. **Accent lights (подсветка платформы / центра)**

   * 1–2 `SpotLight` изнутри платформы вверх:

     * позиция: (0, baseY+0.1, 0),
     * направление: вверх, с широким углом.

   * Они создают мягкий glow вокруг башни, подчёркивают медальон платформы.

5. **AmbientLight (тонкая подложка)**

   * Очень слабый:

     * intensity 0.03–0.07,
     * цвет чуть более тёмный желтовато‑коричневый.

   * Только чтобы не было идеально чёрных провалов в тенях.

6. **Режимы качества:**

   * В `RenderConfig`:

     ```ts
     hallLightingQuality: 'ultra' | 'low';
     ```

   * В ultra:

     * все источники активны,
     * ключевой directional со shadow,
     * rim/accents включены.

   * В low:

     * возможна схема:

       * ambient + 1 directional + hemisphere,
       * без rim и spot имитаций, без shadow или с маленькой картой.

---

### 15.6.8. Атмосфера: туман, god‑rays, bloom

**postProcessing.ts + sceneRenderer**

1. **Fog / atmospheric scattering**

   * Мягкий `THREE.FogExp2`:

     * цвет близкий к цвету стен/купола, но темнее:

       * RGB(0.1–0.15, 0.09–0.11, 0.06–0.08).
     * плотность очень маленькая: 0.002–0.006.

   * Включаем только в ultra и только для дальних планов:

     * башня и платформа почти не «затуманены»,
     * купол и дальние верхние части стен — слегка.

   * Параметр `hallFogEnabled` в конфиге + чекбокс в debug.

2. **Bloom**

   * В `postProcessing.ts` уже, скорее всего, есть BloomPass.

   * Настройка под новый свет:

     * threshold высоко (0.7–0.9),
     * strength умеренная (0.4–0.7),
     * radius маленький/средний.

   * Основной эффект:

     * лёгкое сияние:

       * от центрального «неба»,
       * от голограмм в нишах,
       * от сильно освещённых граней кубов.

   * В debug:

     * режим `Show bloom layer` — подсветить только то, что светится.

3. **God‑rays (фейковые) — опционально**

   * Если хочешь прям «RTX‑по‑бедному»:

     * сделать 2–4 billboard‑плоскости (полупрозрачные конусы/веера) под «окном» купола,
     * материал:

       * `MeshBasicMaterial` с текстурой soft‑луча (radial gradient + alpha),
       * повернуть / разместить так, чтобы они шли от центра купола к башне.

   * Лёгкая анимация альфы + scale для «дыхания».

   * Всё это включаем только для ultra и с отдельным флагом:

     ```ts
     hallGodRaysEnabled: boolean;
     ```

---

### 15.6.9. Debug‑режимы

В `visualDebugControls.ts` / `visualDebugMode.ts`:

1. **Lighting debug:**

   * `[ ] Show lights gizmos` — отрисовать маленькие цветные сферы в позициях источников света.
   * `[ ] Solo key light` — оставить только keyLight + ambient, вырубить остальное.
   * `[ ] Solo env map` — выключить все эксплицитные источники, оставить только IBL.

2. **Dome / sky debug:**

   * `[ ] Hide dome` — скрыть геометрию купола (чтобы посмотреть стены/зал без него).
   * `[ ] Sky only` — показать только «небо»/skyDisks (выключить зал).

3. **Fog / bloom toggles:**

   * `[ ] Hall fog`
   * `[ ] Hall bloom`
   * `[ ] Hall god‑rays`

Это нужно, чтобы ты мог тонко регулировать и ловить артефакты.

---

### 15.6.10. Тесты

1. **hallDomeLayout.test.ts**

   * Проверить:

     * `innerRadius == wallsLayout.innerRadius`,
     * `outerRadius > innerRadius`,
     * `baseY >= wallsLayout.zones.corniceTopY`,
     * `apexY > towerTopY + cellSize.y * 0.5`,
     * `skyInnerRadius < innerRadius`.

2. **goldenDomeGeometry.test.ts**

   * Для маленького `segmentCount`:

     * геометрия не пустая,
     * boundingBox:

       * XZ радиус около `innerRadius..outerRadius`,
       * Y диапазон от `baseY..apexY`.

3. **lightingRig.test.ts**

   * Проверить:

     * keyLight.target направлен примерно в центр башни,
     * интенсивности в разумных пределах (не > 10),
     * источники лежат вне радиуса башни.

4. **envMap.test.ts**

   * Создаём HallEnvMap:

     * envMap не null,
     * diffuseEnvMap не null,
     * `envMap.mapping` == `THREE.CubeReflectionMapping` или `EquirectangularReflectionMapping`.

---

### 15.6.11. Что ты должен увидеть глазами

После реализации 15.6 (на фоне 15.1–15.5):

1. **Зал сверху больше не пустота.**

   * Над стенами — реальный купол:

     * с рёбрами, панелями, карнизом,
     * с богатой формой, соответствующей стилю стен.

2. **Центр верха зала светится.**

   * Через «окно»/небесный круг льётся мягкий свет:

     * башня сверху читается,
     * верхние ряды кубов красиво подсвечены.

3. **Свет «обнимает» башню.**

   * Есть чёткое направление основного света (тени),
   * но при этом золото не превращается в чёрные пятна:

     * виден объём кубов,
     * платформа/паркет блестят,
     * стены переливаются рельефом.

4. **Никаких белых шариков.**

   * Источники света не выглядят как «лампы в кадре»,
   * всё светит «из архитектуры»: от купола, от ниш, от пола.

5. **В ultra режиме:**

   * лёгкая дымка сверху,
   * мягкий bloom на самых ярких участках,
   * при желании — тонкие god‑rays от купола вниз.

---




---

## 15.7. Атмосфера зала (air‑VFX, реакция на игру, кинематографичность)

### 15.7.0. Жёсткие инварианты

1. **Читаемость геймплея — святое.**

   * Никакой эффекстной херни, которая:

     * закрывает кубы,
     * мешает видеть силуэты тетримино,
     * делает фон по яркости сравнимым с фигурой.
   * Все эффекты — *слой вокруг*, а не поверх важной информации.

2. **Все атмосферные штуки — полностью отключаемые.**

   * Через `RenderConfig`/debug‑панель:

     * `[ ] Atmosphere enabled`,
     * `[ ] Particles`,
     * `[ ] Color grading`,
     * `[ ] Event pulses`.
   * В low‑режиме — по умолчанию минимальный набор.

3. **Нет строба и эпилептичных вспышек.**

   * Все анимации:

     * плавные, с периодами ≥ 2–3 сек,
     * переходы интенсивности — ease in/out, без резких ступеней.

4. **Zero влияние на доменную логику.**

   * Никакого взаимодействия с `core/`:

     * только «слушаем» события (lock, line clear, danger),
     * сами эффекты живут в `render/` + небольшой `app/`‑прослойке.

5. **Ограничения по производительности.**

   * Для каждого вида эффекта:

     * верхние пределы (`maxParticles`, `maxOverlays`),
     * никаких бесконечных аллокаций в runtime:

       * re‑use буферов,
       * instanced/Grid, `THREE.Points` и т.п.

---

### 15.7.1. Файлы: что трогаем

**Добавляем/меняем:**

* `src/app/events.ts`

  * расширяем/уточняем события, которые интересны атмосфере:

    * `PieceLocked`,
    * `LinesCleared`,
    * `LevelChanged`,
    * `DangerZoneEntered` / `DangerZoneLeft` (когда высота башни > N),
    * `GameOver`.

* `src/app/hallAtmosphereController.ts` *(новый модуль)*

  * вычисляет «состояние атмосферы» на основе событий и времени.

* `src/render/atmosphere/airParticles.ts` *(новый модуль)*

  * частицы в воздухе: пыль, искры, золотые «мотыльки».

* `src/render/atmosphere/eventWaves.ts` *(новый модуль)*

  * волны/пульсации по залу от событий (например, разрушение ряда).

* `src/render/postProcessing.ts`

  * добавляем:

    * лёгкий color grading,
    * vignette,
    * optional film‑grain.

* `src/render/renderConfig.ts`

  * флаги:

    * `atmosphereEnabled: boolean`,
    * `atmosphereParticles: 'off' | 'low' | 'ultra'`,
    * `atmosphereColorGrading: boolean`,
    * `atmosphereEventPulses: boolean`.

* `src/render/sceneRenderer.ts`

  * создание/обновление атмосферных систем,
  * передача им глобального `elapsedTime` и состояния игры.

* `src/render/debugOverlays.ts`, `visualDebugControls.ts`, `visualDebugMode.ts`

  * добавляем контроль и отдельные debug‑режимы для атмосферы.

**НЕ трогаем:**

* всё под `src/core/**`;
* `src/app/destruction/**`;
* `src/render/boardRenderer.ts`, `activePieceRenderer.ts`, `towerFootprint.ts` (кроме чтения позиций/массивов);
* camera/контролы.

---

### 15.7.2. Общий концепт атмосферы

Хочется, чтобы зал ощущался:

* **живым** — воздух чуть «шевелится»,
* **реагирующим на игру** — зал «вздыхает», радуется, напрягается,
* **монолитным стилем** — всё продолжает золотую эстетку, никаких кислотных вставок.

Три слоя:

1. **Фоновая атмосфера**

   * медленное «дыхание» света и оттенков,
   * лёгкая пыль в воздухе,
   * едва заметные блики в куполе.

2. **Игровые реакции**

   * при уничтожении ряда — мягкая радиальная волна по стенам/полу,
   * при lock — лёгкий всплеск вокруг фигуры,
   * при danger (высокая башня) — зал становится чуть «мрачнее», контрасты усиливаются.

3. **Кинематографический «look»**

   * мягкий vignette (подчёркивает центр),
   * лёгкий тёплый color‑grading (золотистый tint),
   * опциональный тонкий grain для «дорогой картинки».

---

### 15.7.3. HallAtmosphereController (app‑уровень)

**Файл:** `src/app/hallAtmosphereController.ts`

1. **Состояние атмосферы:**

```ts
export interface HallAtmosphereState {
  baseIntensity: number;      // 0..1 — общая «живость» зала
  dangerLevel: number;        // 0..1 — насколько всё напряжённо
  lastLineClearPulse: number; // время с момента последнего очистки ряда
  lastLockPulse: number;      // время с момента последнего lock
  levelMood: number;          // плавный индекс текущего уровня/стадии
  gameOverFade: number;       // 0..1 — сколько "зала" уже погасло
}
```

2. **Контроллер:**

```ts
export class HallAtmosphereController {
  state: HallAtmosphereState;
  update(deltaMs: number, gameSnapshot: GameSnapshot, recentEvents: GameEvent[]): void;
}
```

* `GameSnapshot` — чтение высоты башни, текущего уровня, статуса игры (`running/clearing/gameover`).
* `recentEvents` — список событий за тик.

**Правила:**

* `baseIntensity` медленно колеблется синусом/перлином (очень легонько), чтобы зал не был *совсем* статичным.
* `dangerLevel`:

  * вычисляется по текущей высоте стека (высота / board.height),
  * сглаживается во времени (экспоненциальное сглаживание).
* `lastLineClearPulse` / `lastLockPulse`:

  * сбрасываются при соответствующих событиях;
  * увеличиваются с каждым `deltaMs`.
* `gameOverFade`:

  * растёт от 0 к 1 после `GameOver`.

**Инвариант:**

* Контроллер **не** меняет игру; он — чистый «читатель»:

  * вся логика здесь — перевод игрового состояния в параметры визуальных систем.

---

### 15.7.4. AirParticles: пыль, искры, «золотые пылинки»

**Файл:** `src/render/atmosphere/airParticles.ts`

1. **Общие требования:**

* Частицы:

  * маленькие, полупрозрачные,
  * **всегда** позади тетримино по яркости,
  * количество ограничено (например, до 2–3k в ultra, 500–800 в low).
* Используем:

  * либо `THREE.Points` с текстурой «блика»,
  * либо небольшой instanced quad.

2. **Типы частиц:**

* **DustLayer** — медленная пыль в воздухе:

  * объём: цилиндр/окоёк вокруг башни и платформы,
  * скорость — очень маленькая, лёгкое «парение»,
  * светятся чуть сильнее в зоне «светового окна» купола.

* **SparkLayer** — редкие золотые искры:

  * появляются чуть выше платформы,
  * иногда медленно поднимаются и гаснут,
  * без агрессивной яркости.

* **AmbientSwirl** — едва заметные микроскопические частицы вокруг башни:

  * задают чувство «магического поля».

3. **API:**

```ts
export interface AirParticles {
  group: THREE.Group;
  update(deltaSec: number, atmosphere: HallAtmosphereState): void;
}

export function createAirParticles(
  domeLayout: HallDomeLayout,
  hallLayout: HallLayoutRadii,
  config: RenderConfig
): AirParticles;
```

4. **Зависимость от атмосферы:**

* `baseIntensity`:

  * регулирует общий count активных частиц / яркость.
* `dangerLevel`:

  * слегка ускоряет движение,
  * чуть повышает яркость spark’ов.
* `lastLineClearPulse`:

  * даёт короткие всплески активности (добавить несколько искр, чуть увеличить скорость на 0.5–1 сек).

---

### 15.7.5. EventWaves: волны по залу от событий

**Файл:** `src/render/atmosphere/eventWaves.ts`

1. **Идея:**

* При:

  * `LinesCleared` — по полу/стенам/куполу идёт мягкая световая волна, как от взрыва в замедленном/стилизованном виде.
* Она:

  * не меняет геометрию,
  * только модифицирует:

    * emissive/цвет материалов,
    * либо вводит screen‑space overlay (additive ring).

2. **Подход 1: material wave (per‑fragment)**

* В `textures.ts`/материалах платформы/стен/купола:

  * уже есть `uTime`, `vUv`, позиции.
* Добавляем uniform `uEventWave` с параметрами:

```ts
uniform float waveCenterY;    // вертикальный центр волны
uniform float waveRadius;     // текущий радиус (в world units или normalized)
uniform float waveWidth;      // толщина фронта
uniform float waveStrength;   // 0..1
```

* В шейдерах платформы/стен:

  * вычисляем расстояние от точки до круга (например, по радиусу XZ или высоте Y),
  * подсвечиваем только там, где точка попадает в «кольцо»:

```glsl
float dist = length(worldPos.xz) - waveRadius;
float mask = 1.0 - smoothstep(waveWidth, waveWidth * 2.0, abs(dist));
vec3 waveColor = vec3(1.0, 0.95, 0.8);
totalEmissiveRadiance += waveColor * mask * waveStrength;
```

3. **Подход 2: overlay mesh (если не хочется шейдерных правок)**

* Создаём отдельное тонкое кольцо‑mesh над платформой:

  * радиус растёт с временем,
  * материа — `MeshBasicMaterial` с radial‑градиент текстурой.

* Для стен/купола:

  * либо оставляем только кольцо,
  * либо добавляем второй overlay, повторяющий форму стены (но это сложнее).

4. **API:**

```ts
export interface EventWavesController {
  group: THREE.Group;
  triggerLineClear(level: number, height: number): void;
  update(deltaSec: number): WaveUniformsSnapshot;
}
```

* `WaveUniformsSnapshot` — структура, которую `sceneRenderer` размажет по материалам.

---

### 15.7.6. Color grading, vignette, grain

**Файл:** `src/render/postProcessing.ts`

1. **Vignette**

* Добавляем небольшой screen‑space vignette:

  * затемнение по краям, очень мягкое.

* Реализация:

  * либо собственный shader pass,
  * либо внутри уже существующего пост‑шейдера.

* Параметры:

  * `strength` ≈ 0.1–0.2,
  * `radius` ≈ 0.9.

* Центр vignette настраиваем так, чтобы он примерно совпадал с проекцией башни в viewport.

2. **Color grading**

* Лёгкий тёплый tint:

  * после гамма‑коррекции, перед bloom:

    * добавляем корректировку:

      * слегка поднимаем красный/жёлтый канал,
      * чуть опускаем синий в midtones.

* Параметры завязать на `HallAtmosphereState`:

  * при `dangerLevel → 1`:

    * картинка становится чуть контрастнее,
    * чуть менее насыщенная по золоту (добавить легкую «жёсткость»).

3. **Film grain (опционально)**

* Очень мягкий grain:

  * маленький амплитудой,
  * зависимость от `baseIntensity` (не сильно, просто для живости).

* Реализация:

  * добавляем noise внутри пост‑проц шейдера:

```glsl
float n = fract(sin(dot(gl_FragCoord.xy, vec2(12.9898,78.233)) + uTime*37.0) * 43758.5453);
color.rgb *= 1.0 + (n - 0.5) * grainAmount;
```

* `grainAmount` в ultra: 0.02–0.04, в low — 0 или очень мало.

---

### 15.7.7. Реакции атмосферы на игровое состояние

Здесь всё завязано на `HallAtmosphereController`.

1. **Danger zone (высокая башня)**

* При `dangerLevel > threshold` (например 0.7):

  * слегка:

    * увеличиваем контраст через color grading,
    * уменьшаем яркость fillLights/ambient,
    * чуть усиливаем rimLight’ы (силуэты кубов становятся жестче).

* Но:

  * никаких красных вспышек, просто «зал стал тревожнее».

2. **Line clear**

* `lastLineClearPulse` сбрасывается в 0; первые 0.8–1.5 сек:

  * включаем/усиливаем `EventWaves`:

    * волна по полу/стенам/куполу,
  * чуть повышаем яркость голограмм в нишах.

3. **Piece lock**

* `lastLockPulse`:

  * даёт маленький, быстрый (0.2–0.3 сек) локальный всплеск:

    * можно через EventWaves с маленьким радиусом,
    * либо через лёгкое увеличение glow вокруг платформы.

4. **Level up**

* При повышении уровня:

  * медленный (3–5сек) переход:

    * легкая смена оттенка color grading (на пару градусов по цвету),
    * чуть изменяем темп «дыхания» baseIntensity.

5. **Game over**

* `gameOverFade` растёт от 0 до 1:

  * ambient и fill падают в ноль,
  * envMapIntensity уменьшается (зал «гаснет»),
  * остаётся только soft glow от центрального неба / паркетного медальона,
  * можно сделать лёгкий fade to warm black через post‑processing.

---

### 15.7.8. Debug / tuning

В `visualDebugControls.ts`:

* Раздел **Atmosphere**:

  * `[ ] Atmosphere enabled`
  * `Particles: off / low / ultra`
  * `[ ] Event pulses`
  * `[ ] Color grading`
  * `[ ] Vignette`
  * `[ ] Grain`

* Раздел **Atmosphere state** (readonly):

  * `baseIntensity: 0.00–1.00`
  * `dangerLevel: 0.00–1.00`
  * `lastLineClearPulse: Ns`
  * `gameOverFade: 0–1`

Отдельный режим:

* `Show atmosphere only` — отключить:

  * кубы,
  * платформу,
  * стены,
  * оставить:

    * купол/небо,
    * частицы,
    * eventWaves overlays,
    * пост‑проц.

---

### 15.7.9. Тесты

1. **hallAtmosphereController.test.ts**

* Проверяем:

  * при росте высоты стека `dangerLevel` увеличивается монотонно,
  * события `LinesCleared` и `PieceLocked` корректно сбрасывают/увеличивают `lastLineClearPulse`/`lastLockPulse`,
  * `gameOverFade` растёт до 1 за ожидаемое время.

2. **airParticles.test.ts**

* Создать AirParticles в тестовом renderer:

  * убедиться, что:

    * количество вершин ≤ maxParticles по конфигу,
    * позиции частиц остаются в пределах нужного радиуса/высоты.

3. **eventWaves.test.ts**

* Проверяем:

  * после `triggerLineClear` радиус волны растёт,
  * waveStrength корректно затухает,
  * snapshot подходит под диапазоны (нет NaN/∞).

4. **postProcessingAtmosphere.test.ts** (smoke‑style)

* Проверка, что:

  * при `atmosphereColorGrading = false` картинка ≈ исходный рендер,
  * при включении grading/vignette/grain не вылетает шейдер и параметры в допустимых границах.

---

### 15.7.10. Что ты увидишь глазами

После 15.7 (вместе с 15.1–15.6):

* В зале **появляется жизнь**:

  * мягкая пыль и золотые «пылинки» в воздухе,
  * иногда вспыхивают редкие искорки, подчёркивая магию зала.
* При разрушении ряда:

  * кроме шикарной симуляции осколков
  * ты видишь, как **сам зал откликается**:

    * по полу и стенам бежит световая волна,
    * купол чуть ярче вспыхивает, но аккуратно.
* Когда башня подбирается к верху:

  * свет становится чуть жёстче,
  * зал как будто «замирает» и подталкивает тебя не косячить.
* При обычной игре:

  * картинка «дышит» как дорогой рендер:

    * лёгкий vignette,
    * мягкий тёплый tint,
    * крошечный grain,
    * но всё вместе **не мешает**, а подчёркивает богатство сцены.




---

## Этап 15.8. Реальная оптимизация (performance, quality‑профили, бюджеты)

### 15.8.0. Жёсткие инварианты

1. **Геймплей и домен не трогаем.**

   * Всё в `src/core/**` и игровая логика в `src/app/**` остаётся как есть.
   * Оптимизация — **только** в:

     * `render/**`,
     * конфиге качества,
     * порядках обновления / частоте обновления тяжёлых систем.

2. **Качество по умолчанию не деградируем.**

   * Профиль `ultra` должен визуально соответствовать тому, что вы уже вымучили:

     * башня, зал, осколки, свет, атмосфера — всё включено.
   * Урезание фич — только через явные профили: `high/medium/low`.

3. **Оптимизируем по измерениям, а не «по ощущениям».**

   * Вводим:

     * счётчики времени по подсистемам,
     * FPS/frametime монитор,
     * простую «телеметрию» в debug‑панели.

4. **Никаких магических скрытых авто‑подкручиваний.**

   * Авто‑деградация (если и будет) только:

     * с явной индикацией профиля,
     * и через настройки, понятные человеку.

---

### 15.8.1. Файлы и структуры

**Добавляем:**

* `src/render/perf/perfMetrics.ts`

  * учёт timing per subsystem.

* `src/render/perf/perfConfig.ts`

  * quality‑профили, бюджеты.

* `src/render/perf/perfOverlay.ts`

  * небольшой HUD с fps/frametime/переключателем профилей.

**Модифицируем:**

* `src/render/renderConfig.ts`

  * добавляем поля для пресетов качества и флагов heavy‑фич.

* `src/render/sceneRenderer.ts`

  * оборачиваем обновление/рендер подсистем в perf‑метрики,
  * учитываем quality‑настройки.

* `src/render/destruction/fragmentInstancedMesh.ts`, `instanceUpdater.ts`

  * уважаем пределы `maxFragments`, `maxSimultaneousExplosions`.

* `src/render/atmosphere/**` (когда появится после 15.7)

  * адаптируем частоту/количество частиц под профили.

* `src/render/postProcessing.ts`

  * включение/отключение тяжёлых эффектов по профилю.

---

### 15.8.2. PerfMetrics: измеряем, где реально больно

**Файл:** `perfMetrics.ts`

1. **Структура счётчиков**

```ts
export interface PerfSample {
  frameTimeMs: number;
  subsystems: {
    gameUpdateMs: number;
    destructionUpdateMs: number;
    renderSceneMs: number;
    postProcessingMs: number;
    atmosphereUpdateMs: number;
  };
}

export interface PerfMetrics {
  last: PerfSample;
  avgFrameTimeMs: number;
  avgFps: number;
  worstFrameTimeMs: number;
  history: PerfSample[]; // ограниченный кольцевой буфер, например 120 кадров
}
```

2. **API**

```ts
export class PerfTracker {
  beginFrame(): void;
  endFrame(): void;

  beginSection(name: PerfSectionName): void;
  endSection(name: PerfSectionName): void;

  getMetrics(): PerfMetrics;
}
```

* `PerfSectionName` — перечисление:

  * `"gameUpdate"`, `"destructionUpdate"`, `"renderScene"`, `"postProcessing"`, `"atmosphere"`.

3. **Интеграция в `sceneRenderer` / главный loop**

* Перед апдейтом игры: `beginSection('gameUpdate') / endSection`.
* Перед/после destructionSim.
* Вокруг рендера сцены.
* Вокруг пост‑процессинга.
* Вокруг апдейта атмосферы/частиц.

4. **Инвариант:**

* Перф‑трекинг **должен** быть выключаемым:

  * через `RenderConfig.perfTrackingEnabled`.
  * В релизе можно поставить по умолчанию `false` (или оставить лёгкую версию без истории).

---

### 15.8.3. Quality‑профили и бюджеты

**Файл:** `perfConfig.ts` + дополнения в `renderConfig.ts`

1. **QualityProfile**

```ts
export type QualityProfileId = 'ultra' | 'high' | 'medium' | 'low';

export interface QualityProfile {
  id: QualityProfileId;
  description: string;

  maxFragmentsPerExplosion: number;
  maxActiveExplosions: number;

  shadowQuality: 'off' | 'low' | 'medium' | 'high';
  envMapResolution: 'low' | 'medium' | 'high';
  atmosphereParticles: 'off' | 'low' | 'medium' | 'high';
  hallLightingQuality: 'ultra' | 'low';

  postProcessing: {
    bloom: boolean;
    bloomStrength: number;
    bloomRadius: number;
    filmGrain: boolean;
    vignette: boolean;
  };

  domeDetailSegments: number;        // сегменты купола по высоте
  wallDetailLevel: 'low' | 'medium' | 'high'; // влияет на количество ниш/лепнины
}
```

2. **Набор стандартных профилей**

* `ultra`:

  * максимум визуалки: то, что у вас сейчас + купол/зал/атмосфера.
  * `maxFragmentsPerExplosion ≈ 128–256`, `maxActiveExplosions ≈ 4–6`.
  * тени `high`, envMap `high`, атмосферa `high`, bloom/grain/vignette включены.

* `high`:

  * немного урезать разрушения и атмосферу:

    * `maxFragmentsPerExplosion ≈ 96–128`,
    * `maxActiveExplosions ≈ 3–4`.
  * тени `medium`, envMap `medium`, атмосфера `medium`.

* `medium`:

  * ещё сильнее:

    * `maxFragmentsPerExplosion ≈ 64`,
    * `maxActiveExplosions ≈ 2`.
  * тени `low` или `off`, атмосфера `low`, bloom ослаблен.

* `low`:

  * упор на fps:

    * `maxFragmentsPerExplosion ≈ 32`,
    * `maxActiveExplosions ≈ 1`,
    * отключаем сложную атмосферу, god‑rays, grain.
  * envMap `low`, простой свет, минимум пост‑проц.

3. **Применение профиля**

* Функция:

```ts
export function applyQualityProfile(profile: QualityProfile, renderConfig: RenderConfig): void;
```

* Внутри:

  * выставляем флаги для уже существующих подсистем:

    * `destructionQuality`, `hallLightingQuality`, `atmosphere...`, `shadowConfig`, `envMapConfig`, `postProcessingConfig`.

---

### 15.8.4. Бюджеты по системам

1. **Разрушения (DestructionSim + фрагменты)**

* В `destructionPresets.ts`, `fragmentCount.ts`, `simulationManager.ts`:

  * уважаем:

    * `maxFragmentsPerExplosion`,
    * `maxActiveExplosions`.

* Если взрывы чаще, чем бюджет:

  * новые взрывы:

    * либо ставим в очередь (ограниченной длины),
    * либо “дешёвый” режим (меньше фрагментов, быстрее fade).

2. **Атмосфера / частицы**

* В `airParticles.ts`:

  * `maxParticles` определяется профилем:

    * ultra: ~2–3k,
    * low: ~300–500.

* Обновление:

  * heavy‑слой (spark) можно апдейтить реже:

    * раз в 2 кадра или по таймеру.

3. **Купол и стены**

* В `goldenDome.ts` / `goldenHallWalls.ts`:

  * параметр detailLevel:

    * `domeDetailSegments`, `wallDetailLevel` зависит от профиля,
    * в low:

      * меньше вертикальных/горизонтальных сегментов,
      * меньше ниш/голограмм.

4. **Пост‑процесс**

* В `postProcessing.ts`:

  * если профиль `< high`:

    * выключаем film‑grain, god‑rays,
    * уменьшаем bloomStrength,
    * можно понижать internal resolution (рендер в рендер‑таргет меньшего размера).

---

### 15.8.5. GPU‑оптимизации (геометрия, тени, текстуры)

1. **Статика: merge/instancing**

* Убедиться, что:

  * стены/купола/платформа:

    * по максимуму **слиты** в пару крупных `BufferGeometry` (с группами материалов),
    * нет сотен мелких `Mesh`, которые могли бы быть объединены.

* Там, где паттерн повторяется (колонны/ниши одинаковой формы):

  * по возможности использовать instancing:

    * `InstancedMesh` для идентичных элементов,
    * разные матрицы трансформации.

2. **Тени**

* В `sceneRenderer`/`lightingRig`:

  * Ограничить, кто кидает тени:

    * башня, осколки, платформа,
    * стены/купол — либо без теней, либо только при ultra/high.

  * Shadow map size:

    * ultra: 2048,
    * high: 1024,
    * medium/low: 512 или отключить shadows.

3. **Текстуры**

* Убедиться, что все atlas:

  * степени двойки по размеру (1024/2048),
  * `minFilter = LinearMipmapLinear`,
  * `magFilter = Linear`,
  * разумный `anisotropy`.

* В low:

  * уменьшить размер атласов в 2 раза (до 512/1024),
  * отключить некоторые нормал‑map’ы, если не критично.

---

### 15.8.6. CPU‑оптимизации: аллокации, циклы

1. **Избегаем новых Vector3/Matrix4 в hot‑loops**

* Проверить:

  * `fragmentSimulation.ts`,
  * `fragmentVelocity.ts`,
  * `airParticles.ts`,
  * любые update‑функции, вызываемые каждый кадр для сотен/тысяч элементов.

* Там, где есть:

  ```ts
  const v = new Vector3(...);
  ```

  внутри циклов — заменить на переиспользуемые временные объекты.

2. **TypedArrays / batch‑обновления**

* При работе с instanced‑атрибутами:

  * обновлять большие буферы блочно (как уже делается в instanceUpdater),
  * не трогать geometry‑структуру в целом после инициализации.

3. **Разделение обновления**

* Для некоторых систем (атмосфера, визуальные event‑waves):

  * можно обновлять с пониженным fps:

    * например, каждые 2–3 кадра,
    * используя накопленный `deltaTime`.

---

### 15.8.7. Perf‑overlay: HUD для реального fps

**Файл:** `perfOverlay.ts`

1. **Минимальный GUI:**

* В углу экрана:

  * текущий FPS,
  * средний FPS,
  * worst‑frame (за последние 2–5 секунд),
  * профиль качества (`ultra/high/medium/low`).

2. **Более продвинутый (в debug):**

* Маленькая горизонтальная гистограмма:

  * `frameTime` за N кадров,
  * цветовая раскраска:

    * зелёный < 16ms,
    * жёлтый 16–24ms,
    * красный > 24ms.

* Breakdown per subsystem:

  * `game / destruction / render / post / atmosphere`.

---

### 15.8.8. Acceptance для 15.8

1. В `ultra` с «обычной» игрой (не спамя искусственно взрывами) — стабильные 60fps на референс‑ПК.

2. В `low` даже при спаме взрывами / частицами:

   * нет слайдшоу,
   * интерфейс отзывчивый.

3. Переключение профилей в debug‑панели:

   * видно, как меняется:

     * количество фрагментов,
     * плотность частиц,
     * качество теней,
     * но игра не ломается и не превращается в мусорную картинку.

---

## Этап 15.9. Debug и диагностика (чтобы баги и лаги ловить, а не гадать)

Теперь сделаем так, чтобы проект был **самодиагностируемым** — и под кодекс, и под тебя.

### 15.9.0. Инварианты

1. Debug‑код **не должен** случайно включаться в боевом билде.

   * Всё за флагами:

     * `isDebugBuild`,
     * query‑параметры (`?visualDebug=1`),
     * фичефлаги.

2. Debug‑инструменты помогают:

   * понять *что* происходит и *где* проблема,
   * а не вмешиваются в домен.

---

### 15.9.1. Debug‑панель: PERF & RENDER вкладки

В `visualDebugControls.ts` / `visualDebugMode.ts`:

1. **Вкладка PERF**

* Показ:

  * FPS + frametime histogram (из PerfOverlay),
  * перечисление подсистем и их средних ms за кадр,
  * текущий `QualityProfile`.

* Контролы:

  * dropdown для смены профиля (ultra/high/medium/low),
  * чекбокс `Perf tracking`.

2. **Вкладка RENDER**

* Тогглы типа:

  * `[ ] Wireframe mode`
  * `[ ] Show bounding spheres`
  * `[ ] Show draw calls budget`
  * `[ ] Freeze destruction`
  * `[ ] Freeze atmosphere`

* Отдельный режим:

  * `[ ] Show complexity heatmap`:

    * цветовое выделение объектов по относительной стоимости (условно: чем больше вершин, тем «краснее»).

---

### 15.9.2. Visual assertions / safety‑оверлеи

1. **Floating/illegal blocks**

* Специальный debug‑слой:

  * проверяет:

    * наличие «висящих» кубов (заполненная ячейка без опоры под ней),
    * выход кубов за допустимый радиус башни.

* В `visualDebugMode`:

  * `[ ] Show invalid cells` — подсвечивает красным (overlay‑кубы/маркеры) там, где инвариант нарушен.

2. **Destruction sanity**

* Проверяем в debug only:

  * суммарный объём осколков для куба ≈ объём куба,
  * нет NaN/Inf в позициях/скоростях.

* Любая аномалия:

  * лог в консоль с подробным описанием,
  * можно опционально визуализировать подозрительные осколки ярким цветом.

---

### 15.9.3. Replay / запись входных команд (микро‑черный ящик)

Чтобы ловить сложные баги/лаги, полезно иметь mini‑replay.

1. **Мини‑лог команд:**

* В `app/gameController.ts`:

  * в debug‑режиме добавляем:

    * логирование последовательности команд (input + timestamp).

```ts
interface InputEventLogEntry {
  timeMs: number;
  type: 'keyDown' | 'keyUp' | 'autoRepeat';
  command: GameCommand;
}
```

* Лимитируем длину лога (например, последние 2–5 минут).

2. **Export**

* В debug‑панели:

  * кнопка `Export replay`:

    * выдаёт JSON:

      * seed генератора фигур,
      * начальный конфиг,
      * список input‑событий,
      * возможно, несколько снэпшотов PerfMetrics по времени.

3. **Import (optional, если захотите)**

* Возможность загрузить такой JSON и прогнать игру в «голом» debug‑режиме без UI:

  * для воспроизведения редкого бага/лага.

---

### 15.9.4. Логирование «аномалий»

1. **Perf‑аномалии**

* Если `frameTime` периодически превышает порог (например, > 50ms более N раз за окно):

  * логируем событие:

    * текущее качество,
    * активные системы (есть ли взрывы, атмосфера, камера летает и т.п.).

* Можно выводить это в debug‑панель:

  * «Perf spikes detected: N за последние 60 секунд».

2. **Геймплейные аномалии (на уровне рендера)**

* Например:

  * если позиция визуального куба резко меняется без соответствующего события в домене,
  * или если height башни в домене ≠ визуально наблюдаемой высоте.

* В таких случаях:

  * лог текстовый,
  * highlight на сцене (через debug‑оверлей).

---

### 15.9.5. Юнит‑ и интеграционные тесты для debug/opt

1. **PerfTracker tests**

* Проверить:

  * секции корректно суммируются,
  * `avgFrameTimeMs` и `avgFps` считаются без NaN/деления на ноль,
  * history огранничен по длине.

2. **QualityProfile tests**

* Для каждого профиля:

  * проверить, что значения в разумных диапазонах,
  * никакой профиль не выставляет, например, отрицательное количество фрагментов.

3. **Debug toggles tests**

* В `visualDebugMode` smoke‑тестом:

  * включить/выключить основные флаги,
  * убедиться, что не падает при включении «atmosphere only», «wireframe» и прочих.

---

### 15.9.6. Acceptance для 15.9

1. У тебя есть **реальный инструмент**, который:

   * показывает fps и frame time,
   * даёт breakdown по подсистемам,
   * позволяет менять пресеты качества и видеть эффект.

2. При любых визуальных странностях:

   * ты можешь включить нужные debug‑оверлеи (wireframe/heatmap/invalid cells),
   * сделать export минимального «replay + perf + конфиг»,
   * кинуть это Кодексу с запросом «по 3d_helper_system.txt найди и вылечи».

3. При лаге:

   * вместо «что‑то лагает» у тебя есть:

     * конкретные числа:

       * destruction 12ms,
       * atmosphere 8ms,
       * postProcessing 10ms,
     * и понятный рычаг:

       * профиль качества, который можно либо подкрутить, либо оптимизировать точечно.

---



Этап 16. Интерактивный Object Inspector (кликни по чему угодно — узнай, что это)
16.0. Инварианты (жёсткие правила)

Работает для ЛЮБОГО объекта на сцене, насколько это вообще возможно:

Mesh, Group, Line, Points, InstancedMesh, Light, Camera, debug‑оверлеи — всё.

Ничего не ломает в геймплее.

Inspector включается только в debug‑режиме (?visualDebug=1 или флаг).

В обычной игре никакого перехвата кликов.

Всегда даёт осмысленную инфу, или честно пишет “я не знаю, что это”, но не молчит.

Есть формат “Copy for LLM” — компактный, структурированный текст, который ты просто вставляешь в промпт Codex’у.

Никаких глобальных “магических” ссылок.

Вся дополнительная инфа привязана к object.userData.debugTag / instanceDebugTag, а не к «угадай по имени».

16.1. Общая архитектура

Новый модуль:

src/render/debug/objectInspector.ts
Отвечает за:

picking (Raycaster + спец‑обработка instanced),

подсветку выбранного объекта,

сбор информации,

выдачу структуры ObjectDebugInfo.

Интеграция:

src/app/visualDebugMode.ts

включает/выключает режим Inspector’а.

пробрасывает события мыши и текущее состояние в renderer.

src/render/debugOverlays.ts

добавляет:

контур/outline/бокс вокруг выбранного объекта,

маркеры для instanced‑элементов.

src/ui/hud.ts или отдельный:

панель/окно Object Inspector с текстовой инфой и кнопкой Copy.

16.2. Debug‑метаданные: чтобы инспектор понимал “что за зверь”

Новый тип:

export type DebugObjectKind =
  | 'towerCell'
  | 'activePiece'
  | 'fragment'
  | 'hallWallSection'
  | 'hallDomeSegment'
  | 'hallFloor'
  | 'hallFootprint'
  | 'atmosphereParticles'
  | 'light'
  | 'camera'
  | 'debugOverlay'
  | 'unknown';


Интерфейс тегов:

export interface DebugTag {
  kind: DebugObjectKind;

  // Откуда объект (чтобы можно было сказать Codex'у "это из такого-то модуля")
  sourceModule?: string;       // 'render/boardRenderer'
  sourceFile?: string;         // 'src/render/boardRenderer.ts'
  sourceFunction?: string;     // 'createBoardInstancedMesh'

  // Доменные детали (заполнять по ситуации)
  boardCoords?: { ring: number; level: number; height: number };
  pieceId?: string;            // 'T', 'L', etc
  fragmentInfo?: {
    shardTemplateId?: number;
    instanceId?: number;
  };
  hallSection?: {
    ring: 'inner' | 'middle' | 'outer';
    segmentIndex: number;      // по окружности
    levelBand?: 'base' | 'mid' | 'crown';
  };
  atmosphereLayer?: 'dust' | 'spark' | 'swirl';

  // Любой произвольный текст/метаданные
  label?: string;
  notes?: string;
}


Helper:

tagObject(obj: Object3D, tag: DebugTag): void

записывает в obj.userData.debugTag.

Для instanced:

instanceDebugTag в userData + логика в инспекторе.

Что сделать:

В местах создания:

башни: boardRenderer, activePieceRenderer → kind = 'towerCell' | 'activePiece', boardCoords.

фрагментов разрушения: fragmentInstancedMesh → kind = 'fragment', fragmentInfo.

пола/footprint: towerFootprint, постамент → kind = 'hallFloor' | 'hallFootprint'.

стен: hallWalls → kind = 'hallWallSection', hallSection.

купол: hallDome → kind = 'hallDomeSegment'.

атмосферы: atmosphere/* → kind = 'atmosphereParticles'.

источников света: lightingRig → kind = 'light', label: 'keyLight' | 'rimLight' | ....

камеры: cameraSetup → kind = 'camera'.

16.3. Picking (клик по объекту)

Файл: objectInspector.ts

Система Raycaster

Имеет ссылку на:

renderer.domElement

camera, scene

В режиме инспектора:

подписывается на события мыши:

mousedown / mouseup / click.

Обработка клика:

Конвертация координат мыши в NDC ((-1..1)).

Raycaster → intersectObjects(scene.children, true).

Разбор результатов:

Берём первое пересечение, удовлетворяющее:

object.visible === true,

object.userData?.debugSelectable !== false (по умолчанию всё selectable).

Для InstancedMesh:

используем intersection.instanceId, сохраняем его.

Выбор приоритетов (если несколько коллизий)

Например:

если попали в fragment и в hallWall одновременно (перекрытие):

можно:

либо брать ближайшее,

либо циклом перебирать при повторных кликах (но это уже усложнение; можно описать как “опционально”).

Состояние инспектора:

interface ObjectInspectorSelection {
  object: Object3D;
  instanceId?: number;
  debugTag?: DebugTag;
  hierarchyPath: string[]; // scene > hall > wallsGroup > section_03 > mesh WallPanel
}


Хранится в синглтоне ObjectInspector.

16.4. Собираем ObjectDebugInfo (что именно показывать)

Тип:

export interface ObjectDebugInfo {
  name: string;
  objectType: string;       // 'Mesh', 'InstancedMesh', 'Group', 'PointLight', ...
  uuid: string;

  hierarchyPath: string[];

  worldPosition: { x: number; y: number; z: number };
  worldRotationEuler: { x: number; y: number; z: number };
  worldScale: { x: number; y: number; z: number };

  geometry?: {
    type: string;
    vertexCount?: number;
    indexCount?: number;
    drawRange?: { start: number; count: number };
    boundingBox?: { min: number[]; max: number[] };
  };

  material?: {
    type: string;
    name?: string;
    metalness?: number;
    roughness?: number;
    emissive?: number[];
    transparent?: boolean;
  };

  instance?: {
    instanceId: number;
  };

  debugTag?: DebugTag;

  // Чисто для LLM
  summaryForLLM: string;
  jsonForLLM: string;
}


Сбор:

Берём:

object.constructor.name,

object.name,

object.uuid,

путь родителей:

const path = []; let p = obj; while (p) { path.unshift(p.name || p.type); p = p.parent; }.

world transform:

object.getWorldPosition, getWorldQuaternion, перевод в Euler.

geometry:

если Mesh:

mesh.geometry.attributes.position.count,

geometry.index?.count,

geometry.boundingBox.

если InstancedMesh:

те же данные, плюс instanceId.

material:

metalness, roughness, emissive, transparent.

summaryForLLM:

Формируем строку вида:

Object: Mesh "TowerCell"
Debug kind: towerCell
Hierarchy: scene > HallRoot > TowerGroup > TowerCellsMesh
World position: {x: 1.23, y: 4.56, z: -7.89}
Board coords: { ring: 12, level: 5, height: 3 }
Geometry: vertices=864, indices=1296
Material: MeshStandardMaterial (metalness=1, roughness=0.3)
Source: src/render/boardRenderer.ts:createTowerCellsMesh


jsonForLLM:

JSON.stringify всего ObjectDebugInfo (но без огромных массивов) с отфильтрованными полями.

16.5. UI: панель инспектора + подсветка объекта

Панель:

В visualDebug UI новый блок: Object Inspector:

строка Selected object: ...

многострочное поле с summaryForLLM;

кнопки:

[Copy summary]

[Copy JSON]

дополнительная инфа:

debugTag.kind, boardCoords, hallSection, и т.п.

Подсветка выбранного объекта:

В debugOverlays.ts:

добавляем:

BoundingBoxHelper / wireframe вокруг объекта,

или outline‑контур (можно просто отдельный LineSegments).

Для instanced:

либо:

генерируем временный Box3 по instance’у,

либо:

создаём временный Mesh‑маркер в позицию instance.

Поведение:

При выборе нового объекта:

старый highlight очищается,

новый создаётся.

В панели можно нажать [Clear selection].

16.6. Формат “для нейросети”

Ключевая фича — чтобы ты мог сделать:

Клик → выбрал херню.

Нажал Copy summary.

Вставил в промпт:

Вот инспектор-дамп объекта:

OBJECT_DEBUG_DUMP_BEGIN
Object: Mesh "TowerCell"
Debug kind: towerCell
Hierarchy: scene > HallRoot > Tower > TowerCellsMesh
World position: {x: 1.23, y: 4.56, z: -7.89}
Board coords: { ring: 12, level: 5, height: 3 }
Geometry: vertices=864, indices=1296
Material: MeshStandardMaterial (metalness=1, roughness=0.3, emissive=[0.1,0.08,0.02], transparent=false)
Source: src/render/boardRenderer.ts:createTowerCellsMesh
OBJECT_DEBUG_DUMP_END


И рядом коротко:
«Вот эта сука странно мерцает/застревает/отрисовывается.»

Codex по этому дампу уже понимает:

что за тип объекта,

где он создаётся,

как он привязан к домену (boardCoords, hallSection),

какой код править.

16.7. Интеграция с существующим debug’ом

В visualDebugControls.ts:

Чекбокс:

[ ] Object Inspector mode.

При включении:

курсор меняется (например, на “прицел” или “pointer”),

обычные клики по сцене больше не управляют камерой/орбитой,

все клики идут в ObjectInspector.

Горячая клавиша:

Например, I:

переключает режим Inspector on/off.

16.8. Тесты / sanity‑checks

Unit-tests (минимум):

objectInspector.buildObjectDebugInfo:

на простом Mesh:

корректно заполняет тип, позицию, path, geometry, material, debugTag.

на InstancedMesh:

корректно указывает instanceId.

Manual checklist:

Кликаешь по:

кубу башни (tower cell) → видишь kind: towerCell, boardCoords.

активной фигуре → kind: activePiece, pieceId.

осколку → kind: fragment, fragmentInfo.

стене → kind: hallWallSection, hallSection.

куполу → kind: hallDomeSegment.

источнику света → kind: light, label: keyLight.

debug‑сетки/footprint → kind: hallFootprint.

Во всех случаях:

панель заполняется,

Copy даёт адекватный текст.

16.9. Acceptance: когда можно сказать “инспектор готов”

Ты можешь:

Кликнуть по любой странной хрени на сцене.

Увидеть:

что это за тип,

откуда оно родом в коде,

к какой доменной сущности привязано (координаты, секция, слой и т.п.).

Нажать Copy summary и вставить прямо в промпт Codex’у.

После этого:

тебе больше не нужно пытаться объяснять:
«там какая-то мразь слева сверху, вроде кусок стены, но не уверен» —
вместо этого ты даёшь Codex’у точный дамп.






---

## Этап 17. Hall / Platform / Footprint Geometry Monitor (heavy artillery)

### 17.0. Жёсткие инварианты (никаких “ну почти нормально”)

Сначала задаём **математически**, что считается правильным. Без этого модель продолжит “подправлять на глаз”.

**17.0.1. Базовый пол башни и Ring A**

* Существует **одна эталонная высота пола башни** `Y_floor`.
* Верхняя поверхность платформы **Ring A** совпадает с этим полом:

> `|Y_top(RingA) - Y_floor| <= ε_floor`
> (ε_floor маленький, например 0.001–0.01, чисто на погрешность математики/float).

* Все **нижние кубы первого уровня башни**:

  * Их **нижняя грань** `Y_cubeBottom` должна совпадать с `Y_floor` с тем же ε.
  * **Не допускается** ситуация, когда AABB куба пересекается с объёмом платформы глубоко внутрь (`penetrationDepth > ε_penetration`).

**17.0.2. Footprint (прицел под башней)**

* Footprint‑декор имеет **свою высоту** `Y_footprint`, и она:

  * Не ниже верхней поверхности Ring A (`Y_footprint >= Y_top(RingA)`).
  * Не выше `Y_top(RingA) + footprintMaxOffset` (например, 0.02–0.05).

* Footprint‑геометрия (кольца, сектора) **никогда полностью не спрятана в платформе**:

  * Минимальная высота вершин `minY(footprint)` ≥ `Y_top(RingA) - ε_floor`.
  * И есть хотя бы часть вершин выше `Y_top(RingA) + ε_floor`.

**17.0.3. Радиусы и порядок колец**

* Есть цилиндр башни с радиусом `R_tower`.
* Есть радиусы:

  * `R_footprintInner` / `R_footprintOuter`,
  * Platform rings: `R_ringAOuter`, `R_ringBOuter`, `R_ringCOuter`, …
* Инварианты:

  * `R_tower < R_footprintInner` (footprint не залезает под башню).
  * `R_footprintOuter < R_ringBOuter` (прицел внутри платформы).
  * Все кольца платформы имеют строгий порядок радиусов:

    * `R_ringAOuter < R_ringBOuter < R_ringCOuter < R_hallInner`.

**17.0.4. Ориентация footprint’а и платформы**

* Верхняя поверхность платформы — **почти горизонтальная**:

  * Нормаль `n_platform` ≈ (0, 1, 0) (расхождение по углу ≤ 1–2°).
* Footprint‑меши (и кольцо, и сектора):

  * Их **локальная “верхняя” нормаль** также ≈ (0, 1, 0).
  * **Отдельные торы/кольца** не имеют нормаль вдоль X или Z — никаких “радуг” из пола.

**17.0.5. “Нет могил под полом”**

* Любой объект с `DebugTag.kind` ∈ {`hallFloor`, `hallFootprint`, `towerCell`, `postamentStep`} **не должен иметь значимую часть объёма ниже уровня “реального пола”** той зоны, где он должен лежать.
* Если AABB пересекается с другим AABB на глубину > `ε_penetration` — считаем, что объект **застрял**.

**17.0.6. Никаких silent‑нарушений**

* Если хоть один инвариант нарушен:

  * В лог попадает **чёткое событие** с именем инварианта, участниками, координатами и глубиной нарушения;
  * В визуальном debug панели горит красным, какой именно инвариант сломан.

---

### 17.1. Слой “классификация сцен” — пометить, что чем является

Чтобы монитор мог осмысленно работать, нужно **однозначно понять, какой меш за что отвечает**.

**17.1.1. Debug‑роли для объектов**

Расширяем `DebugTag` (или аналог):

```ts
type HallDebugKind =
  | 'towerCell'         // кубы башни
  | 'towerRoot'         // группа башни
  | 'platformRingA'
  | 'platformRingB'
  | 'platformRingC'
  | 'platformSide'
  | 'footprintCore'     // базовый footprint (старый)
  | 'footprintDecor'    // новый прицел
  | 'hallInnerShell'
  | 'hallOuterShell'
  | 'hallColumn'
  | 'hallCeiling'
  | 'hallFloor'
  | 'debugOverlay'
  | 'unknown';
```

**17.1.2. Где ставим эти теги**

* `goldenPlatform.ts`:

  * Ring A top → `kind: 'platformRingA'`.
  * Остальные кольца → `platformRingB`, `platformRingC`.
  * Боковые цилиндры → `platformSide`.
* `towerFootprint.ts`:

  * сырой footprint‑wire → `kind: 'footprintCore'`.
* `footprintDecor.ts`:

  * игровой прицел → `kind: 'footprintDecor'`.
* `boardRenderer.ts` / `activePieceRenderer.ts`:

  * instanced‑mesh башни → `kind: 'towerCell'`, плюс данные о уровнях.
* `goldenHallScene.ts`:

  * пол → `kind: 'hallFloor'`;
  * внутренняя оболочка → `kind: 'hallInnerShell'`;
  * колонны → `kind: 'hallColumn'`;
  * купол → `kind: 'hallCeiling'`.

**17.1.3. Функция сборщика сцены (snapshot)**

Создаём модуль, например `src/render/debug/hallGeometrySnapshot.ts`:

* Функция `collectHallSnapshot(scene, camera, configs): HallGeometrySnapshot`.
* Внутри:

  * обходит сцену (`scene.traverse`),
  * собирает все `Object3D` c `debugTag.kind ∈ HallDebugKind`,
  * для каждого считает:

    * world‑позицию,
    * AABB (`Box3`),
    * world‑нормаль (если верхняя поверхность: по центру и смещение вверх/вниз),
    * радиус (если объект примерно в кольцевой зоне).

**Структура HallGeometrySnapshot (упрощённо):**

```ts
interface HallObjectSnapshot {
  id: string;
  kind: HallDebugKind;
  name: string;
  worldPos: [number, number, number];
  bbox: {
    min: [number, number, number];
    max: [number, number, number];
  };
  approxRadiusXZ?: number;
  upNormal?: [number, number, number];
  debugTag?: DebugTag; // чтобы не потерять домен
}

interface HallGeometrySnapshot {
  towerCells: HallObjectSnapshot[];     // хотя бы нижний пояс
  platformRings: HallObjectSnapshot[];  // A/B/C
  platformSides: HallObjectSnapshot[];
  footprints: HallObjectSnapshot[];     // и core, и decor
  hallFloor: HallObjectSnapshot[];
  hallShells: HallObjectSnapshot[];
  others: HallObjectSnapshot[];         // на всякий пожарный
}
```

---

### 17.2. Геометрический монитор: проверяем всё “в цифрах”

Новый модуль: `src/render/debug/hallGeometryMonitor.ts`.

**17.2.1. Тип “нарушение”**

```ts
type InvariantId =
  | 'INV_PLATFORM_RINGA_FLOOR_ALIGNMENT'
  | 'INV_TOWER_BASE_ABOVE_RINGA'
  | 'INV_FOOTPRINT_HEIGHT_RANGE'
  | 'INV_FOOTPRINT_NOT_BURIED'
  | 'INV_FOOTPRINT_ORIENTATION'
  | 'INV_PLATFORM_RING_RADII_ORDER'
  | 'INV_PLATFORM_NO_DEEP_INTERSECTIONS'
  | 'INV_TOWER_NO_DEEP_INTERSECTIONS'
  | 'INV_HALL_FLOOR_NOT_ABOVE_TOWER'
  | 'INV_UNKNOWN_OBJECTS';

interface HallGeometryViolation {
  invariant: InvariantId;
  severity: 'error' | 'warning';
  message: string;
  objectsInvolved: string[];    // id либо name
  details: Record<string, any>; // числа, координаты, радиусы
}
```

**17.2.2. Функции‑проверки**

На вход: `HallGeometrySnapshot`, `HallLayout` / `PlatformLayout`, константы ε.

* `checkPlatformRingAFloorAlignment(snapshot, platformLayout, ε): HallGeometryViolation[]`

  * вычисляем `Y_top_ringA` по AABB платформы или по layout,
  * вычисляем `Y_floor_tower` как минимальный `bottomY` среди `towerCells` первого уровня,
  * сравниваем, логируем нестыковку.

* `checkTowerBasePenetration(snapshot, ε_penetration)`

  * для всех towerCells на первом (и нулевом) уровне:

    * берём AABB,
    * пересекаем с AABB платформы / Ring A,
    * если `penetrationDepth > ε_penetration`, логируем.

* `checkFootprintHeightRange(snapshot, platformLayout, config)`

  * берём все `footprintCore` и `footprintDecor`,
  * считаем minY/maxY,
  * проверяем диапазон относительно `Y_top_ringA`.

* `checkFootprintNotBuried(snapshot, …)`

  * проверяем, что **есть** вершины footprint’а выше уровня `Y_top_ringA + epsilon`,
  * если весь footprint ниже/на уровне → violation (как в твоём кейсе).

* `checkFootprintOrientation(snapshot)`

  * для всех footprint‑объектов:

    * берём upper normal `upNormal`,
    * считаем угол с (0,1,0),
    * если > `maxAngle` (например 5°) → `INV_FOOTPRINT_ORIENTATION`.

* `checkPlatformRingRadiiOrder(snapshot, hallLayout, platformLayout, …)`

  * по AABB колец считаем радиусы (максимальная длина до оси (0,0)):

    * `approxRadiusXZ = sqrt(x²+z²)` по центру bbox,
  * проверяем:

    * `R_ringA < R_ringB < R_ringC` и т.д.
    * `R_tower < R_ringA` и `R_footprintOuter < R_ringB` и т.д.

* `checkHallFloorNotAboveTower(snapshot)`

  * если `Y_top(hallFloor)` > `Y_top_ringA` + ε → это значит, что пол “ушёл вверх” и башня может вязнуть.

И т.д. — закрываем все инварианты из 17.0.

**17.2.3. Главная функция мониторинга**

```ts
export function analyzeHallGeometry(
  snapshot: HallGeometrySnapshot,
  layout: { hallLayout: HallLayout; platformLayout: PlatformLayout },
  config: HallGeometryMonitorConfig
): { violations: HallGeometryViolation[] }
```

* Последовательно вызывает все `check*`.
* Возвращает список нарушений.

---

### 17.3. Визуальный режим “Hall Geometry Debug”

Файл: `src/app/visualDebugMode.ts` + `src/app/hallGeometryDebugPanel.ts`.

**17.3.1. Панель**

* В debug UI новая секция:

> **Hall Geometry Debug**
> [Analyze once] [Auto analyze on scene change]
> Lista:
>
> * ✅ INV_PLATFORM_RINGA_FLOOR_ALIGNMENT
> * ❌ INV_FOOTPRINT_NOT_BURIED (2 issues)
> * ❌ INV_TOWER_BASE_ABOVE_RINGA (1 issue)

* При клике по строке инварианта:

  * подсвечиваются объекты, участвующие в нарушении (через Object Inspector / debugOverlays).

**17.3.2. Визуальные подсказки**

* В `debugOverlays.ts` добавляем:

  * Отображение:

    * цилиндр башни (полупрозрачный),
    * цилиндр footprint’а,
    * платформенные кольца как цветные outline’ы.
  * Для каждой violation:

    * рисуем красные `Box3` вокруг конфликтующих объектов,
    * линию/стрелку, показывающую глубину penetration.

**17.3.3. Export для нейросети**

Кнопка:

> [Copy geometry report for LLM]

Кладёт в буфер текст вроде:

```text
HALL_GEOMETRY_REPORT_BEGIN
Scenario: main_hall
Seed: 42
HallLayout:
  towerRadius: 4.50
  platformRingA.radius: 5.20
  platformRingA.Y_top: 0.00
  ...

Violations:
- INV_TOWER_BASE_ABOVE_RINGA (error)
  message: "tower base cubes intersect platform ring A by 0.23 units"
  objects:
    - towerCell[level=0, ring=12]
    - platformRingA
  details:
    penetrationDepth: 0.23
    towerCell.bottomY: -0.18
    ringA.topY: 0.05

- INV_FOOTPRINT_NOT_BURIED (error)
  message: "footprintDecor minY is below platform top, no vertices above surface"
  objects:
    - footprintDecorMainRing
    - platformRingA
  details:
    footprint.minY: -0.05
    footprint.maxY: -0.02
    ringA.topY: 0.00
HALL_GEOMETRY_REPORT_END
```

Ты просто кидаешь это в промпт и говоришь:
“Исправь платформу/footprint так, чтобы все инварианты прошли, не ломая отношения из HallLayout и др. кода”.

---

### 17.4. Лаборатория HallGeometryLab по 3d_helper_system

Сделаем **отдельный стенд**, где конкретно эти штуки тестируются в отрыве от игры.

**17.4.1. Отдельный режим**

Например: `?visualDebug=1&lab=hallGeometry`.

* Загружается **только**:

  * башня (1–2 уровня),
  * платформенные кольца,
  * footprint,
  * hall floor.

**17.4.2. UI**

* Слайдеры:

  * смещение платформы по Y,
  * высота footprint,
  * масштаб радиусов footprint.
* Кнопка:

  * [Run geometry analysis] (вызывает `analyzeHallGeometry`).
* Лог:

  * показывает зелёным/красным, что сломано.

**17.4.3. Сценарии для тестов**

Юнит‑тесты для `hallGeometryMonitor`:

* “Нормальное состояние” → 0 violations.
* “Опустить весь footprint на 0.1 вниз” → ожидать violation `INV_FOOTPRINT_NOT_BURIED`.
* “Сдвинуть Ring A вверх на 0.2” → violation `INV_PLATFORM_RINGA_FLOOR_ALIGNMENT` + `INV_TOWER_BASE_ABOVE_RINGA`.

---

### 17.5. Логи и баг‑репорты в стиле 3d_helper_system

Чтобы прямо вписаться в `3d_helper_system.txt`:

**17.5.1. Frame‑лог для геометрии**

Мини‑лог (однокадровый snapshot):

```json
{
  "type": "hall_geometry_snapshot",
  "engineVersion": "…",
  "hallLayout": { "...": "..." },
  "platformLayout": { "...": "..." },
  "objects": [
    {
      "id": "platformRingA",
      "kind": "platformRingA",
      "bbox": { "min": [..], "max": [..] },
      "upNormal": [0,1,0]
    },
    {
      "id": "footprintDecorMainRing",
      "kind": "footprintDecor",
      "bbox": { "min": [..], "max": [..] },
      "upNormal": [0.01, -0.99, 0.02]
    }
  ],
  "violations": [
    {
      "invariant": "INV_FOOTPRINT_ORIENTATION",
      "severity": "error",
      "message": "footprint decor ring is vertical; upNormal is not aligned with +Y",
      "objectsInvolved": ["footprintDecorMainRing"],
      "details": {
        "angleToUpDeg": 110.0
      }
    }
  ]
}
```

Эту JSON‑ку можно сохранять в файл и отдавать Codex’у, не объясняя “радуга воткнулась в пол”.

**17.5.2. Bug report шаблон**

Чтобы тебе было проще, можно в AGENTS/инструкции вписать шаблон для Codex:

> “Когда у нас говно с платформой/footprint’ом, сначала:
>
> 1. Запускаем HallGeometryLab и нажимаем ‘Run geometry analysis’.
> 2. Копируем HALL_GEOMETRY_REPORT.
> 3. Скидываем его в промпт и просим исправить геометрию так, чтобы все инварианты были зелёными.”

---

### 17.6. Acceptance: когда этап 17 можно считать готовым

Этап 17 завершён, когда:

1. **Я могу нажать одну кнопку в debug’е** → получить отчёт, где чёрным по белому написано:

   * что конкретно:

     * tower base cubes залезают в платформу на 0.2;
     * footprint лежит ниже пола;
     * кольца платформы перепутаны по радиусу;
   * какие инварианты нарушены,
   * какие объекты в этом замешаны.

2. **Я могу кликнуть по любому странному элементу** (как ты делал с инспектором) и увязать его с отчётом монитора:

   * инспектор говорит “это `footprintDecorMainRing`, `kind = footprintDecor`”,
   * монитор — “он нарушает `INV_FOOTPRINT_NOT_BURIED` и `INV_FOOTPRINT_ORIENTATION`”.

3. **Codex больше не может “переориентировать случайный тор” и сказать “готово”**:

   * любое нарушение тут же сделает красный флаг в панели;
   * тесты `hallGeometryMonitor.test.ts` завалятся.

---
