Сразу к делу: я **не могу физически “проиграть” mp4‑файл**, но у меня есть твои скриншоты + описание, и этого более чем достаточно, чтобы восстановить механику и сделать **очень дотошное ТЗ** для реализации клонa этой мини‑игры.

Ниже я сначала кратко формализую, *что именно происходит в ролике*, а потом превращу это в структурированное ТЗ под реализацию (браузер/JS, без Unity‑подобных движков, но так, чтобы логику можно было перенести и на Python).

---

## 1. Восстановление концепции по ролику и описанию

### 1.1. Внешний вид сцены

1. На чёрном фоне стоит **высокая цилиндрическая башня** из маленьких кубиков.
2. Кубики двух типов:

   * **“Заполненные”** – внешний слой башни, белый “махджонг‑тайл” с красным иероглифом.
   * **Пустые/фон** – жёлтые кубики (внутренняя часть башни, а также пустые места, где нет белых блоков).
3. Внизу заметно **зеркальное отражение башни** – словно стоит на чёрном глянцевом полу.
4. Камера:

   * Статичная, чуть выше середины башни, смотрит немного сверху.
   * Башня визуально не крутится вокруг оси (или крутится минимально, можно считать статичной).

### 1.2. Игровое поле (логика)

Если “развернуть” цилиндр по шву в плоскость – получим **обычное поле Тетриса**:

* По вертикали: высота в несколько десятков блоков (на глаз 20–30).
* По окружности: ширина в несколько десятков колонок (на глаз 24–32 сектора).

Башня – это:

* **Тонкая “стенка” в один куб по радиусу**, образующая кольцо вокруг пустоты.
* Каждая “ячейка” стены – либо занята блоком (белый куб с текстурой), либо пуста (жёлтый фон).
* Пустые ячейки образуют вертикальный зигзагообразный “колодец” – аналог “колодца для I‑фигуры”, как в обычном Тетрисе.

Фактически это:
**2D‑тетрис на поле `width x height` с периодическими границами по `x` (левая и правая сторона склеены в цилиндр)**.

### 1.3. Фигуры

1. Фигуры – классические тетромино из 4 кубиков, но “приклеены” к внутренней поверхности цилиндра:

   * `I`, `O`, `T`, `J`, `L`, `S`, `Z`.
   * На скриншотах видно, например, крест/`T`‑подобную фигуру.
2. Фигура всегда имеет толщину в 1 куб по радиусу → логика целиком в координатах *(x, y)*.

### 1.4. Падение и управление

По ролику + твоё описание:

* Фигура появляется **в верхней части башни**, внутри цилиндра.
* В каждом такте:

  * Фигура опускается вниз по оси цилиндра (`y--`).
  * Игрок:

    * двигает её по окружности (влево/вправо по цилиндру);
    * вращает фигуру вокруг вертикальной оси (как в 2D‑тетрисе относительно собственного центра);
    * может “прибить” фигуру вниз (ускоренное падение / hard drop) в выбранное место.
* Перемещение по окружности:

  * При выходе за край `x < 0` → перенос в `x = width-1`, и наоборот.

### 1.5. Фиксация и очистка “этажей”

1. Когда фигура больше **не может опуститься** (достигла дна или упёрлась в уже стоящие блоки), её кубики:

   * добавляются в массив занятых ячеек;
   * на башне появляются белые кубики в соответствующих местах.
2. После фиксации проверяются все высоты `y`:

   * если определённая окружность полностью заполнена блоками (нет ни одной жёлтой пустой ячейки), считается, что **“этаж собран”**.
3. Эффект очистки:

   * На этой высоте `y` весь **кольцевой слой белых кубиков взрывается наружу**:

     * кубики разлетаются по радиусу, вращаются, рассыпаются (см. кадры 3–4).
   * После завершения анимации:

     * логическая строка очищается;
     * все строки выше опускаются вниз на число удалённых слоёв (обычный “гравити” как в Тетрисе).
4. При необходимости (если одновременно собранно несколько этажей):

   * очищается сразу несколько соседних высотных уровней;
   * анимация может запускаться поочерёдно или одновременно (на видео, судя по всему, кольца рушатся одно или несколько раз за ход).

### 1.6. Поведение башни после очистки

* Визуально видно, что верхняя часть башни “подпрыгивает” / смещается вниз после разрушения кольца – имитация падения верхних слоёв.
* Возможен эффект:

  * зачищенные этажи заменяются новыми сверху (для бесконечного режима);
  * либо просто остаётся пустое пространство в верхней части (как в классическом Тетрисе).

### 1.7. Стартовое состояние (уровень из рекламы)

На скриншотах видно:

* Башня уже **почти вся заполнена блоками**, кроме одного сложного вертикального “колодца” из жёлтых пустых ячеек.
* Это типичный “тетрис‑сетап”: одна узкая шахта, через которую, правильно вставив длинную фигуру `I`, можно **сразу разрушить несколько этажей** подряд.
* Реклама, скорее всего, показывает момент, когда игрок *идеально* ставит фигуру и этажи красиво рушатся.

---

## 2. Формальное ТЗ (под реализацию в браузере / JS)

Ниже — структурированное ТЗ, которое можно напрямую давать ИИ‑кодеру или человеку‑программисту.

---

### 2.1. Общие требования

1. **Платформа:**

   * Основной таргет: браузер (Chrome/Firefox/Edge) на Windows.
   * Использовать чистый JS/TypeScript + WebGL (желательно через Three.js либо аналогичную лёгкую библиотеку, не игровой “движок” уровня Unity/Unreal).
2. **FPS:** цель – стабильные 60 FPS на средних ПК.
3. **Разрешение:** рендер в `window.innerWidth x window.innerHeight`, с адаптивным масштабированием.
4. Логика игры должна быть **полностью отделена** от рендера:

   * ядро пишетcя так, чтобы его можно было использовать и с Python‑рендером (PyOpenGL/pygame, etc.).

---

### 2.2. Игровая логика (модель)

#### 2.2.1. Система координат

1. Игровое поле в логике – **дискретная сетка**:

   * `width` – количество секторов по окружности цилиндра (по умолчанию 24).
   * `height` – количество уровней по высоте (по умолчанию 30).
2. Координаты:

   * `x ∈ [0, width-1]` – индекс сектора по окружности (угол);
   * `y ∈ [0, height-1]` – уровень по высоте (0 – дно, `height-1` – самый верх).
3. Логическая граница:

   * по `x` – **замкнутая**: `x = -1 ⇔ x = width-1`, `x = width ⇔ x = 0`;
   * по `y` – открытая: `y = -1` – “под дном” (стоп), `y = height` – выше поля (скрытая часть появления фигуры).

#### 2.2.2. Представление поля

* `board[y][x] : 0/1` или enum:

  * `0` – пустая ячейка (визуально жёлтый фон).
  * `1` – занятая ячейка (есть блок – белый куб с текстурой).

Дополнительно можно хранить:

* `int colorId` (если позже захочется разноцветные блоки).
* флаг “в анимации разрушения” (для отдельных эффектов).

#### 2.2.3. Набор фигур

1. Список стандартных тетромино (7 шт). Для каждой:

   * Базовая форма в локальных координатах `[(x,y), …]`.
   * Набор вращений (4 ориентации).
2. Локальная система фигуры:

   * центр вращения – как в классическом Тетрисе (лучше использовать матрицу 4x4 для фигур).
3. Каждая фигура в состоянии игры описывается:

   ```text
   struct Piece {
       type   // I, O, T, L, J, S, Z
       rot    // 0..3
       x, y   // позиция базовой точки (например, левый нижний блок фигуры)
   }
   ```

#### 2.2.4. Появление новой фигуры

1. Фигура появляется на высоте `spawnY = height - 1` или немного выше (например, `height`), с частью блоков ещё “за пределами поля”.
2. Появление “по центру”:

   * `spawnX = floor(width / 2)` (с последующей нормализацией по модулю `width`).
3. Если новопоявившаяся фигура **сразу конфликтует** с уже занятыми ячейками – состояние “Game Over”.

#### 2.2.5. Падение / тайм‑степ

1. Игра работает по дискретным **тикам** (game ticks).
2. На каждом тике:

   * Время накапливается, при достижении порога `fallDelay` (зависит от уровня) вызывается попытка `moveDown()`:

     * если фигура может опуститься (`canMove(0, -1)`), `y--`;
     * если не может → `lockPiece()`.
3. Скорость падения:

   * Базовый интервал, например 1 секунда на клетку;
   * С увеличением уровня – уменьшать.

#### 2.2.6. Управление фигурой (логика)

Функции:

* `moveHorizontal(dx)`:

  * `x = (x + dx + width) % width`;
  * проверка коллизии; если есть – откат.
* `rotate(dir)`:

  * изменение `rot` (0..3) с учётом “wall kick” (по аналогии с Tetris).
* `softDrop()`:

  * ускоренное падение (на каждом кадре вызывается ещё один `moveDown`, если возможно).
* `hardDrop()`:

  * пока `canMove(0,-1)` – опускать вниз;
  * затем `lockPiece()`.

Коллизия:

```text
for each block cell (bx, by) of piece in world coords:
    worldX = (piece.x + bx + width) % width
    worldY = piece.y + by
    if worldY < 0 → коллизия (дно)
    if worldY < height and board[worldY][worldX] is occupied → коллизия
```

#### 2.2.7. Фиксация фигуры

Функция `lockPiece()`:

1. Все блоки фигуры записать в `board[y][x] = 1`.
2. Перейти к проверке заполненных линий.

#### 2.2.8. Проверка и очистка окружностей (слоёв)

1. Для каждого уровня `y`:

   ```text
   if all board[y][x] == 1 for all x in [0..width-1]:
       mark y as full
   ```
2. Если нет ни одного полного уровня → просто сгенерировать новую фигуру.
3. Если есть:

   * добавить в список `clearedLayers`.
   * Запустить **этап анимации разрушения**:

     * логика может на время поставить игру на паузу (кроме визуальных эффектов);
     * после анимации применить “гравитацию”.

#### 2.2.9. Гравитация после очистки

После окончания анимации:

* Пусть очищено несколько уровней `y1 < y2 < ...`.
* Удаляем соответствующие строки из `board` и **сдвигаем сверху вниз**:

  * Можно реализовать как:

    ```text
    newBoard = []
    for each y from 0..height-1:
        if y not in clearedLayers:
            newBoard.append(board[y])
    while len(newBoard) < height:
        newBoard.append(emptyRow)
    board = newBoard
    ```
* Т.е. верхние строки “падают” вниз, имитируя опускание этажей.

---

### 2.3. Визуализация / 3D‑рендер

#### 2.3.1. Геометрия сцены

1. **Камера:**

   * Тип: перспективная.
   * Позиция: по оси Z, на уровне чуть выше центра башни.
   * Направление: на центр цилиндра.
   * Приблизительно: `z ≈ 3–4 * radius`, `y ≈ height * blockSize * 0.5`.
2. **Свет:**

   * Один мягкий направленный источник света (вроде “солнца”).
   * Один слабый окружающий (ambient).
3. **Пол:**

   * Тёмный глянцевый диск/плоскость с зеркальным шейдером (reflection or fake reflection текстурой).
4. **Фон:**

   * Чистый чёрный, без неба и объектов.

#### 2.3.2. Башня и блоки (материалы)

1. **Размер одного кубика:** `blockSize = 1.0` (логический).
2. **Радиус цилиндра:** `radius = width * blockSize / (2π)` или подобрать визуально.
3. Каждый занятый блок `board[y][x] == 1` визуализируется как **куб**:

   * Центр куба:

     ```text
     angle = 2π * x / width
     worldX = cos(angle) * radius
     worldZ = sin(angle) * radius
     worldY = y * blockSize
     ```
4. Материалы:

   * Наружные грани куба: текстура плитки Mahjong (white + red character).
   * Внутренние грани (обращённые внутрь цилиндра) можно сделать:

     * либо теми же,
     * либо однотонными (жёлтыми).
5. **Пустая ячейка** (`board[y][x] == 0`):

   * визуально: нет внешнего куба на этом секторе → сквозь “дырку” виден жёлтый внутренний фон/облицовка.
   * для имитации жёлтой внутренней стенки можно:

     * сделать **тонкий внутренний цилиндр** радиусом чуть меньше, покрытый жёлтым материалом.

#### 2.3.3. Отдельная фигура

* Активно падающая фигура рисуется отдельной группой кубиков поверх текущего состояния:

  * каждый кубик — те же материалы, те же вычисления координат, только берутся `x,y` из фигуры.

#### 2.3.4. Анимация падения и движений

1. Падение по высоте:

   * Логика дискретная, но визуально можно интерполировать позицию `worldY` от одной строки к другой плавно за время шага.
2. Перемещение по окружности:

   * также можно анимировать интерполяцией угла между секторами.
3. Вращение фигуры:

   * можно сделать мгновенным или за короткую анимацию (0.1–0.15 сек).

---

### 2.4. Анимация разрушения этажей

#### 2.4.1. Логическая и визуальная часть

1. На момент фиксации и обнаружения заполненных слоёв:

   * Логика помечает их, но **пока не очищает `board`**.
   * Для всех кубиков в этих слоях создаются временные “фрагменты” для анимации.
2. Визуально на протяжении, скажем, 0.5–1 сек:

   * Эти кубики отделяются от башни и:

     * получают случайный импульс по радиусу и немного вверх/вниз;
     * начинают вращаться (случайные угловые скорости);
     * постепенно уменьшают непрозрачность (fade‑out).
3. После окончания анимации:

   * фрагменты удаляются из сцены;
   * логика обновляет `board` (удаляет слои и “роняет” верхние).

#### 2.4.2. Вариант реализации

* Использовать **instanced meshes** (Three.js InstancedMesh) и массив атрибутов:

  * позиции;
  * скоростей;
  * угловых скоростей;
  * времени жизни.
* На каждый кадр обновлять эти атрибуты в шейдере/CPU.

---

### 2.5. Пользовательский интерфейс и управление

#### 2.5.1. Управление на ПК (клавиатура)

* `←` / `→` – перемещение фигуры по окружности (dx = -1 / +1).
* `↑` – вращение по часовой стрелке.
* `Z` – вращение против часовой (опционально).
* `↓` – soft drop (ускоренное падение).
* `Space` – hard drop.
* `P` – пауза.

Опционально:

* `Q` / `E` – лёгкий поворот камеры вокруг башни (для красоты).

#### 2.5.2. HUD

Минимальный набор:

* Счёт (за обычную очистку, за “тетрисы” – несколько этажей сразу).
* Уровень.
* Количество очищенных этажей.
* Превью **следующей фигуры** (можно вывести сбоку в отдельном окошке, плоское 2D).

---

### 2.6. Игровые режимы

1. **Классический бесконечный:**

   * Пустое поле в начале.
   * Постепенно увеличивается скорость падения.
2. **Демо/рекламный сценарий (как в ролике):**

   * Поле предварительно заполнено блоками, образующими красивый “колодец”.
   * Игроку (или скрипту) подаётся фигура, которая даёт многократный “тетрис”.
   * После установки фигуры подряд срабатывает разрушение нескольких этажей с мощными эффектами.

---

### 2.7. Архитектура кода (рекомендация)

Можно сделать так:

1. **Core / Logic (не привязано к рендеру)**

   * `Game` – главный класс:

     * состояние: board, currentPiece, nextPiece, score, level, чувствительность к вводу и пр.;
     * методы: `tick(dt)`, `spawnPiece()`, `movePiece(...)`, `rotatePiece(...)`, `hardDrop()`, `lockPiece()`, `checkLines()`.
   * `Board` – обёртка вокруг двумерного массива.
   * `Piece` – структура фигуры.
2. **Renderer3D**

   * Инициализация сцены, камеры, источников света, пола.
   * Отрисовка башни по состоянию `board`.
   * Отрисовка текущей фигуры.
   * Анимации падения, движения, разрушения.
3. **InputController**

   * Слушает события клавиатуры/мыши.
   * Преобразует в команды для `Game`.
4. **Main Loop**

   * `requestAnimationFrame` → `update(dt)` → `game.tick(dt)` → `renderer.render(gameState)`.

Архитектура должна позволять:

* отдельно тестировать `Game` (например, в Node.js без WebGL).
* при желании написать Python‑клиент, читающий те же структуры данных.

---

### 2.8. Параметры для удобной настройки (константы)

В ТЗ стоит явным списком зафиксировать:

* `BOARD_WIDTH` – число секторов (по умолчанию 24).
* `BOARD_HEIGHT` – число уровней (по умолчанию 30).
* `BLOCK_SIZE` – размер куба.
* `FALL_DELAY_BASE` – базовая задержка падения на первом уровне.
* `FALL_DELAY_MIN` – минимально возможная задержка.
* `LINES_PER_LEVEL` – сколько очищенных слоёв → повышение уровня.
* Время анимаций: падения, вращения, разрушения.
* Радиус цилиндра, параметры камеры (можно как часть конфигурации).

---

### 2.9. Требования к качеству и оптимизации

1. Не создавать/удалять отдельные Mesh‑объекты для каждого кубика на каждом кадре → использовать instancing или batched‑геометрию.
2. Отдельное обновление геометрии только при:

   * фиксации фигуры;
   * очистке/падении слоёв.
3. Активные “обломки” от взрывов должны иметь ограниченный срок жизни (не засорять сцену).
4. Код разбит по модулям, без “спагетти” в одном файле.

---

## 3. Что можно сделать дальше

Когда скажешь “поехали”, можно:

1. На основе этого ТЗ составить **конкретный пошаговый план разработки** (спринты/этапы).
2. Начать с минимального ядра:

   * 2D‑логика цилиндрического Тетриса (без 3D).
   * Потом прикручиваем 3D‑рендер в браузере.
3. Дальше – доводка визуальных эффектов, как в рекламе.

Если хочешь, в следующем шаге я могу:

* либо расписать пошаговый план (что за чем делать),
* либо сразу начать с тобой писать код (например, ядро логики на JS с разворачивающимся полем).
