Codex, СТОП: ничего не ломаем и не “упрощаем”. Делаем 3 точечных улучшения footprint‑лавы.

========================================
0) ЖЁСТКИЕ ИНВАРИАНТЫ (ОБЯЗАТЕЛЬНО)
========================================
0.1 НЕЛЬЗЯ трогать:
- камеру и её логику/радиусы/следящий режим (вообще не лезть)
- логику тетримино, коллизии, board state, падение/lock и т.д.
- BoardToWorldMapper/координаты доски (кроме чтения формул)
- goldenPlatform layout-инварианты (высоты колец, выравнивание пола)
- existing hall/platform invariants tests должны оставаться зелёными.

0.2 МОЖНО трогать только footprint/inlay/lava и FX вокруг него:
- исправить угловое выравнивание footprint
- добавить частицы “искры/угольки”
- добавить дым/пар (реалистично, без колец и без примитивных мешей)

0.3 ЗАПРЕЩЕНО “халтурить”:
- НИКАКИХ PointLight “лампочек” вместо частиц/искр
- НИКАКИХ плоских кольцевых Mesh для дыма (это не дым)
- НИКАКИХ квадратных “пикселей”/квадратных points без нормальной sprite‑map
- НИКАКИХ новых аллокаций в каждом кадре (никаких new Vector3 внутри update)
- НИКАКИХ тысяч draw calls: максимум +2 draw calls (sparks Points + smoke Points)

0.4 Производительность:
- Ultra: max ~512 sparks + max ~128 smoke (или меньше), ОДИН пул, без GC
- Update должен быть O(N), N фиксирован, typed arrays, needsUpdate только атрибутов.

========================================
1) ПРОБЛЕМА №1: footprint НЕ СТЫКУЕТСЯ С КУБАМИ (угловой сдвиг)
========================================
Симптом: кубик “садится” примерно серединой своей нижней грани на границу между двумя footprint‑ячейками.
Это почти всегда означает: footprint построен по центрам колонок, а должен быть по границам (или наоборот).
Наша эталонная математика уже есть в проекте:

- core/coords: getColumnAngle(x,width) = 2π * x / width  (это угол ГРАНИЦЫ колонки)
- BoardToWorldMapper в render/boardToWorldMapper.ts использует:
  centerAngle = getColumnAngle(x,width) + 0.5 * step, где step = 2π/width
  => кубы стоят по центрам, а их границы совпадают с углами x*step.

ЧТО НУЖНО СДЕЛАТЬ:
1.1 Найди в текущем коде footprint/inlay место, где вычисляются углы для “ячейки/сектора/канавы” по ширине.
    - ИЩИ по словам: footprint, inlay, sector, cell, angleStep, thetaStart, thetaLength, width, columns.
    - Там почти наверняка есть формула вида:
      angle = (i + 0.5) * step   ИЛИ angle = i * step + 0.5*step
      Вот это и даёт смещение.

1.2 Введи один КАНОНИЧЕСКИЙ контракт углов для footprint‑канав:
    - step = 2π/width
    - boundaryAngle(i) = getColumnAngle(i,width) + footprintAngleOffsetRad
    - cellSpan = [ boundaryAngle(i), boundaryAngle(i+1) ]
    - cellCenterAngle(i) = boundaryAngle(i) + step/2

    Канавы/границы должны соответствовать boundaryAngle(i), а НЕ centerAngle(i).

1.3 Реализация исправления (выбери один способ и сделай строго):
    Вариант A (предпочтительный): исправить формулу углов в генераторе inlay‑геометрии,
    чтобы канавы реально “вырезаны” в правильных местах.

    Вариант B: если inlay целиком отдельным Group/mesh и симметричен — можно повернуть его group.rotation.y,
    НО только если это реально вращает ГЕОМЕТРИЮ канав и лавы (а не декоративный оверлей).

    В любом случае:
    - лава + стенки канав + обод должны совпадать и вращаться вместе.
    - никаких “провернуть только огоньки” — так снова будет несовпадение.

1.4 Добавь ЯВНУЮ переменную “footprintAngleOffsetRad”:
    - default = 0 (если ось +X — начало колонки 0, как у RingGeometry/BoardToWorldMapper)
    - если нужно — допускается offset = -step/2, но только если докажешь тестом, что это именно то, что надо.

1.5 Диагностика/валидатор (обязательный):
    - В render/debug/hallGeometryMonitor.ts добавь проверку FOOTPRINT_ANGLE_ALIGNMENT:
      вычисли step = 2π/width, и сравни:
        expectedBoundary0 = getColumnAngle(0,width) (т.е. 0)
        actualBoundary0 = footprintAngleOffsetRad (или формула, которую реально используешь)
      и/или проверяй, что “центр ячейки 0” совпадает с mapper‑центром:
        expectedCenter0 = 0.5*step
        actualCenter0 = usedStartAngleForCell0 + 0.5*step
      Ошибка по углу должна быть < 1e-3 рад.
      Если больше — в отчёте мониторинга писать Δrad и Δdeg.

1.6 Тест (обязательный, без визуала):
    - Добавь новый unit test типа src/render/__tests__/footprintAngleAlignment.test.ts
      где:
        width = 16/32
        step = 2π/width
        проверяется:
          cell0SpanStart == approx(0 + offset)
          cell0SpanEnd == approx(step + offset)
          cell0Center == approx(step/2 + offset)
        и что mapper‑центр совпадает с footprint‑центром.

1.7 Визуальный acceptance (обязательный):
    - В game‑mode поставь 1 блок/тетримино на 1 этаж:
      границы кубиков в угловом направлении совпадают с границами footprint‑сектора.
      НЕТ ситуации “центр куба на границе двух ячеек”.
    - Проверить на 4 позициях: x=0, x=width/4, x=width/2, x=3width/4
      (везде совпадение).

========================================
2) ПРОБЛЕМА №2: НЕТ “искр/частиц” от лавы (AAA embers)
========================================
Требование: не лампочки. Нужны реальные частицы:
- мелкие “угольки/искорки” (часто, мягко поднимаются вверх, дрейфуют, затухают)
- редкие “всплески” (короткий burst из нескольких ярких частиц)
- визуально: мягкий glowing sprite (НЕ квадраты), цвет: hot sakura-pink → золото → fade.

2.1 Архитектура (строго):
- Сделай отдельный модуль FX: src/render/footprintLavaFx.ts (или аналог),
  который экспортирует:
  - createFootprintLavaFx({ board, platformLayout, ...config })
  - updateFootprintLavaFx(fx, dtMs, camera, timeMs)
  и возвращает:
  { group: THREE.Group, sparks?: THREE.Points, smoke?: THREE.Points, dispose() }

- В renderer.ts при создании footprint/lava добавь fx.group в сцену как child footprint/inlay,
  чтобы fx наследовал все трансформы и не рассинхронизировался.

- В sceneRenderer.ts в update‑цикле (как updateGoldenHallFx) вызывай updateFootprintLavaFx.

2.2 Частицы искр: строго particle pool + typed arrays
- НИКАКИХ new Vector3 в update.
- Пул фиксированного размера MAX_SPARKS (ultra: 512, medium: 256, low: 128).
- Хранить в typed arrays:
  posX/Y/Z, velX/Y/Z, age, life, size, seed, colorRGB (или temp)
- activeMask либо freeList, чтобы быстро брать свободные слоты.

2.3 Эмиттеры (как выбрать стартовые точки):
- Эмиттеры должны быть привязаны к footprint геометрии:
  - минимум: по одному эмиттеру на колонку (width штук), в центре канавы по радиусу
  - лучше: 2 ряда эмиттеров (innerEdge/outerEdge канавы), чтобы искры были объёмнее
- Эмиттер world pos вычислять теми же углами, что footprint (boundary+center),
  радиус = (inlayInnerRadius + inlayOuterRadius)/2, y = lavaSurfaceY + маленький lift (например 0.01).

2.4 Спавн‑логика (AAA, не “равномерный поток”):
- baseRate: например 40–120 sparks/sec суммарно (зависит от quality)
- burstChance: например 0.4–1.2 burst/sec (случайно), burstSize: 4–10 искр
- Распределение:
  - 70% “тихие угольки”: маленькая скорость, плавно вверх
  - 30% “плюющиеся”: сильнее импульс, небольшой разброс по углу/радиусу

2.5 Физика искр (чтобы не было “топорного полёта”):
- Использовать:
  - buoyancyUp (постоянная вверх), gDown (гравитация вниз), drag (сопротивление)
  - легкий swirl вокруг оси Y: добавь скорость по тангенсу, зависящую от sin(time+seed)
  - micro-jitter: маленький шум в lateral компоненты, чтобы “жизнь” была
- На life:
  - ageNorm = age/life
  - sizeCurve: быстро стартует, чуть увеличивается, потом уменьшается
  - alphaCurve: быстрое появление (0–10%), затем плавное затухание (60–100%)
  - colorCurve: hot white/pink -> warm pink -> golden -> fade

2.6 Рендер искр (САМОЕ ВАЖНОЕ — чтобы не квадраты и не лампы):
- Использовать THREE.Points + BufferGeometry
- Материал НЕ “чистый PointsMaterial без map”.
  Нужно:
  - sprite‑texture (CanvasTexture) с мягким радиальным градиентом + микрошумом
  - blending = AdditiveBlending
  - transparent=true, depthWrite=false, depthTest=true
  - vertexColors=true (цвет на частицу)
  - sizeAttenuation=true
  - toneMapped=false (чтобы bloom/яркость выглядели “сочно”)

- Создай отдельную функцию генерации sprite map:
  src/render/textures.ts (или новый файл footprintFxTextures.ts)
  createSparkSpriteTexture():
    canvas 128x128:
      - ядро белое/розовое
      - несколько колец градиента
      - легкий noise (чтобы частицы не одинаковые)
    выставить правильные фильтры, mipmaps.

2.7 Acceptance sparks:
- Искры видны даже без дебага: они мягкие, светящиеся, НЕ квадраты.
- Они не “стреляют пулемётом” одинаково, а живут нерегулярно.
- Они не пролезают сквозь пол визуально: стартуют чуть над лавой.
- На ultra — красиво, но FPS не падает заметно.

========================================
3) ПРОБЛЕМА №3: НЕТ “дыма/пара” (AAA steam), И НЕ ДОЛЖНО БЫТЬ КОЛЕЦ
========================================
Требование:
- НЕ кольца и НЕ плоская “пластина”/тор.
- Это должны быть пыхи/струйки пара:
  - медленно поднимаются
  - расширяются (size grows)
  - растворяются (alpha fades)
  - слегка “вихрятся” и уходят в сторону (noise/wind)
  - не перекрывают геймплей (умеренная плотность)

3.1 Архитектура:
- Smoke как отдельная система внутри того же FootprintLavaFx:
  smoke: THREE.Points (1 draw call)
  pool MAX_SMOKE (ultra: 128, medium: 64, low: 32)

3.2 Текстура дыма (не квадрат):
- Обязательна sprite map с альфой “дым”:
  canvas 256x256:
    - мягкая форма (не круг идеальный)
    - фрактальный шум/перлин-подобная структура
    - края растворяются
  Итог: CanvasTexture + mipmaps.
- Материал:
  - blending = NormalBlending (или слегка Additive, но очень аккуратно)
  - transparent=true
  - depthWrite=false
  - depthTest=true
  - vertexColors=true (чуть менять оттенок/яркость)
  - toneMapped=true (обычно), но можно false если хочется “светящегося пара”
    (тогда сделать низкую альфу, чтобы не кислотно)

3.3 Шейдер (желательно) для качества:
- Чтобы дым не был одинаковыми “плюшками”, добавь:
  - per-particle rotation (атрибут aRot)
  - лёгкую анимацию UV/noise (time-based distortion) в fragment shader
Если шейдер делать страшно — минимум: rotation можно эмулировать разными текстурами/вариантами,
но предпочтительнее шейдер.

3.4 Спавн дыма:
- два режима:
  A) постоянные тонкие wisps: низкая частота, 1–3 пыха в секунду по кольцу
  B) bubble puffs: при burst искр — 1–3 крупных пыха рядом
- Стартовые точки: те же эмиттеры, но с небольшим рандомным смещением по радиусу и углу.

3.5 Физика дыма:
- Вверх медленно + drift:
  velY = 0.15..0.6
  velXZ = небольшой, зависит от sin/cos(time+seed) (как “турбулентность”)
- drag высокий (чтобы не улетал)
- size увеличивается с возрастом: size = lerp(size0, size1, smoothstep)
- alpha: появление быстро, затем плавное исчезновение
- ограничение по высоте: когда y > lavaY + maxHeight (например 2–3 блока), быстрее fade-out.

3.6 Acceptance smoke:
- Дым НЕ образует кольцо.
- Это отдельные мягкие пыхи/струйки в разных местах.
- Вблизи видно, что он “живой” (не статичная картинка).
- Не мешает видеть тетримино и площадку.

========================================
4) КОНФИГ, DEBUG, ТЕСТЫ (обязательно)
========================================
4.1 renderConfig.ts:
- Добавь секцию типа footprintLavaFx:
  enabled, sparksEnabled, smokeEnabled
  maxSparks, maxSmoke
  sparksRate, burstRate
  smokeRate
  seed
  quality scaling (ultra/medium/low)

4.2 objectInspector:
- На fx.group повесь debugTag.kind = 'footprintLavaFx'
- В userData запиши:
  width, step, footprintAngleOffsetRad, lavaSurfaceY, maxSparks, maxSmoke

4.3 hallGeometryMonitor:
- Добавь в report:
  - footprintAngleAlignmentRad
  - sparksActiveCount, smokeActiveCount
  - предупреждение если count превышает budget или если dt вызывает скачки.

4.4 Tests:
- footprintAngleAlignment.test.ts (обязателен)
- footprintLavaFxInit.test.ts:
  - создаётся без исключений
  - атрибуты нужных размеров
  - лимиты max particles соблюдаются (после имитации update 10 секунд)

========================================
5) ЧЕКЛИСТ ПРИЁМКИ (что должен увидеть человек)
========================================
A) Alignment:
- границы footprint-ячейки совпадают с границами кубиков первого этажа
- нет “пол-куба в одной ячейке, пол-куба в другой”
- проверить в 4 разных углах вокруг башни.

B) Sparks:
- видны мягкие светящиеся искры/угольки, поднимаются от лавы
- иногда всплески (burst)
- не квадраты, не лампы, не “шарики света”
- не пожирают FPS

C) Smoke:
- видно тонкий пар/дымок, отдельные пыхи
- НЕ кольцо и НЕ плоская полоса
- при приближении выглядит “слоисто/шумно”, а не как стикер

========================================
6) ПРИОРИТЕТЫ
========================================
1) Сначала выравнивание footprint (пункт 1) + тест.
2) Потом sparks (пункт 2) + базовый визуал.
3) Потом smoke (пункт 3) + довести до AAA.
4) В конце — debug/report/test/производительность.

ВАЖНО: если где-то есть соблазн “сделать проще” — НЕ делай. Это не примитивный прототип.
