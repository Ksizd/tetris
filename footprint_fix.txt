Codex, сейчас делаем ТОЛЬКО AAA‑искра/плевки лавы (embers + spatter) для footprint‑лавы.
То, что сейчас есть — недостаточно симулятивно. Нужна настоящесть: физика, охлаждение, турбулентность, правдоподобный цвет/свет, и корректный рендер (никаких квадратиков).

==========================
0) ЖЁСТКИЕ ИНВАРИАНТЫ
==========================
0.1 НЕЛЬЗЯ трогать (вообще):
- камеру и её логику (никаких изменений follow/орбиты)
- доменную логику тетриса, коллизии, board state, lock и т.д.
- BoardToWorldMapper и любую математику сетки (кроме чтения для вычисления позиций эмиттеров)
- платформу/зал, их инварианты, footprint‑гравировку/лаву (кроме добавления FX вокруг неё)

0.2 ЗАПРЕЩЕНО “халтурить” искрами:
- НИКАКИХ PointLight “лампочек” вместо искр
- НИКАКИХ плоских колец/торусов/mesh‑пшиков
- НИКАКИХ одинаковых квадратиков points без нормального спрайта/шейдера
- НИКАКИХ “просто летят вверх и исчезают” — это не симуляция
- НИКАКИХ new Vector3/Color в каждом кадре (обязателен пул + typed arrays)

0.3 Производительность (обязательно соблюсти):
- 1 draw call на искры (макс 2, если делаем отдельный halo слой, но лучше 1)
- фиксированный пул частиц, O(N) update, typed arrays
- никаких аллокаций per‑frame, никаких массивов, которые растут
- max sparks (ultra) = 800 (но реальных активных обычно 150–350), medium 400, low 200

0.4 Детерминизм:
- фиксируем seed для PRNG и пишем его в debug‑report
- одинаковый seed + одинаковое время => одинаковые первые N частиц

==========================
1) ЦЕЛЬ: “ЛАВОВЫЙ ПЛЕВОК” И “УГОЛЬКИ” КАК В ЖИЗНИ
==========================
Мы НЕ делаем “магические пшики”.
Мы моделируем 2 класса частиц:

A) Embers (угольки/искорки):
- мелкие, чаще, мягко поднимаются, слегка дрейфуют и завихряются
- быстро яркие (почти бело‑желтые/розовые), потом остывают до оранж/красн, потом гаснут

B) Spatter droplets (брызги лавы):
- реже, но эффектнее: короткий “плевок” — группа частиц с более сильной начальной скоростью
- летят по баллистике дугой, с drag (торможение), иногда “крошатся” (split) на 2–3 мелких эмбера
- визуально: ярче, чуть крупнее, заметный trail/stretch, затем остывание

ВАЖНО: ощущение должно быть “живое”: нерегулярность, разные скорости, турбулентность, охлаждение, не одинаковые траектории.

==========================
2) АРХИТЕКТУРА: ОТДЕЛЬНЫЙ МОДУЛЬ + ЖЁСТКИЙ ПУЛ
==========================
2.1 Создай отдельный модуль FX (название согласуй с кодом проекта, но смысл такой):
- src/render/footprintLavaSparksFx.ts (или рядом с текущим footprint lava fx)
Экспорты:
- createFootprintLavaSparksFx({ footprintInlayRef, board, quality, seed, limits, … })
- updateFootprintLavaSparksFx(fx, dtSec, timeSec, camera)
- fx.group (THREE.Group) для добавления в сцену как child footprint/lava‑группы
- dispose()

2.2 Внутри FX:
- фиксированный пул частиц: MAX
- typed arrays:
  posX/Y/Z, velX/Y/Z
  age, life
  size
  temp (температура/“жар”)
  kind (0 ember / 1 droplet)
  spin (если нужно)
  rand (seed per particle)
  + любые нужные атрибуты для рендера (alpha, stretch, rot)

2.3 Никаких аллокаций per‑frame:
- все временные векторы — один раз, или вообще без них (работа в float)
- обновление буферов — только когда реально меняется (position/color/size)

==========================
3) ЭМИССИЯ: НЕ “равномерный поток”, а СОБЫТИЯ ПУЗЫРЕЙ
==========================
3.1 Мы вводим “bubble events” на лаве:
- В каждый момент времени для кольца лавы существует вероятность события:
  bubblePop: небольшое (embers)
  spatterBurst: редкое (droplets)

3.2 Распределение по месту:
- Эмиттеры привязаны к геометрии канавы (НЕ к миру абстрактно):
  минимум: по одному эмиттеру на колонку (width), в центре канавы
  лучше: 2 полосы эмиттеров (inner/outer edge) для объёма
- Точки эмиссии вычисляй по тем же углам, что и footprint‑сектора (иначе рассинхрон).

3.3 Физически правдоподобные начальные скорости:
- Embers:
  speed0 = 0.2..1.2 (в “блочных” единицах/сек, подгони под масштаб сцены)
  направление: вверх + небольшой тангенс + небольшой радиальный шум
- Droplets:
  speed0 = 1.0..4.0
  направление: вверх + радиальная компонента (наружу от центра кольца) + небольшой тангенс
  иногда: “jet” — узкий конус, чтобы был эффект плевка

3.4 Нерегулярность:
- Нельзя делать одинаковые интервалы.
- Используй poisson‑подобный процесс:
  nextEventTime = time + expRand(rate)
- События:
  - bubblePop: 2–6 embers
  - spatterBurst: 6–18 droplets + 5–12 embers (хвост)

==========================
4) СИМУЛЯЦИЯ ДВИЖЕНИЯ: БАЛЛИСТИКА + DRAG + КОНВЕКЦИЯ + ТУРБУЛЕНТНОСТЬ
==========================
Это сердце “настоящести”. Без этого будет “пшик”.

4.1 Силы/ускорения (приближённо, но убедительно):
- gravity: a_g = (0, -g, 0)   где g подобрать под масштаб (например 3..12)
- drag (воздушное сопротивление):
  НЕ просто “vel *= 0.99”.
  Сделай минимум линейный drag + чуть-чуть квадратичного:
  a_drag = -k1 * v - k2 * |v| * v
  (k2 особенно важен для droplet, чтобы дуга была реалистичней)
- buoyancy / convection (подъём горячего воздуха):
  a_buoy = (0, b * tempNorm, 0)
  где tempNorm = temp/temp0 (0..1), b = 1..6 (подбирай)
- turbulence field (критично для “живости”):
  Используй curl-noise‑подобное поле или псевдо‑curl:
    a_turb = turbStrength * curlNoise(pos*freq + time*speed)
  Если полноценный curl сложно:
    сделай 3D шум и возьми ротированную разность (псевдо‑curl), но чтобы были вихри, а не дрожь.

4.2 Охлаждение (цвет/яркость зависит от температуры):
- temp(t) = temp0 * exp(-coolRate * age)
- Для droplets coolRate меньше (они остывают чуть дольше), для embers больше
- Когда temp < threshold:
  - частица темнеет (color -> тёмно‑красный)
  - alpha быстрее падает
  - можно “убивать” частицу раньше, чтобы не копить мусор

4.3 Фрагментация droplet (очень улучшает реализм):
- Для droplet с некоторой вероятностью на age ~ 0.15..0.35 сек:
  split на 2–3 части:
  - новые частицы: embers
  - скорость = часть старой + небольшой разлёт
  - temp наследуется * 0.7..0.9
Это создаёт ощущение “брызг/крошения”.

4.4 Коллизии (минимально, но убедительно):
- Если частица падает ниже уровня пола/платформы:
  - либо “splat”: spawn 2–5 micro‑embers + убить droplet
  - либо bounce (очень аккуратно, 1 отскок максимум, иначе цирк):
    v.y = -v.y * restitution (0.15..0.35)
    v.xz *= friction (0.5..0.8)
  Embers лучше НЕ бить, пусть “гаснут” раньше.

4.5 Интегратор:
- semi‑implicit Euler (v += a*dt; p += v*dt) достаточно
- Но dt ограничь: если dt > 1/30, делай substeps 2–3 (иначе рывки)
- В debug report логируй, когда включился substep.

==========================
5) РЕНДЕР: НИКАКИХ КВАДРАТИКОВ. ДОЛЖНО БЫТЬ “СВЕТЯЩЕЕСЯ ЯДРО + ХАЛО + СТРЕАК”
==========================
Если сделать тупо PointsMaterial — будет “детсад”.
Делаем нормально.

5.1 Геометрия:
- Один InstancedMesh с billboard‑квадом (2 треугольника) ЛИБО Points с кастомным шейдером.
Я рекомендую InstancedMesh с кастомным ShaderMaterial (больше контроля: rotation + stretch + halo).

5.2 Атрибуты инстанса:
- instancePos (можно через матрицу или отдельным атрибутом)
- size
- rot
- stretch (зависит от скорости)
- color/temp
- alpha

5.3 Шейдер (обязателен, иначе “квадратики”):
Vertex:
- billboard к камере (right/up из viewMatrix)
- растягивание вдоль скорости:
  - посчитай vDir в view space
  - смещай вершины по vDir * stretchFactor
  - добавь rot вокруг оси взгляда (рандом)

Fragment:
- shape не должен быть квадратом:
  - используем radial falloff: r = length(uv*2-1), alpha *= smoothstep
  - добавь шум (простая hash noise) чтобы края были “живые”
- цвет от температуры:
  - сделай 1D LUT (массив 6–10 цветов) или формулу blackbody approx
  - начало: hot white/pink -> warm pink -> orange -> red -> dark
- яркость/эмиссия:
  - additive blending
  - intensity зависит от temp^p (p ~ 1.5..3)
  - когда temp падает, частица становится менее “ядро‑яркая”, остаётся мягкое свечение и исчезает

5.4 Trail / streak:
- stretch = base + speed * k
- Для droplets stretch сильнее.
- Это создаст “искры летят” вместо “точки летит”.

5.5 Soft particles (опционально, но если уже есть depthTexture — включи):
- при близости к поверхности “смягчай” альфу, чтобы не было жестких пересечений.
Если depthTexture сейчас не используется — сделай это как “ultra-only” и выключаемо.

5.6 Пост‑эффекты:
- если есть bloom — искры должны участвовать.
- либо материал toneMapped=false, чтобы bloom “цеплял” яркие пиксели.

==========================
6) DEBUG/ТЕСТЫ: ДАТЬ “ГЛАЗА” И НЕ ПОВТОРИТЬ ЦИРК
==========================
6.1 В visualDebug/hallGeometry debug добавить чекбоксы:
- showSparkEmitters (показать точки эмиттеров маленькими маркерами)
- freezeSparks (заморозить)
- stepSparksOneFrame (шаг)
- copySparksReport (в clipboard JSON)

6.2 SparksReport (JSON) должен содержать:
- seed, quality, dt, substeps
- activeCounts (embers/droplets)
- sample 10 частиц: pos, vel, temp, age, kind
- любые нарушения инвариантов (ниже)

6.3 Инварианты (runtime asserts в dev):
- ни одна частица не спавнится ниже lavaSurfaceY - eps
- скорость не NaN/Inf
- count не превышает MAX
- dt substep включается при dt>threshold и отражается в отчёте

6.4 Тесты (vitest):
- determinism test: при фикс seed и dt первые N позиций совпадают
- budget test: за 30 секунд симуляции activeCount <= MAX
- no-allocation smoke test (если есть возможность): хотя бы проверка, что массивы не растут

==========================
7) ВИЗУАЛЬНЫЙ ACCEPTANCE (если это не выполняется — считаем провалом)
==========================
A) Искры НЕ квадратики и НЕ “пшики”.
- При приближении виден мягкий shape, ядро+halo, нет “квадратной точки”.

B) Есть 2 характера:
- постоянные угольки (embers) мягко поднимаются и вихрятся
- редкие плевки (droplets) дугой, с заметным stretch, иногда крошатся

C) Есть “научное” ощущение:
- траектории не одинаковые, есть drag, дуги, затухание, охлаждение цвета
- частицы не исчезают мгновенно, а остывают/гаснут естественно

D) Производительность:
- ultra не превращает сцену в слайд‑шоу
- 1–2 draw calls максимум на sparks, всё остальное — update typed arrays

==========================
8) ПОРЯДОК ВЫПОЛНЕНИЯ (строго)
==========================
1) Сначала симуляция на голых данных (без рендера): spawn+update+debug report, убедиться что дуги/drag/охлаждение есть.
2) Потом рендер базовый shader (без bloom/soft) — чтобы ушли квадраты.
3) Потом добавить stretch+цвет от температуры.
4) Потом добавить split droplet (если включено).
5) Потом включить bloom/soft (ultra-only).
6) В конце — тесты и debug‑панель.

Если где-то возникает соблазн “сделать проще” — НЕ делай. Это AAA-эффект, а не прототип.
