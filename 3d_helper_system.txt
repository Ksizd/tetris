Ниже — содержание файла `3d_helper_system.txt`, уже в финальном виде (то, что можно сохранять и скармливать моделям).

---

# 3D Helper System

Методология тестовых стендов и диагностик для 3D‑проектов с нейросетью

## 0. Зачем всё это

Нейросеть (Codex, ChatGPT и т.п.) **плохо “чувствует” 3D**:

* путает оси и ориентации;
* двигает объекты не туда (лево/право, вперёд/назад);
* ломает коллизии: застревание, пролёты сквозь стены, дрожание;
* строит геометрию с пересечениями, зазорами, “сломаными” нормалями.

Чисто словами объяснить модели, что “вот этот куб на 5% залез в тот” — тяжело и нервно.
Задача Helper‑системы:

> Превратить поведение 3D‑мира в **цифры, структуру, отчёты и понятные визуалки**, которые легко скормить нейросети и по которым она сможет понять, что именно не так и как это чинить.

Эта методология **не привязана к конкретному проекту**. Примеры (башня, тетрис, персонаж и т.п.) — только иллюстрации, а не прямые инструкции “сделать сейчас”.

---

## 1. Принципы: как дать нейросети “глаза”

### 1.1. Представлять 3D‑состояние как данные

Любая визуальная проблема (“не так выглядит”, “застряло”, “криво повернулось”) должна быть сведена к:

* позициям и векторным величинам;
* ориентациям (quaternion, Euler, базисные векторы `forward/right/up`);
* расстояниям и углам;
* флагам коллизий и спискам пересечений;
* инвариантам (“так должно быть всегда”).

Helper‑система должна уметь **в любой момент** получить:

* список объектов;
* их глобальные и локальные трансформации;
* bounding volumes (сфера, AABB, OBB);
* контакты/коллизии (“кто с кем пересёкся и на сколько”);

и сохранить это в **простом структурированном формате** (`JSON`, `CSV`, текстовый отчёт).

### 1.2. Детерминизм и воспроизводимость

Чтобы модель могла что-то исправить, нужно, чтобы баг:

* воспроизводился **одинаково**;
* имел чётко описанный сценарий.

Для этого Helper‑система должна обеспечивать:

* фиксируемый `seed` генератора случайных чисел;
* запись последовательности входных событий (команды игрока, входной сценарий);
* механизм **replay**:

  * запуск теста с тем же seed + набором команд;
  * получение того же результата.

Опционально:

* возможность **заморозить** симуляцию в момент обнаружения бага и сделать snapshot состояния.

### 1.3. Многоуровневая проверка

Баг может рождаться на любом уровне. Helper‑система должна уметь смотреть на:

1. **Математику и геометрию**
   (векторы, матрицы, quaternions, локальные ↔ глобальные координаты).

2. **Игровую/логическую модель**
   (клетки, целевые ячейки, логические координаты, правила).

3. **Сцену/рендер**
   (позиции и ориентации мешей, коллайдеров, визуальных эффектов).

4. **Взаимодействие и сценарий**
   (какие команды поданы, в какой момент, в каком порядке).

Helper‑система — это набор инструментов, который даёт наблюдаемость на всех этих уровнях.

---

## 2. Слои тестовой инфраструктуры

### 2.1. Геометрический слой (математика и координаты)

Ответственность:

* векторная математика;
* преобразования координат (матrices, quaternions);
* конвертация между различными системами координат (локальная/мировая, правая/левая).

Helper‑подход:

* Чётко выделенный модуль геометрии.
* Юнит‑тесты на:

  * длину, нормализацию, скалярные и векторные произведения;
  * композицию трансформаций (A ∘ B);
  * вращения вокруг осей (проверки, куда “смотрит” объект после поворота).

Цель — исключить базовые “математические” ошибки (поменяли местами X/Z, знак угла, перепутали порядок умножения матриц).

### 2.2. Слой игровой логики

Ответственность:

* логические объекты и их состояния (сеточные координаты, “клетки”, “слоты”);
* абстрактные коллизии: “занята ли клетка”, “нет ли двух объектов на одной логической позиции”.

Helper‑подход:

* Юнит‑тесты, не зависящие от 3D‑движка:

  * проверки размещения объектов на сетке;
  * корректность удаления/перемещения/поворота логических сущностей;
  * проверка инвариантов логики (например, “не может быть двух блоков в одной клетке”).

### 2.3. Слой сцены и рендера

Ответственность:

* реальные 3D-объекты (меши, материалы, источники света);
* коллайдеры, физика, анимации.

Helper‑подход:

* статические валидаторы сцены (проверка пересечений, ориентаций, масштабов);
* runtime‑мониторы:

  * отслеживание пересечений коллайдеров;
  * измерение penetration depth;
  * проверка соответствия логического состояния и визуального.

### 2.4. Слой взаимодействия и сценариев

Ответственность:

* управление (клавиатура/мышь/геймпад);
* скриптовые сценарии тестов.

Helper‑подход:

* запись сценариев (последовательностей команд во времени);
* воспроизведение этих сценариев;
* генерация рандомизированных сценариев (фуззинг) на основе инвариантов.

---

## 3. Типы тестов и стендов

### 3.1. Юнит‑тесты математики и координат

Цель:

* зафиксировать конвенцию осей (`+X`, `+Y`, `+Z`), ориентаций и операций;
* поймать простые баги до того, как они проявятся визуально.

Типичные проверки:

* “После поворота вокруг оси Y на +90° вектор `forward` (0,0,1) должен стать (1,0,0)”.
* “Преобразование туда и обратно (локальная → мировая → локальная) возвращает тот же вектор (с небольшой погрешностью)”.
* “Ортонормальный базис (`forward`, `up`, `right`) остаётся ортонормальным после серии вращений”.

Такие тесты — фундамент, на который опираются все остальные стенды.

### 3.2. Статические проверки сцены (scene validators)

Цель:

* выявить проблемы в сцене/ресурсах до запуска интерактивной логики.

Возможные проверки:

* **Пересечения мешей/коллайдеров в стартовом состоянии**
  (объекты изначально “впечатаны” друг в друга).
* **Зазоры ниже минимума**
  (меньше, чем может отобразить engine без артефактов).
* **Слишком большие/маленькие масштабы**
  (объекты в 1000 раз больше ожидаемого, плавающие точности).
* **Ориентация ключевых объектов**
  (камера, персонаж, глобальные оси).

Результат — отчёт с перечнем нарушений.

### 3.3. Динамические сценарные стенды

Цель:

* тестировать поведение объектов во времени, в типичных сценариях.

Идея:

* каждый стенд — это маленький мир, в котором:

  * минимум объектов;
  * понятный сценарий;
  * жёстко прописанные инварианты.

Например (пример, не инструкция):

* “Стенд падения”: объект падает на поверхность под гравитацией, система должна гарантировать:

  * отсутствие пролёта сквозь поверхность;
  * остановку в пределах приемлемого зазора (без подпрыгиваний/дребезга).

Helper‑часть:

* пошагово записывает:

  * позицию;
  * скорость;
  * коллизии;
* сравнивает с инвариантами, логирует нарушения.

### 3.4. Визуальные режимы диагностики

Цель:

* помочь человеку увидеть взаимосвязи, а нейросети — интерпретировать скриншоты.

Полезные режимы:

* прорисовка коллайдеров (wireframe поверх мешей);
* прорисовка нормалей;
* отрисовка опорных осей (`forward/right/up`) для ключевых объектов;
* подсветка областей пересечения (heatmap).

Для помощи модели:

* хранить скриншоты вместе с текстовыми логами;
* в логах явно описывать, что означает тот или иной цвет/оверлей.

### 3.5. Property‑based / фузз‑тесты

Цель:

* находить баги, о которых никто ещё не догадался, через массовый перебор случайных сценариев с проверкой общих свойств.

Примеры свойств:

* “Ни два объекта, которые должны занимать уникальные логические позиции, не имеют физически пересекающихся коллайдеров”.
* “При движении объекта к цели на каждом шаге расстояние до цели не увеличивается, если нет препятствий”.

Стенд:

* случайным образом генерирует начальные позиции, цели, скорости;
* выполняет симуляцию;
* проверяет выполнение свойств;
* сохраняет параметры тех запусков, где свойство нарушено, в отдельный bug report.

### 3.6. Интерактивные “лаборатории”

Цель:

* иметь отдельную изолированную сцену для **каждой важной сущности** или группы связанных сущностей.

Типы лабораторий:

* лаборатория движения;
* лаборатория коллизий;
* лаборатория башни/сеточного поля;
* лаборатория камеры/ориентации.

Внутри каждой:

* контролы (клавиши, слайдеры) для ручного изменения параметров;
* оверлеи с данными;
* кнопка “Export diagnostics”, которая сохраняет все данные эксперимента в удобный формат.

---

## 4. Типовые баги и специализированные мониторы

### 4.1. Переплетение и застревание объектов

**Проблемы:**

* объекты входят друг в друга;
* застревают и не могут разойтись;
* слегка “дрожат” на границе контакта.

**Мониторы:**

1. **Penetration monitor**

   * Для каждой пары потенциально взаимодействующих объектов:

     * вычислять факт пересечения их коллайдеров;
     * измерять глубину penetration.
   * Вводится инвариант:

     * `penetrationDepth <= maxAllowedPenetration`.
   * При нарушении:

     * логировать time, объекты, глубину, позицию контакта.

2. **Stickiness monitor**

   * Отслеживать пары объектов, которые:

     * долгое время находятся в контакте;
     * но при этом между ними есть силы/скорости, которые должны их разъединять.
   * Подозрительные пары логируются как кандидаты на “залипание”.

### 4.2. Неверная ориентация / зеркальность

**Проблемы:**

* объект “смотрит назад”;
* перевёрнут вверх ногами;
* перепутан порядок осей (лево/право).

**Мониторы:**

1. **Orientation validator**

   * Для ключевых объектов задать эталонные направления:

     * `expectedForward`, `expectedUp`.
   * Регулярно считать:

     * угол между текущим и эталонным вектором;
     * если угол > порога — считать ориентацию неверной и логировать.

2. **Handedness validator**

   * Для тройки векторов (`right`, `up`, `forward`):

     * проверять, что `cross(forward, up)` ≈ `right` (или другая согласованная конвенция).
   * Если знак не совпадает — базис “зеркальный”.

3. **Orientation logging**

   * Для проблемных объектов в отчётах всегда указывать:

     * `forward`, `up`, `right` в мировых координатах;
     * Euler‑углы с явным описанием, что такое yaw/pitch/roll и вокруг каких осей;
     * quaternion (на случай корректных вращений без сингулярностей).

### 4.3. Неправильное движение (ошибки направления/скорости)

**Проблемы:**

* объект едет в обратную сторону;
* при “влево” смещение по оси “вперёд”;
* “прыжок” вверх уходит по диагонали.

**Мониторы:**

1. **Trajectory monitor**

   * Логировать траектории:

     * позиции по кадрам;
     * целевой вектор движения;
     * расстояние до целевой точки.
   * Проверять свойства:

     * при движении к цели расстояние не растёт;
     * проекция скорости на целевое направление не меняет знак.

2. **Input→Movement mapping log**

   * В стендах движения:

     * для каждого кадра логировать:

       * какие команды были активны;
       * фактическое изменение позиции и ориентации.
   * Нейросеть легко видит:

     * “при `MoveLeft` `x` увеличивается, ожидалось уменьшение”.

3. **Speed profile monitor**

   * Проверять плавность изменения скорости:

     * отсутствие случайных скачков (кроме спецэффектов);
     * соблюдение максимальной/минимальной скорости.

### 4.4. Прорыв коллизий / проход сквозь стены

**Проблемы:**

* быстрые объекты иногда пролетают через тонкие стены;
* физика не успевает заметить пересечение между кадрами.

**Мониторы:**

1. **Substep comparison**

   * В специальных тестах:

     * прогон симуляции с обычным шагом;
     * прогон той же сцены с уменьшенным шагом (substeps).
   * Если colission появляется только при маленьком шаге — флаг потенциального “tunneling”.

2. **Sweep / raycast tests**

   * Между позициями объекта на кадрах:

     * выполнять sweep‑тест/лучевой тест коллайдера;
   * Если sweep пересекает препятствие, а движок решил, что столкновения нет, — логировать.

### 4.5. Несоответствие логики и визуала

**Проблемы:**

* логическая “клетка” одна, визуальный объект стоит мимо;
* ряд считается уничтоженным логически, но визуально кубики ещё видны.

**Монитор: Logical↔Visual consistency**

* Для каждого логического объекта (клетка, элемент поля, персонаж, блок):

  * известна **логическая позиция** (индексы, координаты в сетке);
  * известна **формула отображения** в мировые 3D‑координаты;
  * есть ссылка на визуальный объект.

* Монитор:

  * для каждого шага:

    * вычисляет **ожидаемую** позицию (по формуле);
    * сравнивает с фактической позицией меша;
    * если расхождение > порога — логирует “visual drift”.

* Аналогично — для логики уничтожения:

  * список логически пустых ячеек должен совпадать со списком мест, где **нет** визуального блока.

---

## 5. Форматы экспорта для нейросети

Helper‑система должна уметь выдавать данные в формате:

* **простом** (без движковских внутренних типов);
* **стабильном** (структура не меняется от запуска к запуску);
* **богатом контекстом** (есть и входные условия, и наблюдения, и ожидания).

### 5.1. Лог по кадрам (frame log)

Цель: дать полный “фильм в цифрах”.

Пример структуры:

```json
{
  "scenarioName": "falling_object_on_cylinder",
  "engineVersion": "x.y.z",
  "seed": 12345,
  "frameRate": 60,
  "frames": [
    {
      "frame": 0,
      "time": 0.0,
      "inputCommands": [],
      "objects": [
        {
          "id": "piece_1",
          "role": "piece",
          "logical": { "x": 12, "y": 25 },
          "position": [0.5, 10.0, -2.3],
          "rotationEuler": [0.0, 0.0, 0.0],
          "forward": [0.0, 0.0, 1.0],
          "up": [0.0, 1.0, 0.0],
          "collider": {
            "type": "box",
            "center": [0.5, 10.0, -2.3],
            "extents": [0.5, 0.5, 0.5]
          },
          "contacts": []
        }
      ],
      "events": []
    }
    // ...
  ]
}
```

Нейросеть по такому логу может:

* отследить траекторию объектов;
* увидеть несоответствия логической и визуальной позиции;
* найти момент возникновения бага.

### 5.2. Снимки состояния (snapshot)

Иногда нужен **один кадр**, но очень подробный:

* список всех объектов;
* их трансформации;
* связи parent/child;
* активные состояния/флаги (анимация, физика).

Snapshot:

* используется для воспроизведения проблемного кадра;
* может быть загружен обратно в движок для отладки;
* удобен для нейросети как “одна картинка в цифрах”.

### 5.3. Журналы конфликтов (collision / invariant reports)

Вместо сырых логов на сотни кадров можно иметь компактный отчёт по нарушениям:

```json
{
  "type": "invariant_report",
  "scenario": "tower_layer_clear",
  "violations": [
    {
      "time": 1.233,
      "frame": 74,
      "invariant": "no_interpenetration",
      "objects": ["block_42", "block_57"],
      "penetrationDepth": 0.12,
      "expectedMaxDepth": 0.01,
      "position": [0.5, 3.2, -1.1]
    },
    {
      "time": 1.250,
      "frame": 75,
      "invariant": "logical_visual_alignment",
      "object": "block_42",
      "expectedPosition": [0.5, 3.0, -1.1],
      "actualPosition": [0.5, 2.7, -1.1]
    }
  ]
}
```

Такой отчёт легко прикладывать к промпту как “сырые факты”.

### 5.4. Полноценный bug report для модели

Формат “готового кейса” для ИИ:

```text
## Scenario
Имя стенда, версия движка, что именно тестировалось.

## Expected behavior
Кратко, но формализованно: какой инвариант должен выполняться.

## Observed behavior
Что нарушилось, на каких кадрах, какие объекты задействованы.

## Data
- выдержки из frame log;
- collision / invariant report;
- параметры запуска (seed, шаг времени, размеры объектов).

## Notes
Любые дополнительные наблюдения (скриншоты описываются словами).
```

Это описание + данные = минимальный “пакет” для разумной работы модели над багом.

---

## 6. Как применять Helper‑систему с нейросетью

### 6.1. Постановка задачи “починить баг”

Рекомендуемый шаблон общения с моделью:

1. Объяснить человечески:
   *“Вот такая-то сущность ведёт себя так-то, визуально это выглядит так-то.”*
2. Приложить:

   * краткий bug report;
   * JSON с логами и/или snapshot;
   * (опционально) текстовое описание скриншота/оверлея.
3. Чётко сформулировать, какие **инварианты** нарушены.

И просить:

* не “переписать всё с нуля”, а:

  * найти место в текущем коде, которое отвечает за это поведение;
  * предложить изменение, которое заставит инварианты выполняться.

### 6.2. Инварианты как контракт

Лучше один чёткий инвариант, чем 20 раз “должно нормально работать”.

Типовые формулировки:

* “В любой момент два блока, имеющие разные логические координаты, не должны иметь penetrationDepth > 0.01”.
* “При поступлении команды MoveLeft логический индекс по X уменьшается на 1 (с учётом циклической обёртки по ширине поля)”.
* “После окончания анимации разрушения логически пустые ячейки не имеют визуальных кубов”.

Такие формулировки:

* вшиваются в код через assert’ы/проверки;
* включаются в bug report и промпт к модели.

### 6.3. Использование модели для генерации тестов

Helper‑система — это каркас. Сама нейросеть может:

* предлагать новые стенды;
* писать код сценариев для фуззинг‑тестов;
* расширять список инвариантов.

Главное — при постановке задачи подчёркивать:

* что стенд должен:

  * быть детерминированным;
  * иметь измеримые результаты;
  * использовать уже существующие механизм логов/репортов, а не создавать свой хаос.

---

## 7. Иллюстративные примеры (не прямые инструкции)

### 7.1. Лаборатория падающих объектов на цилиндрическом поле

*Пример для игр с башнями/платформами, не обязательное требование.*

Идея:

* есть цилиндрическая поверхность (поле) и объекты, которые падают и должны “садиться” в ячейки.

Лаборатория:

* даёт возможность:

  * бросать объекты с разных высот и углов;
  * менять параметры гравитации и формы коллайдера;
* Helper‑часть:

  * измеряет:

    * конечную высоту над поверхностью;
    * угол наклона объекта;
    * факт/глубину интерференции с соседними объектами;
  * проверяет:

    * что объект остановился в пределах допустимого зазора;
    * что не залез в соседние ячейки.

### 7.2. Лаборатория ориентации камеры или персонажа

Идея:

* проверить, что камера/персонаж смотрят туда, куда надо, при разных комбинациях вращений.

Лаборатория:

* минимальная сцена: объект + камера;
* есть UI для поворота по yaw/pitch/roll;
* Helper‑часть:

  * отображает текущие векторы `forward/up/right`;
  * логирует угол отклонения от эталонных направлений;
  * фиксирует случаи, когда ориентация нарушает заданную конвенцию (например, “вверх” больше не похож на глобальный `+Y`).

### 7.3. Лаборатория разрушаемых слоёв

Идея:

* для игр, где “этажи”/“ряды” удаляются и что-то падает вниз, проверить:

  * что логика удаления согласована с визуалом;
  * что верхние части корректно “переезжают”.

Лаборатория:

* запускает разные сценарии удаления слоёв;
* Helper‑часть:

  * сравнивает логический список удалённых уровней с фактическим положением блоков после анимации;
  * проверяет, что:

    * нет блоков, оставшихся висеть на удалённом уровне;
    * индексы уровней корректно смещены.

---

## 8. Итоговые рекомендации

1. Helper‑систему всегда держать **отдельным слоем**, а не вплетать прямо в геймплей:

   * отдельные модули для:

     * сбора метрик;
     * визуальных debug‑режимов;
     * экспорта логов и bug reports.

2. Начинать с простейшего:

   * юнит‑тесты математики;
   * статический валидатор сцены;
   * простой frame log.

3. Для каждой новой сложной фичи (движение, башня, фигуры, камера):

   * сразу закладывать лабораторию/стенд;
   * сразу придумывать 2–3 инварианта и включать их в код.

4. При появлении бага:

   * не спорить с нейросетью словами “он же не там стоит”;
   * сначала:

     * описать инвариант, который нарушен;
     * включить мониторинг и логирование;
   * потом отправить модели **данные** + описание.

5. Форматы логов/отчётов:

   * держать неизменными и простыми;
   * по возможности документировать их структуру прямо в этом файле или рядом.

Эта методология предназначена для того, чтобы любой 3D‑проект, управляемый с помощью нейросети, имел **жёсткую систему наблюдаемости и тестов**, превращающую “криво выглядит” в конкретные, понятные модели факты, с которыми уже можно работать кодом.
