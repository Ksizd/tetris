Вот содержимое `convention.txt`, заточенное под этот проект и под работу с ИИ.

---

# Code & Project Conventions

Этот файл описывает **жёсткие правила** оформления и организации кода для проекта.
Любой человек или нейросеть, пишущие код для проекта, должны им руководствоваться **вместе** с `architecture.txt` и `TZ.txt`.

Документ намеренно универсален: он не привязан к конкретным названиям файлов и библиотек, но задаёт стиль и «рамки», внутри которых можно свободно работать.

---

## 0. Общие принципы

1. **Читаемость важнее краткости.**
   Код должен быть понятен человеку, который впервые увидел проект. Краткость не должна идти в ущерб ясности.

2. **Предсказуемость и единообразие.**
   Все модули оформляются по одинаковым правилам: одинаковые паттерны, одинаковое форматирование, одинаковые соглашения по именам.

3. **Явная структура слоёв.**
   Все архитектурные правила из `architecture.txt` обязательны к соблюдению:

   * домен не импортирует рендер/DOM/Three.js;
   * рендер/инфраструктура не вмешиваются в правила игры;
   * ввод не изменяет состояние напрямую.

4. **Маленькие, законченные куски.**

   * Лучше несколько небольших модулей, чем один огромный.
   * Лучше несколько простых функций, чем одна супер‑функция на 200 строк.

5. **Чистые данные на границах.**

   * Между слоями передаются простые структуры данных, без протаскивания через границы чужих типов и зависимостей (например, внутри домена не ходят объекты Three.js).

---

## 1. Технологический стек и базовые настройки

1. **Язык**

   * Предпочтительно: **TypeScript**.
   * Если по каким‑то причинам используется чистый JS — обязательны подробные JSDoc‑типы и строгий стиль, максимально приближенный к TS.

2. **Модули**

   * Используются **ES‑модули** (`import` / `export`).
   * Никаких `require` / `module.exports`.

3. **Версия стандарта**

   * Не ниже ES2020 (допускаются современные возможности: `async/await`, `Map/Set`, `for...of`, optional chaining, etc.).

4. **Глобальный JS в HTML**

   * Запрещён.
     В HTML допускается только подключение скомпилированных/бандленных файлов и минимальная инициализация.

---

## 2. Организация файлов и модулей

### 2.1. Размеры и сложность

* **Файл (модуль)**:

  * целевой размер: 150–300 строк;
  * верхний предел: 500–600 строк;
  * если приближается к 400–500 — нужно **осознанно** думать о разбиении на подмодули.
* **Функция**:

  * целевой размер: до 20–25 логических строк;
  * максимум: 40 строк; больше — разбить на под‑функции.
* **Класс**:

  * если в классе больше 15–20 методов, почти всегда нужно выделить часть логики в отдельный класс/сервис.

### 2.2. Ответственность модулей

Каждый модуль должен иметь одно чёткое описание:

> «Этот модуль отвечает за …»

Если ответ длиннее одного предложения — модуль делает слишком много.

Примеры:

* модуль, отвечающий за вращение и геометрию фигур (домен);
* модуль, отвечающий за визуальное представление башни (рендер);
* модуль, отвечающий за обработку клавиатурного ввода (input).

### 2.3. Зависимости и импорты

* **Никаких циклических импортов.** Если они появляются — это сигнал к пересмотру архитектуры.
* Модули доменного слоя могут импортировать только:

  * другие доменные модули;
  * общие утилиты, не зависящие от браузера/рендера.
* Модули рендера импортируют:

  * свои внутренние утилиты;
  * внешнюю 3D‑библиотеку;
  * DTO/интерфейсы, предоставленные Application/Domain (без внедрения туда трёхмерных классов).
* Модули ввода импортируют только:

  * DOM/Browser API;
  * интерфейсы команд Application‑слоя.

---

## 3. Стиль кода

### 3.1. Общий стиль

* Отступы: **2 пробела**.
* Длина строки: целевой максимум **100 символов**; критический — 120 (длиннее только при крайней необходимости).
* Скобки:

  * `if (...) {` — открывающая на той же строке.
* Обязательно использовать **точки с запятой**.
* Всегда использовать **строгие сравнения** (`===`, `!==`).
* Никаких `var`; только `const` и `let`.

  * `const` по умолчанию;
  * `let` только если переменная реально переназначается.
* Строки — один стиль: **одинарные кавычки** `'...'`, шаблонные литералы `\`${...}`` где нужно.
* Вложенность `if/for` и т.п. не должна превышать ~3–4 уровней; при превышении рефакторить (guard clauses, early returns, вынос в функции).

### 3.2. Функции

* Предпочитать **чистые функции** там, где это возможно (особенно в домене).
* Избегать функций с большим количеством параметров:

  * > 4 параметров — использовать объект параметров.
* Порядок параметров:

  1. обязательные;
  2. необязательные;
  3. options‑объект.
* Не возвращать “магические” структуры без явных типов / JSDoc.

### 3.3. Классы

* Порядок членов класса:

  1. статические поля/методы;
  2. публичные поля;
  3. конструктор;
  4. публичные методы;
  5. защищённые методы;
  6. приватные методы.
* Логика инициализации не должна быть размазана — основная часть инициализации в конструкторе или отдельном методе `init`.
* Запрещены “тяжёлые” операции (загрузка ресурсов, network, DOM‑манипуляции) в конструкторе доменных классов — только в инфраструктурных.

---

## 4. Именование

### 4.1. Общие правила

* **Классы, интерфейсы, перечисления**: `PascalCase`
  Примеры: `GameState`, `BoardModel`, `InputHandler`, `RendererConfig`.
* **Функции и переменные**: `camelCase`
  Примеры: `updateGameState`, `spawnPiece`, `currentScore`.
* **Константы** (глобальные/конфигурационные): `SCREAMING_SNAKE_CASE`
  Примеры: `MAX_BOARD_HEIGHT`, `LINES_PER_LEVEL`.
* **Модули/файлы**:

  * либо `kebab-case` (`game-state.ts`, `input-handler.ts`),
  * либо `camelCase` (`gameState.ts`) — важно **не смешивать стили** внутри проекта.
  * Название файла должно отражать основную сущность: файл с классом `GameState` должен называться соответствующе.

### 4.2. Специфические рекомендации

* Булевы переменные и геттеры:

  * имена с вопросом/смыслом: `isPaused`, `hasClearedLines`, `shouldDrop`.
* Флаги режима/состояния:

  * `mode`, `state`, `phase`, `status` — только с осмысленными значениями (`'running'`, `'paused'`, `'gameOver'`).
* Никаких однобуквенных имён вне коротких циклов (`for (let i = 0; ...)` допустимо).

### 4.3. Слои и роли в именах

Имена должны помогать отличать слой:

* Для домена: `GameState`, `Board`, `Piece`, `GameRules` и т.п.
* Для Application: `GameSession`, `SceneManager`, `CommandBus`.
* Для рендера: `TowerRenderer`, `MeshPool`, `ExplosionEffect`.
* Для ввода: `KeyboardInput`, `InputMapper`.
* Для UI: `HudView`, `MenuView`, `UiManager`.

---

## 5. Комментарии и документация

### 5.1. JSDoc / TS Doc

* Все **публичные** функции и классы (экспортируемые из модулей) должны иметь JSDoc/TS Doc‑комментарий:

  * краткое описание;
  * параметры (`@param`);
  * возвращаемое значение (`@returns`);
  * важные побочные эффекты / инварианты.

### 5.2. Обычные комментарии

Использовать комментарии:

* для объяснения *почему* сделано так, а не иначе (не что делает код — это видно из имени функции);
* для нетривиальных алгоритмов;
* для временных ограничений (`TODO`, `FIXME`).

Формат:

* `// TODO(username): описание задачи`
* `// FIXME(username): что именно багует и что должно быть`

Комментарии не должны описывать очевидное:

```ts
// Плохой пример
// Увеличиваем счёт на единицу
score++;

// Хороший пример
// Короткий бонус всегда даёт минимум 1 очко
score++;
```

---

## 6. Соблюдение архитектурных слоёв

Этот раздел ещё раз фиксирует ограничения:

1. **Domain (Game Core)**

   * Запрещён импорт любых браузерных API (`window`, `document`, `localStorage`).
   * Запрещён импорт библиотек рендера (Three.js и др.).
   * Запрещены побочные эффекты: `console.*`, логирование, таймеры.
   * Разрешены:

     * чистые вычисления;
     * структурированные данные;
     * конфиг, не зависящий от платформы.

2. **Application Layer**

   * Может:

     * вызывать доменные функции;
     * использовать простые утилиты и DTO;
     * работать с временем (`deltaTime`), очередями команд.
   * Не может:

     * напрямую манипулировать WebGL/Three.js сценой (это дело рендера);
     * напрямую лазить в DOM (это дело UI‑слоя).

3. **Rendering / UI / Input / Audio**

   * Могут использовать:

     * Three.js и другие визуальные библиотечки;
     * DOM API, события ввода;
     * WebAudio API.
   * Не могут:

     * менять доменное состояние напрямую;
     * вызывать доменные функции, минуя Application.

Если для решения задачи хочется “быстренько” нарушить это правило — нужно остановиться и придумать решение, **совместимое** с архитектурой (например, через события или DTO).

---

## 7. Обработка ошибок, логирование и `console.log`

1. **Доменные модули**

   * Не логируют вообще.
   * Ошибки внутри домена по возможности выражаются через:

     * расширенные типы результатов (например, `Result`/`Either`);
     * проверки входных параметров и выброс осмысленных ошибок только на границах (если вообще нужно).

2. **Application и инфраструктура**

   * Логирование через единый `Logger`, а не прямой `console.log`.
   * `console.log` допускается только:

     * в экспериментальном/отладочном коде, который не попадёт в финальную сборку;
     * в очень узких местах, обёрнутых флагом debug.

3. **Ошибки**

   * Никаких пустых `catch` без логирования.
   * Если ошибка не критична — логируем в `Logger` и аккуратно восстанавливаемся.
   * Если ошибка критична — даём понятное сообщение в UI и корректно останавливаем игру.

---

## 8. Тесты

1. Тесты пишутся в первую очередь для **домена**:

   * движение и вращение фигур;
   * коллизии;
   * очистка слоёв;
   * подсчёт очков и уровней;
   * игровой цикл (lock piece → clear → spawn).
2. Именование тестов:

   * один файл тестов проверяет один модуль/сущность;
   * имена тестов отражают сценарии (например, `should_clear_full_layer_when_piece_locked`).
3. Тесты не должны зависеть от Three.js, DOM и других инфраструктурных библиотек.
4. Любое найденное баговое поведение сначала фиксируется тестом, затем исправляется код.

---

## 9. Использование внешних библиотек

1. Любая внешняя библиотека должна быть **обёрнута адаптером/фасадом**:

   * чтобы при необходимости её можно было заменить;
   * чтобы не пропускать типы библиотеки сквозь архитектурные границы.
2. Внутри адаптера:

   * допускается “грязный” API библиотеки;
   * наружу выходят аккуратные методы с чистыми типами.
3. Никаких “магических” глобальных зависимостей от библиотек, подключаемых через `<script>`; всё через модульную систему.

---

## 10. Производительность и оптимизации

1. Сначала правильность и чистота архитектуры, потом оптимизации.
2. Для рендера:

   * по возможности использовать instancing, переиспользование геометрий и материалов;
   * не пересоздавать объектов на каждом кадре;
   * анимации делать на данных, а не пересобирать сцену полностью.
3. Для домена:

   * избегать лишних аллокаций в горячих путях (создание временных массивов в циклах и т.п.);
   * не жертвовать читаемостью ради микрооптимизаций, пока нет доказанной необходимости.

---

## 11. Специальные правила для кода, который пишет нейросеть

Этот раздел адресован прямо ИИ‑кодогенератору.

1. **Всегда учитывать архитектуру.**
   Перед генерацией/изменением кода считать, что:

   * `architecture.txt` и `convention.txt` — источник истины;
   * нарушать их нельзя, даже если “так быстрее”.

2. **Не создавать монолитные файлы.**

   * Никогда не пытаться впихнуть весь проект в один `index.js` / `main.ts` / один `HTML`‑файл.
   * При добавлении новой функциональности:

     * определить, к какому слою она относится (Domain, Application, Renderer, UI, Input, Audio, Utils);
     * если в этом слое уже есть подходящий модуль — расширить его;
     * если нет — **создать новый модуль** с понятной ответственностью.

3. **Минимизировать изменения.**

   * При доработке не переписывать существующие модули “с нуля”, если это не оговорено отдельно.
   * Делать локальные изменения, описывая, какие части кода затронуты и почему.

4. **Следить за размерами.**

   * Если генерируемый модуль заметно превышает рекомендованную длину:

     * предложить в ответе, как его разделить;
     * по возможности сразу разбить на несколько модулей.

5. **Соблюдать стиль.**

   * Всегда использовать описанные выше правила форматирования, именования, документации.
   * Не смешивать стили в разных частях проекта.

6. **Явно указывать слой.**

   * При создании нового модуля в комментарии в начале файла указывать его роль, например:

     ```ts
     // Role: Domain – core game rules for piece movement and collisions.
     ```
   * Это помогает людям и ИИ быстрее ориентироваться в коде.

---

Этот `convention.txt` + `architecture.txt` вместе задают “рельсы”, по которым должен ехать весь проект.
Любая новая часть кода (вручную или сгенерированная нейросетью) должна быть совместима **с обоими** документами.

## 12. Использование 3d_helper_system

Этот проект предполагает активную работу с 3D‑логикой и визуалом, поэтому
файл `3d_helper_system.txt` является обязательной частью конвенций. Он задаёт
методологии построения тестовых стендов, лабораторий, логов и диагностических
отчётов для 3D‑сцен.

### 12.1. Общие требования

1. Считается, что при работе над проектом файл `3d_helper_system.txt`
   **всегда доступен** нейросети/разработчику и должен учитываться при любой
   нетривиальной 3D‑работе.
2. Любая задача, которая затрагивает 3D‑аспекты, автоматически подпадает под
   действие этого раздела. К таким задачам относятся:
   - преобразование координат (локальные/мировые, цилиндрическая геометрия и т.п.);
   - движение и ориентация объектов;
   - камера и её поведение;
   - коллизии, физика, проникновение коллайдеров;
   - разрушение/анимация объектов, любые сложные визуальные эффекты.

### 12.2. Обязательное применение методологий Helper‑системы

При реализации или изменении 3D‑логики ИИ/разработчик обязан:

1. **Рассматривать необходимость диагностик.**  
   Не просто «рисовать и смотреть глазами», а думать:
   - какие инварианты должны выполняться;
   - какие данные нужно логировать;
   - какой стенд/лаборатория поможет воспроизвести и измерить поведение.

2. **Опираясь на `3d_helper_system.txt`, предлагать и при необходимости
   реализовывать:**
   - специальные тестовые сцены («лаборатории») для конкретной подсистемы
     (движение, башня, разрушение, камера и т.п.);
   - сбор логов по кадрам (frame log) с позициями, ориентациями, коллизиями;
   - отчёты о нарушении инвариантов (invariant reports) с указанием объектов,
     времени и параметров нарушения.

3. **Не “заглушать” 3D‑баги чисто визуальными твиками.**  
   Запрещается пытаться исправить сложные 3D‑баги (застревание, пролёты сквозь
   стены, неверное направление, зеркальность и т.д.) только подбором чисел или
   «нюансами» в одном месте. Перед исправлением необходимо:
   - сформулировать нарушенный инвариант;
   - собрать данные (логи, репорты) через механизмы из `3d_helper_system.txt`;
   - использовать эти данные для точечного исправления.

### 12.3. Поведение при “застревании” в 3D‑баге

Если:

- один и тот же 3D‑баг обсуждается несколько промптов и словесные описания
  не приводят к устойчивому решению;
- поведение на экране трудно объяснить текстом;
- при правках возникло несколько разных 3D‑багов вокруг одной подсистемы,

ИИ/разработчик должен **переключиться в режим Helper‑системы**. Это означает:

1. Прекратить пытаться чинить баг “на глаз”.
2. Сначала:
   - разработать стенд/лабораторию для этой ситуации;
   - включить логирование (frame log, invariant report) по методикам из
     `3d_helper_system.txt`;
   - описать, какие именно инварианты проверяются.
3. Только после получения и анализа данных — вносить правки в основную логику.

В ответах ИИ должен явно указывать:

- какие типы стендов/логов из `3d_helper_system.txt` он предлагает;
- какие инварианты/проверки вводятся;
- как эти диагностические данные предполагается использовать для дальнейших
  исправлений.

### 12.4. Документирование 3D‑диагностики

При добавлении Helper‑инструментов (стендов, логов, отчётов):

1. В начале соответствующих модулей/файлов следует кратко указать:
   - что именно диагностируется;
   - с какими инвариантами это связано.
2. В комментариях и документации прямым текстом ссылаться на разделы и идеи
   из `3d_helper_system.txt`, чтобы любой разработчик или нейросеть могли
   понять, что логика диагностики построена по этим методологиям.

Таким образом, `3d_helper_system.txt` становится не опциональным “советом”, а
частью формальной конвенции: при работе над 3D‑логикой проект обязан иметь
наблюдаемость и диагностические инструменты, соответствующие этому документу.

