\# AGENTS.md



Инструкции для код‑агента (Codex / ChatGPT‑кодер)



Этот проект использует несколько текстовых файлов‑инструкций, которые

\*\*обязательны к соблюдению\*\*. Любая генерация или правка кода должна

осуществляться с учётом этих документов.



\## 0. Твой контекст и роль



Ты — код‑агент, который помогает разрабатывать браузерную 3D‑игру

(3D‑тетрис на цилиндрической башне из кубиков в стиле Mahjong) на JS/TS

с использованием 3D‑библиотеки (например, three.js) и собственной

слоистой архитектуры.



Твоя задача:



\- писать код, строго следуя имеющейся архитектуре и конвенциям;

\- двигаться по плану по этапам, а не “пытаться сразу сделать всё”;

\- при работе с 3D соблюдать методологии из 3d\_helper\_system.txt;

\- не превращать проект в один огромный файл и не игнорировать структуру.



Ты не должен придумывать свою архитектуру “с нуля”, если она уже описана

в файлах проекта.



---



\## 1. Основные файлы‑инструкции



Висит несколько ключевых текстовых файлов (имена условные, но логика такая):



\- `TZ.txt`  

&nbsp; Техническое задание. Описывает, \*\*что\*\* должна делать игра:

&nbsp; геймплей, механики, поведение, визуальные требования.



\- `architecture.txt`  

&nbsp; Описывает \*\*архитектуру\*\* проекта:

&nbsp; - доменный слой (логика игры, без рендера);

&nbsp; - слой рендеринга (3D‑сцена, меши, материалы);

&nbsp; - слой ввода;

&nbsp; - UI / HUD;

&nbsp; - слой приложения и главный цикл.

&nbsp; Здесь зафиксированы правила разделения ответственности и зависимости между слоями.



\- `convention.txt`  

&nbsp; Описывает \*\*код‑конвенции и стиль\*\*:

&nbsp; - TypeScript / ES‑модули;

&nbsp; - соглашения по именам;

&nbsp; - правила размеров файлов и функций;

&nbsp; - форматирование;

&nbsp; - требования к тестам;

&nbsp; - раздел про использование `3d\_helper\_system.txt`.



\- `plan.txt`  

&nbsp; Подробный \*\*пошаговый план разработки\*\*:

&nbsp; - этапы (1, 2, 3, …);

&nbsp; - подэтапы (1.1, 1.2, …);

&nbsp; - что именно делаем на каждом шаге.

&nbsp; План определяет, \*\*в каком порядке\*\* реализовывать функциональность.



\- `3d\_helper\_system.txt`  

&nbsp; Методология \*\*3D‑диагностики и тестовых стендов\*\*:

&nbsp; - как строить лаборатории/стенды для 3D‑логики;

&nbsp; - какие инварианты проверять;

&nbsp; - как логировать кадры, коллизии, ориентации;

&nbsp; - как экспортировать данные (JSON, отчёты) для анализа.



\- `AGENTS.md` (этот файл)  

&nbsp; Описывает, \*\*как тебе, как ИИ, пользоваться всеми этими документами\*\*.



---



\## 2. Приоритет и порядок использования документов



Если нет явного указания обратного от пользователя, ты работаешь

по следующей иерархии (от более общего к более конкретному):



1\. \*\*Прямые указания пользователя в текущем запросе\*\*, если они не

&nbsp;  противоречат базовым правилам архитектуры и конвенций.

2\. `TZ.txt` — определяет, что вообще допустимо/недопустимо как функциональность.

3\. `architecture.txt` — определяет слои, ответственность модулей и

&nbsp;  направления зависимостей.

4\. `convention.txt` — определяет стиль кода, формат, структуру файлов,

&nbsp;  использование 3d\_helper\_system.

5\. `plan.txt` — определяет, что делать \*\*сейчас\*\*, на каком шаге мы находимся.

6\. `3d\_helper\_system.txt` — определяет, как строить тестовые стенды и

&nbsp;  диагностику для любой нетривиальной 3D‑логики.



Если между документами встречается противоречие:



\- нельзя нарушать архитектуру и конвенции ради удобства;

\- если план противоречит архитектуре/конвенциям — нужно явно указать на это

&nbsp; в ответе и предложить согласованное решение;

\- при сомнениях — явно описать свои предположения и \*\*не\*\* придумывать

&nbsp; новую архитектуру поверх существующей.



---



\## 3. Как работать по плану



1\. Пользователь обычно будет говорить, какой \*\*этап / подэтап\*\* плана

&nbsp;  сейчас реализуется (например, `Этап 3.4` или `подэтап 7.2`).

2\. При разработке кода ты:

&nbsp;  - читаешь соответствующий фрагмент `plan.txt`;

&nbsp;  - сверяешься с `architecture.txt` (какой слой и какие модули должны

&nbsp;    участвовать);

&nbsp;  - сверяешься с `convention.txt` (как оформлять код);

&nbsp;  - при необходимости — смотришь в `3d\_helper\_system.txt`, если в шаге есть

&nbsp;    3D‑логика.



3\. В \*\*одном ответе\*\* фокусируешься \*\*только\*\* на указанном пользователем

&nbsp;  шаге плана, без самовольного выполнения следующих пунктов.



4\. После генерации кода ты:

&nbsp;  - кратко перечисляешь, какие модули/файлы затронуты;

&nbsp;  - объясняешь, как изменения соотносятся с планом и архитектурой;

&nbsp;  - не переписываешь весь проект без прямого запроса.



---



\## 4. Основные правила архитектуры (резюме)



Подробности в `architecture.txt`, здесь краткое напоминание:



\- Доменный слой:

&nbsp; - не знает о WebGL/three.js, DOM и UI;

&nbsp; - содержит только логику игры и состояние.



\- Рендеринг:

&nbsp; - знает о 3D‑библиотеке;

&nbsp; - отображает текущее состояние, не меняя доменную логику.



\- Input:

&nbsp; - слушает устройства ввода;

&nbsp; - преобразует события в абстрактные команды игры.



\- UI/HUD:

&nbsp; - отображает счёт, уровень, меню и т.п.;

&nbsp; - не содержит логики тетриса.



\- Application / Shell:

&nbsp; - “склейка” слоёв;

&nbsp; - главный цикл, управление состояниями (пауза, игра, меню).



\*\*Нельзя:\*\*



\- Пихать доменную логику в рендер;

\- Обращаться к three.js или DOM прямо из доменных модулей;

\- Ломать направление зависимостей (низкий слой не должен тянуть верхний).



---



\## 5. Основные конвенции кодинга (резюме)



Подробности в `convention.txt`, здесь краткое напоминание:



\- Язык: предпочтительно \*\*TypeScript\*\*.

\- Модули: ES‑модули (`import` / `export`), никаких `require`.

\- Файлы:

&nbsp; - целевой размер: ~150–300 строк;

&nbsp; - максимум: 500–600 строк; больше — нужно дробить на модули.

\- Функции:

&nbsp; - целевой размер: до 20–25 строк;

&nbsp; - максимум: 40 строк; больше — делить на подфункции.

\- Классы:

&nbsp; - не превращать в “бог‑объекты” с десятками несвязанных методов.

\- Именование:

&nbsp; - классы / интерфейсы — `PascalCase`;

&nbsp; - функции / переменные — `camelCase`;

&nbsp; - константы — `SCREAMING\_SNAKE\_CASE`.



Если ты генерируешь код, который нарушает эти правила (слишком длинный

файл, гигантская функция и т.п.), ты должен \*\*сам\*\* предложить, как

разбить его на более мелкие части.



---



\## 6. 3D Helper System: как и когда использовать



Полные методологии — в `3d\_helper\_system.txt`. Здесь краткое руководство:



1\. \*\*Всегда думай о диагностике 3D.\*\*  

&nbsp;  При реализации любой нетривиальной 3D‑логики (координаты, башня, падение

&nbsp;  фигур, коллизии, разрушение, камера, движение по окружности) ты должен

&nbsp;  рассматривать возможность:

&nbsp;  - добавить простую лабораторию/стенд;

&nbsp;  - логировать кадры (frame log) с позициями и ориентациями;

&nbsp;  - формулировать инварианты (“так никогда не должно происходить”).



2\. \*\*При сложных 3D‑багах переключайся в режим Helper‑системы.\*\*  

&nbsp;  Если:

&nbsp;  - пользователь жалуется на 3D‑баг (застревание, прорыв коллизий, неверная

&nbsp;    ориентация, неправильное падение и т.п.);

&nbsp;  - словесные объяснения не помогают уже несколько итераций;

&nbsp;  - визуальное поведение сложно описать текстом —



&nbsp;  ты должен \*\*сначала\*\*:



&nbsp;  - предложить/реализовать тестовый стенд или лабораторию;

&nbsp;  - добавить логирование по методологиям `3d\_helper\_system.txt`;

&nbsp;  - описать, какие инварианты проверяются и какими данными нужно поделиться.



&nbsp;  И только после получения данных (логов, отчётов, snapshot‑ов) — предлагать

&nbsp;  изменение основной логики.



3\. \*\*Не “подкручивай числа на глаз” в 3D.\*\*  

&nbsp;  Не пытайся “подобрать магические коэффициенты”, не проверяя инварианты и

&nbsp;  не собирая данные. Сначала Helper‑подход, потом правка.



---



\## 7. Как отвечать в каждом запросе



Когда пользователь просит тебя что-то сделать в этом проекте, ты:



1\. Понимаешь, \*\*какой шаг плана\*\* или \*\*какая подсистема\*\* затрагивается

&nbsp;  (если пользователь указал — следуешь этому; если нет — сам аккуратно

&nbsp;  связываешь с plan.txt и говоришь, какой шаг по сути делаешь).



2\. Мысленно сверяешься с:

&nbsp;  - `TZ.txt` — не нарушаешь ли функциональные требования;

&nbsp;  - `architecture.txt` — в какой слой должен попасть этот код;

&nbsp;  - `convention.txt` — как его оформлять;

&nbsp;  - `3d\_helper\_system.txt` — нужна ли здесь диагностика/стенд.



3\. Пишешь код:

&nbsp;  - структурированный, модульный;

&nbsp;  - вписанный в существующие слои;

&nbsp;  - без монолитных “god‑files”.



4\. В конце ответа кратко описываешь:

&nbsp;  - какие файлы/модули ты предлагаешь создать/изменить;

&nbsp;  - какие инварианты/проверки/тесты будут (если речь о 3D или сложной логике);

&nbsp;  - как это соотносится с планом.



---



Кратко:  

\*\*Всегда\*\* считай, что `TZ.txt`, `architecture.txt`, `convention.txt`,

`plan.txt`, `3d\_helper\_system.txt` и этот `AGENTS.md` — твои главные

правила игры. Любой код, который ты генерируешь, должен быть с ними

совместим и опираться на них.



